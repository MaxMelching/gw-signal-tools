# -- Standard Lib Imports
from __future__ import annotations  # Enables type hinting own type in a class
from typing import Optional, Any, Literal, Callable

# from functools import cached_property
# TODO: use for .fisher and .fisher_inverse?
# -> ah, would perhaps not work if we project it for example

# -- Third Party Imports
import numpy as np
import matplotlib as mpl
from gwpy.frequencyseries import FrequencySeries
from gwpy.types import Array
import astropy.units as u

# -- Local Package Imports
from ..units import preferred_unit_system
from ..logging import logger
from ..waveform import (
    get_wf_generator,
    inner_product,
    norm,
    overlap,
    optimize_overlap,
    get_default_opt_params,
    _INNER_PROD_ARGS,
    time_phase_wrapper,
    apply_time_phase_shift,
)
from ..types import MatrixWithUnits
from .fisher_utils import fisher_matrix


__doc__ = """
Module for the ``FisherMatrix`` class.
"""

__all__ = ('FisherMatrix',)


class FisherMatrix:
    r"""
    A data type tailored to Fisher matrices. It stores the Fisher matrix
    itself, along with its inverse. Allows for matrix projection and
    calculation of SNR,  statistical + systematic biases (with and
    without alignment) via simple calls of class attributes.

    Parameters
    ----------
    point : dict[str, ~astropy.units.Quantity]
        Point in parameter space at which the Fisher matrix is
        evaluated, encoded as key-value pairs representing
        parameter-value pairs. Given as input to :code:`wf_generator`.
    params_to_vary : str or list[str]
        Parameter(s) with respect to which the derivatives will be
        computed, the norms of which constitute the Fisher matrix.
        Must be a key in :code:`point` or one of :code:`'time'`,
        :code:`'phase'`.

        For the latter, analytical derivatives are applied. This is
        possible because they contribute only to a factor
        :math:`\exp(i \cdot phase - i \cdot 2 \pi \cdot f \cdot time)`
        in the waveform generated by `wf_generator`, i.e. they are
        global phase and time shifts.
        Beware that the polarization angle :code:`psi` might be
        degenerate with :code:`phase`, if you are using the complex
        strain combination :math:`h = h_+ + i \, h_{\times}`.

        The last analytical derivative is the one for the luminosity
        distance :math:`D_L`, which enters in waveforms only as an
        amplitude factor :math:`1/D_L`. Note that can only be done
        if the parameter recognized, i.e. if it is called `'distance'`.
    wf_generator : Callable[[dict[str, ~astropy.units.Quantity]], ~gwpy.frequencyseries.FrequencySeries]
        Arbitrary function that is used for waveform generation. The
        required signature means that it has one non-optional argument,
        which is expected to accept the input provided in
        :code:`point`, while the output must be a ``~gwpy.
        frequencyseries.FrequencySeries`` (the standard output of
        LAL gwsignal generators) because it carries information about
        value, frequencies and units, which are all required for the
        calculations that are carried out.

        A convenient option is to use the method
        :code:`~gw_signal_tools.waveform_utils.get_wf_generator`, which
        generates a suitable function from a few arguments.
    direct_computation : boolean, optional, default = True
        Whether to compute the Fisher matrix upon intialization of the
        class. Usually, this should be the preferred behaviour, but in
        certain cases one might want to save the computation time (e.g.
        if a systematic error shall be computed, where the Fisher
        matrix might be computed in some optimized point and not the one
        given by :code:`point`).
    metadata :
        All other keyword arguments will be treated as input for
        metadata of the Fisher matrix. This metadata consists of
        information relevant for derivative calculation. In particular,
        all settings for the inner products that are involved all the
        time can be specified here (e.g. the power spectral density or
        frequency range).

    See Also
    --------
    gwsignal.fisher.fisher_matrix :
        Routine used for calculation of the Fisher matrix.
    gwsignal.fisher.get_waveform_derivative_1D_with_convergence, gw_signal_tools.fisher.get_waveform_derivative_1D_numdifftools:
        Routine used for calculation of involved derivatives. Used by
        `~gwsignal.fisher_utils.fisher_matrix`.
    numpy.linalg.inv :
        Routine used for inversion of the Fisher matrix.

    Notes
    -----
    In principle, instances of this class constain much more information
    than "just" the Fisher matrix ``FisherMatrix.fisher``, for example
    its inverse ``FisherMatrix.fisher_inverse``. However, to provide an
    intuitive behaviour and remembering the class name, certain
    operations/calls return attributes related only to the actual matrix
    stored in ``FisherMatrix.fisher`` (for example array-conversion).
    """

    default_metadata = {
        'deriv_routine': 'gw_signal_tools',
    }

    _preferred_units = preferred_unit_system
    # Idea: display stuff in these units, i.e. apply .to_system to each matrix before saving them
    # -> even better idea: one could apply .to_system to every input
    # parameter for conversion, the functions will just keep units
    # TODO: make setter etc. for it
    # -> the thing is that one can just pay attention to input units in
    #    point, right? So the overhead of implementing all this stuff
    #    would not be worth it I think

    def __init__(
        self,
        point: dict[str, u.Quantity],
        params_to_vary: str | list[str],
        wf_generator: Callable[[dict[str, u.Quantity]], FrequencySeries],
        direct_computation: bool = True,
        **metadata,
    ) -> None:
        """Initialize a ``FisherMatrix``."""
        self.point = point
        self.wf_generator = wf_generator
        self.params_to_vary = params_to_vary
        self.metadata = self.default_metadata | metadata
        # -- We rely on return_info = True, thus set it now
        self.metadata['return_info'] = True

        if len(self.metadata) > len(self.default_metadata) + 1:  # +1 for return_info
            # -- Arguments for inner product may be given, extract
            self._inner_prod_kwargs = {}
            for key in _INNER_PROD_ARGS:
                if key in metadata:
                    # -- get with default None is potentially bad, some
                    # -- arguments might have this value too
                    self._inner_prod_kwargs[key] = self.metadata[key]
        else:
            self._inner_prod_kwargs = {}

        if direct_computation:
            self._calc_fisher()

    # @property
    # def point(self) -> dict[str, u.Quantity]:
    #     return self._point

    # @point.setter
    # def point(self, wf_params: dict[str, u.Quantity]) -> None:
    #     # Do some parameter checks?

    #     self._point = wf_params

    @property
    def wf_generator(self) -> Callable[[dict[str, u.Quantity]], FrequencySeries]:
        return self._wf_generator

    @wf_generator.setter
    def wf_generator(
        self, wf_gen: Callable[[dict[str, u.Quantity]], FrequencySeries]
    ) -> None:
        self._wf_generator = time_phase_wrapper(wf_gen)
        # -- Note: at one point, I was concerned this would potentially
        # -- mess with things like optimize_overlap, where we do not
        # -- check if some non-zero time/phase shift is in wf_params and
        # -- just set these quantities. However, this is not an issue
        # -- since this function calculates RELATIVE shifts. So some
        # -- shift applied to both waveforms does not change outcome.

    @property
    def params_to_vary(self) -> list[str]:
        """
        Parameters constituting the Fisher matrix.

        :type: `list[str]`
        """
        return self._params_to_vary

    @params_to_vary.setter
    def params_to_vary(self, params: str | list[str]) -> None:
        if isinstance(params, str):
            _params = [params]
        else:
            _params = params.copy()  # We potentially remove later on

        # -- Assert no degenerate parameters are given
        # Build in some phi_ref check? Maybe even based on hm_or_precessing?
        # from gw_signal_tools.inner_product import test_hm, test_precessing
        # assert not (
        #     (('phase' in _params and 'psi' in _params))
        #     or (('phase' in _params or 'psi' in _params) and 'phi_ref' in _params
        #          if not (test_hm(self.point, self.wf_generator)
        #                  or test_precessing(self.point))
        #          else True)  # phi_ref only degenerate if hm or precessing
        # )
        # TODO: make sure this is at point in __init__ where all self stuff is defined

        self._params_to_vary = _params
        self._nparams = len(_params)
        self._param_indices = {
            param: i for i, param in enumerate(_params)
        }  # Avoid linear search through parameters, instead hashing

    @property
    def nparams(self):
        """
        Number of parameters constituting the Fisher matrix.

        :type: `int`
        """
        return self._nparams

    def _calc_fisher(self):
        """Calculate the Fisher matrix for this instance."""
        self._fisher, self._deriv_info = fisher_matrix(
            point=self.point,
            params_to_vary=self.params_to_vary,
            wf_generator=self.wf_generator,
            **self.metadata,
        )

        if (cond_numb := self.cond('fro')) > 1e15:  # pragma: no cover
            # -- Conservative threshold choice for double precision,
            # -- as quoted e.g. in gwbench paper
            logger.info(
                f'This Fisher matrix has a condition number of {cond_numb}, '
                'meaning it is ill-conditioned.'
            )

    @property
    def fisher(self) -> MatrixWithUnits:
        """
        Actual Fisher matrix associated with this class.

        :type: `~gw_signal_tools.types.MatrixWithUnits`
        """
        try:
            return self._fisher
        except AttributeError:  # pragma: no cover
            # -- Should not be called because __getattr__ catches this.
            # -- We still leave this exception in case function is
            # -- removed at some point
            self._calc_fisher()

            return self._fisher

    @property
    def fisher_inverse(self) -> MatrixWithUnits:
        """
        Inverse of Fisher matrix associated with this class.

        :type: `~gw_signal_tools.types.MatrixWithUnits`
        """
        try:
            return self._fisher_inverse  # type: ignore
            # Explanation of ignore: neither can type be inferred nor hinted
        except AttributeError:
            # -- Inverse is called for the first time or has been deleted
            self._fisher_inverse = MatrixWithUnits.inv(self.fisher)

            if (cond_numb := self.cond('fro')) > 1e15:  # pragma: no cover
                # -- Conservative threshold choice for double precision,
                # -- as quoted e.g. in gwbench paper
                logger.info(
                    f'This Fisher matrix has a condition number of {cond_numb}, '
                    'meaning it is ill-conditioned. Results of matrix inversion '
                    'might not be reliable.'
                )

            return self._fisher_inverse

    @property
    def covariance_matrix(self) -> MatrixWithUnits:
        """Alias for `self.fisher_inverse`, with a more intuitive name."""
        return self.fisher_inverse

    def __getattr__(self, name: str) -> Any:
        # -- To enable calls like self.value, self.unit, self.cond()
        if name == '_fisher':
            # -- If call goes here, the _fisher property has not been
            # -- set yet (perhaps because direct_computation=False).
            # -- Thus we have to calculate first and return afterwards
            self._calc_fisher()
            return self.__getattribute__(name)
        elif name == '_deriv_info':
            # -- Analogous case as for _fisher
            return {}

        return self.fisher.__getattribute__(name)

    @property
    def deriv_info(self) -> dict:
        """
        Collection of information about derivatives that have been
        calculated (just the `deriv_info` from each derivative class.)

        :type:`dict`
        """
        try:
            self._deriv_info
        except AttributeError:  # pragma: no cover
            self._deriv_info = {}

        return self._deriv_info

    def get_param_indices(self, params: Optional[str | list[str]] = None) -> list[int]:
        """
        Get indices that correspond to certain parameter names in
        :code:`self.params_to_vary`.

        Parameters
        ----------
        params : str | list[str]
            Parameter(s) that indices shall be calculated for.

        Returns
        -------
        list[int]
            Indices of :code:`params` in :code:`self.params_to_vary`.
        """
        if params is None:
            return self.nparams * [True]  # Simply take all parameters

        if isinstance(params, str):
            params = [params]

        param_indices = np.empty(len(params), dtype=int)

        for i, param in enumerate(params):
            try:
                param_indices[i] = self._param_indices[param]
            except KeyError:
                # -- param is not in self.params_to_vary
                raise ValueError(
                    f'Parameter \'{param}\' was not used to calculate the '
                    'Fisher matrix (which can also mean it was projected out).'
                )

        return param_indices

    def get_sub_matrix_indices(self, params: str | list[str]) -> tuple[np.ndarray, ...]:
        """
        Get indices for all matrix components of this instance that
        contain the given set of parameters. In other words, one can
        apply these indices for slicing in order to filter out only the
        matrix components that belong to `params`.

        Parameters
        ----------
        params : str | list[str]
            Parameters that indices shall be extracted for.

        Returns
        -------
        tuple[np.ndarray, ...]
            Index grid of :code:`params`.

        See Also
        --------
        gw_signal_tools.fisher.fisher.FisherMatrix.get_param_indices :
            Function used to get indices that correspond to
            :code:`params` in :code:`self.params_to_vary`.
        numpy.ix_ :
            Function used to get index grid from indices that correspond
            to :code:`params` in :code:`self.params_to_vary`.
        """
        param_indices = self.get_param_indices(params)
        index_grid = np.ix_(param_indices, param_indices)

        return index_grid

    def update_attrs(
        self,
        new_point: Optional[dict[str, u.Quantity]] = None,
        new_params_to_vary: Optional[str | list[str]] = None,
        new_wf_generator: Optional[
            Callable[[dict[str, u.Quantity]], FrequencySeries]
        ] = None,
        **new_metadata,
    ) -> FisherMatrix:
        """
        Generate a Fisher matrix with properties like the current
        instance has, but selected updates.
        Note that this creates a new instance of ``FisherMatrix`` since
        updating properties would require new calculation anyway.

        Parameters
        ----------
        new_point : dict[str, ~astropy.units.Quantity]
            Point in parameter space at which the Fisher matrix is
            evaluated, encoded as key-value pairs representing
            parameter-value pairs. Given as input to
            :code:`wf_generator`.
        new_params_to_vary : str or list[str]
            Parameter(s) with respect to which the derivatives will be
            computed, the norms of which constitute the Fisher matrix.
            Must be compatible with :code:`param_to_vary` input to the
            the derivative classes defined in :code:`~gw_signal_tools.
            waveform`, i.e. either :code:`'time'`, :code:`'phase'` or a
            key in :code:`point`.

            Note that for this function, it is not required to specify a
            completely novel set. Updating only selected parameters is
            suppported.
        new_wf_generator : Callable[[dict[str, ~astropy.units.Quantity]], ~gwpy.frequencyseries.FrequencySeries]
            Arbitrary function that is used for waveform generation. The
            required signature means that it has one non-optional
            argument, which is expected to accept the input provided in
            :code:`point`, while the output must be a ``~gwpy.
            frequencyseries.FrequencySeries`` (the standard output of
            LAL gwsignal generators) because it carries information
            about value, frequencies and units, which are all required
            for the calculations that are carried out.

            Convenient options are the methods
            :code:`~gw_signal_tools.waveform_utils.get_wf_generator`
            or :code:`FisherMatrix.get_wf_generator`, which generate a
            suitable function from a few arguments.

        Returns
        -------
        ~gw_signal_tools.fisher_matrix.FisherMatrix
            New Fisher matrix, calculated with updated metadata.
        """
        if new_point is None:
            new_point = self.point

        if new_params_to_vary is None:
            new_params_to_vary = self.params_to_vary

        if new_wf_generator is None:
            new_wf_generator = self.wf_generator

        if len(new_metadata) > 0:
            _new_metadata = self.metadata | new_metadata
        else:
            _new_metadata = self.metadata

        out = FisherMatrix(
            new_point,
            new_params_to_vary,
            new_wf_generator,
            **_new_metadata,
        )
        out._wf_generator = new_wf_generator  # Avoid it is wrapped again in setter

        return out

    def project_fisher(self, params: str | list[str]) -> FisherMatrix:
        """
        Project Fisher matrix so that its components now live in the
        orthogonal subspace to certain parameters (corresponds to
        optimizing with respect to them).

        Parameters
        ----------
        params : str or list[str]
            Parameter or list of parameters to project out. Must have
            been given in :code:`params_to_vary` upon initialization of
            the ``FisherMatrix`` instance.

        Returns
        -------
        ~gw_signal_tools.types.MatrixWithUnits
            Matrix with same shape as initial Fisher matrix, but
            potentially different component values.
        """
        if isinstance(params, str):
            params = [params]

        # -- Prepare FisherMatrix instance for projected Fisher
        out = self.copy()
        for param in params:
            out.params_to_vary.remove(param)
            # -- Also look at deriv_info, pop params there
            out._deriv_info.pop(param, None)
        # -- To update indices, we have to set params_to_vary again
        out.params_to_vary = out.params_to_vary

        # -- Perform projection
        fisher_val = self.value
        index_grid = self.get_sub_matrix_indices(params)
        sub_matrix = fisher_val[index_grid]
        if (
            cond_numb := np.linalg.cond(sub_matrix, p='fro')
        ) > 1e15:  # pragma: no cover
            logger.info(
                'Submatrix used for projection has a condition number of '
                f'{cond_numb}, meaning it is ill-conditioned.'
            )
        sub_matrix_inv = np.linalg.inv(sub_matrix)

        full_inv = np.zeros(2 * (self.nparams,))
        full_inv[index_grid] = sub_matrix_inv
        full_inv = MatrixWithUnits(full_inv, self.unit**-1)

        fisher = self.fisher
        index_grid_out = self.get_sub_matrix_indices(out.params_to_vary)
        out._fisher = (fisher - fisher @ full_inv @ fisher)[index_grid_out]
        out._is_projected = True
        out._fisher_inverse = MatrixWithUnits.inv(out.fisher)
        # -- Inverse must be set, otherwise it is self.fisher_inverse

        return out

    @property
    def is_projected(self):
        """
        Information on whether or not the matrix was obtained via
        calculation only or via calculation and subsequent projection.
        In the latter case, one cannot reproduce the result by
        calculating the matrix again with the same parameters.

        :type: boolean
        """
        try:
            return self._is_projected
        except AttributeError:
            self._is_projected = False
            return False

    def statistical_error(
        self, params: Optional[str | list[str]] = None
    ) -> MatrixWithUnits:
        r"""
        Calculates the :math:`1-\sigma` statistical error

        .. math:: \Delta \theta^\mu = \sqrt{\Gamma^{-1}_{\mu \mu}}

        for the selected parameters.

        Parameters
        ----------
        params : str | list[str], optional, default = None
            Parameter(s) to calculate error for. In case it is None (the
            default), the error for all parameters from :code:`self.
            params_to_vary` is calculated. Can also be a string or list
            of strings, but these have to match elements of :code:`self.
            params_to_vary`.

        Returns
        -------
        ~gw_signal_tools.types.MatrixWithUnits
            Vector of statistical errors. Indices match indices of
            :code:`params_to_vary` variable that has been used to
            initialize the class.

        Notes
        -----
        Calculating this does not make sense if a PSD for no noise is
        used during the Fisher matrix calculations.
        """
        param_indices = self.get_param_indices(params)
        return MatrixWithUnits.sqrt(self.fisher_inverse.diagonal()[param_indices])
        # TODO: make it return column vector, is more natural, right?

    def systematic_error(
        self,
        reference_wf_generator: Callable[[dict[str, u.Quantity]], FrequencySeries],
        params: Optional[str | list[str]] = None,
        optimize: bool | str | list[str] = True,
        optimize_fisher: Optional[str | list[str]] = None,
        return_diagnostics: bool = False,
        is_true_point: bool = False,
        **inner_prod_kwargs,
    ) -> MatrixWithUnits | tuple[MatrixWithUnits, dict[str, Any]]:
        r"""
        Calculates the systematic error between two waveform models.
        The recovery model is taken to be :code:`self.wf_generator`,
        with :code:`self.reference_wf_generator` taking the role of the
        injected/reference waveform model.

        Parameters
        ----------
        reference_wf_generator : Callable[[dict[str, ~astropy.units.Quantity]], ~gwpy.frequencyseries.FrequencySeries]
            Waveform generator for "reference model" that the systematic
            error is computed with respect to. Must accept dictionary
            input like `self.point`.
        params : str | list[str], optional, default = None
            Parameter(s) to return error for. In case it is None (the
            default), the error for all parameters from :code:`self.
            params_to_vary` is calculated. Can also be a string or list
            of strings, but these have to match elements of :code:`self.
            params_to_vary`.

            Note that this argument does not determine the parameters
            that enter in the error calculation (i.e. in the summation
            involved). These parameters are given by the ones given as
            :code:`params_to_vary` to the Fisher matrix instance that
            this method is called upon.
        optimize : boolean | str | list[str], optional, default = True
            Option that allows the to control the optimization procedure
            that is used. Can be True or False to switch automatic
            version on and off, but also a list with parameter names
            that the optimization will be carried out for. Using True is
            recommended because it has been shown that estimates become
            more reliable in that case, so this is the default.

            If it is given as a list, the corresponding parameters must
            be in the instances ``point`` dictionary or :code:`'time'`,
            :code:`'phase'`. They need not be part of :code:`params`.

            Note that passing any kind of optimization of the inner
            product as a keyword will also result in this parameter
            being added to the optimized parameters (if it was not
            present before). For details, refer to the documentation of
            :code:`~gw_signal_tools.inner_product.optimize_overlap`.
        optimize_fisher : str | list[str], optional, default = None
            Parameters to optimize the Fisher matrix over, i.e. to
            project out of it. Must be in :code:`params_to_vary`
            attribute of the instance that this method is called upon.

            Note that they will not appear in the returned error anymore
            because they do not appear in the Fisher matrix used for the
            calculation that determines the output.
        return_diagnostics : bool, optional, default = False
            Whether to return information on the calculations along with
            result.
        is_true_point : bool, optional, default = False
            Whether :code:``self.point`` represents the "true", i.e.
            injected, parameters or not. Default is ``False``, which
            means the point is assumed to be the maximum-likelihood
            estimate obtained from :code:``self.wf_generator``. This
            setting is not relevant for the systematic error calculation
            itself, only for the diagnostic tools returned in the
            optimization info.
        inner_prod_kwargs :
            Key word arguments used for the calculations here, i.e. for
            waveform difference and more. These will be combined with
            the inner product arguments that have been passed to the
            Fisher matrix instance (but the arguments passed to the
            routine have a higher priority, i.e. they will overwrite
            the ones that have already been given to the Fisher matrix).

        Returns
        -------
        ~gw_signal_tools.types.MatrixWithUnits | tuple[~gw_signal_tools.types.MatrixWithUnits, dict[str, Any]]
            Column vector containing the systematic errors and
            dictionary with information about the calculation.

            TODO: do details on dictionary keys

        Notes
        -----
        The formula evaluated by this function is basically

        .. math::
            \Delta \theta^\mu = \sum_{\nu} \Gamma^{-1}_{\mu \nu} \langle
            \frac{\partial h}{\partial \theta^\nu}, \delta h \rangle

        where :math:`\delta h = h_2 - h`. Here, :math:`h` is the
        waveform model used to calculate the current Fisher matrix
        instance and :math:`h_2` is a second model, with respect to
        which the systematic error
        :math:`\Delta \theta = \theta - \theta_2` is computed/estimated.

        Here :math:`\theta_2` are the parameters that correspond to the
        "real"/injected signal :math:`h_2(\theta_2)`, whose recovery
        using the second model :math:`h` yielded "best-fitting" signal
        parameters :math:`\theta`. In other words, this function
        calculates the displacement of :code:`self.wf_generators`'s best
        guess from best guess of :code:`reference_model`.

        The point represented by :code:`self.point` can be both
        :math:`\theta` and :math:`\theta_2`. The more common way of
        defining it would be :math:`\theta`, which is where the bias
        formula above is typically evaluated in the literature. However,
        changing the evaluation point of this formula to
        :math:`\theta_2` is equally valid and will yield almost the same
        estimates (if the LSA is valid; but this is needed anyway for
        the formula to produce faithful estimates).
        """
        if isinstance(optimize, str):
            optimize = [optimize]

        if isinstance(optimize_fisher, str):
            optimize_fisher = [optimize_fisher]

        optimization_info = {}

        # -- Update keywords from initial input to the instance
        inner_prod_kwargs = self._inner_prod_kwargs | inner_prod_kwargs

        # -- Get Fisher matrix and delta h to use. This depends on ------------
        # -- whether or not optimization of them over certain parameters ------
        # -- shall be carried out. --------------------------------------------
        opt_is_bool = isinstance(optimize, bool)
        opt_is_list = isinstance(optimize, list)
        use_alignment = (opt_is_bool and optimize) or opt_is_list
        if use_alignment:
            if opt_is_bool:
                opt_params = get_default_opt_params(
                    self.point, self.wf_generator
                )  # Not leaving at none is important, we check for this

                optimization_info['general'] = 'Default optimization was carried out.'
            else:
                # -- Is list
                opt_params = optimize
                optimization_info['general'] = 'Custom optimization was carried out.'

            wf_1, wf_2, opt_vals = optimize_overlap(
                wf_params=self.point,
                fixed_wf_generator=reference_wf_generator,
                vary_wf_generator=self.wf_generator,
                opt_params=opt_params,
                **inner_prod_kwargs,
            )
            delta_h = wf_1 - wf_2

            opt_wf_params = self.point | opt_vals
            optimization_info['opt_params'] = opt_wf_params.copy()

            # -- Following is done for the test in line below and to
            # -- store commonly used values
            time_shift = opt_vals.pop('time', 0.0 * u.s)
            phase_shift = opt_vals.pop('phase', 0.0 * u.rad)

            if len(opt_vals) == 0:
                # -- Means that only time and/or phase were optimized
                # -- over. These do not influence the Fisher values, so
                # -- no need to recalculate (expensive operation). We
                # -- still have to make sure correct waveforms will be
                # -- produced though, so time and phase shift have to be
                # -- allowed as parameters!

                opt_fisher = self.copy()  # Preferred over update_attrs as it copies fisher
                opt_fisher.point = opt_wf_params  # Add time, phase shifts

                # -- The corresponding shifts still have to be applied
                # -- to the derivatives. Works because
                # -- \partial_\mu (h*factor) = \partial_\mu (h)*factor
                # -- if factor is constant w.r.t. \theta_\mu (and since
                # -- apply_time_phase_shift only multiplies with a
                # -- number independent of every other parameter, its
                # -- application qualifies as application of 'factor').
                opt_fisher.fisher  # Make sure derivatives are calculated
                for param in opt_fisher.params_to_vary:
                    deriv = opt_fisher.deriv_info[param]['deriv']
                    opt_fisher.deriv_info[param]['deriv'] = apply_time_phase_shift(
                        deriv, time_shift, phase_shift
                    )
            else:
                opt_fisher = self.update_attrs(
                    new_point=opt_wf_params,
                    **inner_prod_kwargs
                )

            if optimize_fisher is not None:
                opt_fisher = opt_fisher.project_fisher(optimize_fisher)

                optimization_info[
                    'general'
                ] += ' Fisher Matrix projection was carried out as well.'

                optimization_info['fisher_opt_params'] = optimize_fisher

            optimization_info['opt_fisher'] = opt_fisher
        elif opt_is_bool and not optimize:
            wf_1 = reference_wf_generator(self.point)
            wf_2 = self.wf_generator(self.point)
            delta_h = wf_1 - wf_2

            if optimize_fisher is not None:
                opt_fisher = self.project_fisher(optimize_fisher)

                optimization_info['general'] = (
                    'No optimization of the waveform difference was done, '
                    'but Fisher Matrix projection was carried out.'
                )

                optimization_info['fisher_opt_params'] = optimize_fisher
                optimization_info['opt_fisher'] = opt_fisher
            else:
                opt_fisher = self
                # -- We do not want to change something here. Even if
                # -- e.g. inner_prod_kwargs != init_inner_prod_kwargs,
                # -- if we change this here we also potentially change
                # -- the calculated Fisher matrix (not wanted).

                optimization_info['general'] = 'No optimization was carried out.'

            opt_params = None
        else:  # pragma: no cover
            raise ValueError(
                'Given `optimize` input not accepted. Please '
                'provide either a ``boolean`` or a ``list``.'
            )
        # -- After this if-clause, it is always opt_fisher that we must
        # -- turn to. It has the correct Fisher matrix, parameters,
        # -- waveform generators, etc.

        # -- Calculation of systematic error ----------------------------------
        opt_fisher.fisher
        # -- Makes sure has been computed (might not be the case e.g. if
        # -- optimize=False, direct_computation=False in self)

        derivs = [
            opt_fisher.deriv_info[param]['deriv']
            for param in opt_fisher.params_to_vary
            # -- Potential time and phase shifts from optimization are
            # -- already incorporated here
        ]

        vector = MatrixWithUnits(np.zeros((opt_fisher.nparams, 1)))
        for i, deriv in enumerate(derivs):
            vector[i] = inner_product(delta_h, deriv, **inner_prod_kwargs)
        optimization_info['deriv_vector'] = vector

        fisher_bias = opt_fisher.fisher_inverse @ vector

        # -- Bias from Fisher calculation might not be the only one we
        # -- have to account for, some parameters might change in
        # -- optimization procedure (has to be taken into account too).
        # if opt_params is not None:
        if use_alignment:  # Should be equivalent
            opt_bias = 0.0 * fisher_bias  # Get correct shape+units with value of zero

            # -- Do not loop over `params`, some of them might have been
            # -- projected out of opt_fisher
            for param in opt_fisher.params_to_vary:
                i = opt_fisher.get_param_indices(param)

                if param == 'time':
                    opt_bias[i] = time_shift
                elif param == 'phase':
                    opt_bias[i] = phase_shift
                else:
                    wf_param_val = self.point[param]
                    opt_bias[i] = opt_vals.get(param, wf_param_val) - wf_param_val

            fisher_bias += opt_bias
            optimization_info['opt_bias'] = opt_bias

        if not return_diagnostics:
            # -- Check which params shall be returned and then return
            # -- (no need to conduct extra calculations).
            if params is not None:
                param_indices = opt_fisher.get_param_indices(params)
                fisher_bias = fisher_bias[param_indices]

            return fisher_bias


        # -- Some calculations for diagnostic purposes. We look at ------------
        # -- mismatches instead of waveform differences here for --------------
        # -- results that can be more readily interpreted. --------------------

        # -- Calculate mismatch that is estimated over
        optimization_info['remaining_mismatch'] = 1.0 - overlap(
            wf_1,
            wf_2,
            **(inner_prod_kwargs | {'optimize_time_and_phase': False}),
        )
        # -- Reason for {'optimize_time_and_phase': False}:
        # -- Either optimize is turned on (i.e. overlap is already
        # -- optimized, or the relevant mismatch is non-optimized one)
        # -- -> even when inner product in Fisher is optimized. Such
        # --    an optimization is only carried out between waveform
        # --    difference and derivative! And remaining_mismatch is
        # --    is concerned with mismatch of waveform difference

        # -- Calculate mismatch between waveforms that LSA assumes to be
        # -- reasonably equal (as self-consistency check).
        true_params = {
            'time': 0.0 * u.s,
            'phase': 0.0 * u.rad,
        } | self.point.copy()
        bf_params = true_params.copy()
        aligned_params = true_params.copy()
        # -- NOT opt_fisher.point since this is potentially point
        # -- obtained from alignment.
        if is_true_point:
            for param in opt_fisher.params_to_vary:
                i = opt_fisher.get_param_indices(param)
                # -- Nothing to do for true_params, already has correct value
                bf_params[param] = true_params[param] + fisher_bias[i].reshape(-1)[0]  # Clearer what happens
                aligned_params[param] = true_params[param] + (opt_bias[i].reshape(-1)[0] if use_alignment else 0)
        elif not is_true_point:
            for param in opt_fisher.params_to_vary:
                i = opt_fisher.get_param_indices(param)
                true_params[param] = bf_params[param] - fisher_bias[i].reshape(-1)[0]  # Clearer what happens
                # -- Nothing to do for bf_params, already has correct value
                aligned_params[param] = bf_params[param] + (opt_bias[i].reshape(-1)[0] if use_alignment else 0)
        else:
            raise ValueError('Invalid value for `params_is_true_point`.')

        optimization_info['best_fitting_point'] = bf_params
        optimization_info['true_point'] = true_params
        if use_alignment:
            # -- Only set if optimization is turned on
            optimization_info['aligned_point'] = aligned_params

        try:
            # -- Note: do NOT use += in the following. Might change
            # -- memory of waveform that is cached, this is not wanted!
            if not use_alignment:
                left_wf = self.wf_generator(true_params)
                right_wf = self.wf_generator(bf_params)
                for i in range(opt_fisher.nparams):
                    # -- Or is it also nicer to distinguish the two cases?
                    if is_true_point:
                        right_wf = right_wf + derivs[i] * (-fisher_bias[i].reshape(-1)[0])
                        # -- This here might be nice way to account for
                        # -- different derivative points
                        # left_wf = left_wf + derivs[i] * fisher_bias[i].reshape(-1)[0]
                        # -> observation: when adding to left, mismatch
                        #   estimates are a little smaller. But does that
                        #   mean more accurate?
                    else:
                        right_wf = right_wf + derivs[i] * (-fisher_bias[i].reshape(-1)[0])
            # -- That was the simplest case. The next cases require a
            # -- distinction of which point the alignment was based on,
            # -- making things more complicated (thus two more cases).
            elif is_true_point:
                # -- Easier case of the more complicated ones: we can
                # -- use aligned theta_tr and the estimate for theta_bf.
                left_wf = self.wf_generator(aligned_params)  # Based on true_params
                right_wf = self.wf_generator(bf_params)
                for i in range(opt_fisher.nparams):
                    param = opt_fisher.params_to_vary[i]
                    right_wf = right_wf + derivs[i] * (aligned_params[param] - bf_params[param])
                    # left_wf = left_wf + derivs[i] * (bf_params[param] - aligned_params[param])
                    # -- Adding to left_wf tends to have lower estimates...
                    # -- But this does not tell us if it is "more correct"
            else:
                # -- Harder case: we can use theta_bf, but we only have
                # -- estimate for theta_tr, not aligned version. Thus we
                # -- have to perform another alignment (starting from
                # -- this estimated theta_tr).
                # -- Sure, this relies on good estimate
                # -- of thetatr, but this assumption is not so different
                # -- from the previous if-case, where we assumed that
                # -- the thetabf estimate is good.
                logger.info(
                    'Another optimization has to be performed since `params_is_true_point=False`.'
                    ' This is the reason for another log message.'
                )
                _, left_wf, opt_vals_2 = optimize_overlap(
                    wf_params=true_params,
                    fixed_wf_generator=time_phase_wrapper(reference_wf_generator),
                    vary_wf_generator=self.wf_generator,
                    opt_params=opt_params,
                    **inner_prod_kwargs,
                )
                theta_overline_tr = true_params | opt_vals_2
                # right_wf = self.wf_generator(bf_params)
                right_wf = 0  # For single call of apply_time_phase_shift
                for i in range(opt_fisher.nparams):
                    param = opt_fisher.params_to_vary[i]
                    right_wf = right_wf + derivs[i] * (theta_overline_tr[param] - bf_params[param])
                    # right_wf = right_wf + apply_time_phase_shift(derivs[i], bf_params['time'] - aligned_params['time'], bf_params['phase'] - aligned_params['phase']) * (theta_overline_tr[param] - bf_params[param])
                    # right_wf = right_wf + apply_time_phase_shift(derivs[i], bf_params['time'] - aligned_params['time'], bf_params['phase'] - aligned_params['phase']) * (theta_overline_tr[param] - bf_params[param])
                    # right_wf = right_wf + apply_time_phase_shift(derivs[i], -time_shift, -phase_shift) * (theta_overline_tr[param] - bf_params[param])
                    # -- We need deriv in non-aligned point
                    # TODO: definitely put note in if opt_params contains more
                    # than two or when these two are not just time, phase. Then
                    # we do not have very accurate derivs (in fact, in that
                    # case should probably not even apply time and phase shift
                    # because these might make resulting waveform MORE unequal,
                    # due to correlations during optimization. Right?)
                    # -> remember also (would speak FOR trying to get back):
                    #    for derivative, it is also change around the point
                    #    that matters, not just waveform itself. Relevant for
                    #    previous if (I do not think we should add stuff on left
                    #    there tbh -> uh wait, might be opposite and in fact
                    #    argument for putting stuff on the left; where we know
                    #    expression has more sense, namely Taylor expansion)

                if len(opt_params) == 2 and 'time' in opt_params and 'phase' in opt_params:
                    # -- We need deriv in non-aligned point
                    right_wf = apply_time_phase_shift(right_wf, -time_shift, -phase_shift)
                    # right_wf = right_wf + self.wf_generator(bf_params)
                else:
                    logger.info(
                        'Cannot reconstruct non-aligned point for this choice '
                        'of optimization parameters. LSA mismatch calculation '
                        'is most likely impacted by that.'
                    )
                    # TODO: mention derivative in particular (?)

                    # -- Trying same things as above, add deriv to other side
                    # left_wf = left_wf + right_wf
                    # right_wf = self.wf_generator(bf_params)

                right_wf = right_wf + self.wf_generator(bf_params)


                # -- New idea: optimization in both points should yield
                # -- very similar results, no need to re-do it
                # right_wf = self.wf_generator(bf_params)
                right_wf = 0.
                theta_overline_tr = true_params.copy()
                for i in range(opt_fisher.nparams):
                    param = opt_fisher.params_to_vary[i]
                    theta_overline_tr[param] = true_params[param] + (opt_bias[i].reshape(-1)[0])
                    right_wf = right_wf + derivs[i] * (theta_overline_tr[param] - bf_params[param])
                if len(opt_params) == 2 and 'time' in opt_params and 'phase' in opt_params:
                    # -- We need deriv in non-aligned point
                    right_wf = apply_time_phase_shift(right_wf, -time_shift, -phase_shift)
                right_wf = right_wf + self.wf_generator(bf_params)
                left_wf = self.wf_generator(theta_overline_tr)

                # THIS SEEMS TO WORK PRETTY WELL!!! Tested for total mass bias when varying total mass + mass ratio (even when estimate goes bonkers, is still fine)

            optimization_info['lsa_mismatch'] = 1.0 - overlap(
                left_wf,
                right_wf,
                **(inner_prod_kwargs | {'optimize_time_and_phase': False}),
                # -- Same argument as for remaining_mismatch
            )
        except Exception as e:  # pragma: no cover
            try:
                err_msg = '\nThe exception was: ' + str(e)
            except Exception:
                err_msg = ''
            logger.info(
                'There was an error during the LSA mismatch '
                'calculation, so it is set to `nan`.' + err_msg
            )
            optimization_info['lsa_mismatch'] = np.nan


        # TODO: shouldn't we look at one waveform plus sum over deriv*bias
        # (would then require calculating this mismatch before opt_bias is added
        # to fisher_bias, or looking at (fisher_bias - opt_bias)[i][0, 0])?
        # Because this describes fit between linear approximation and true
        # difference. Currently, we are looking at mismatch that has to be
        # approximated over by the linear approximation, but this gives no
        # statement about how well it works in this particular case
        # -> uhm, is this comment still recent? Actually, I don't think so...


        # TODO: implement indistinguishability criterion mentioned in
        # https://arxiv.org/pdf/2301.06630 right after Eq.(23)? This is
        # Fisher estimate of whether or not differences are significant
        # or if they can be confused with noise
        # -> or maybe the one from Hannam paper?
        # -> or the one mentioned here, https://arxiv.org/pdf/1611.07531, 1-overlap<1/(2rho^2)


        # -- Check which params shall be returned and then return -------------
        if params is not None:
            param_indices = opt_fisher.get_param_indices(params)
            fisher_bias = fisher_bias[param_indices]

        # -- When we are here, return_opt_info=True, no if-clause needed
        return fisher_bias, optimization_info

    def snr(self, **inner_prod_kwargs):
        """
        Calculate the signal-to-noise ratio (SNR) of the signal that
        `self.wf_generator` produces at `self.point`.

        Parameters
        ----------
        inner_prod_kwargs :
            Any keyword argument given here will be passed to the inner
            product calculation. Enables e.g. testing SNR with different
            PSD while leaving all other arguments the same.

        Returns
        -------
        ~astropy.units.Quantity :
            SNR, i.e. norm of signal.
        """
        signal = self.wf_generator(self.point)
        return norm(signal, **(self._inner_prod_kwargs | inner_prod_kwargs))

    def plot_matrix(
        self,
        matrix: MatrixWithUnits,
        xticks: bool = True,
        yticks: bool = True,
        *args,
        **kwargs,
    ) -> mpl.axes.Axes:
        """
        Plotting routine specifically for matrices in a ``FisherMatrix``
        instance. Extends `MatrixWithUnits.plot` by adding labels for
        parameters.

        Parameters
        ----------
        matrix : MatrixWithUnits
            Matrix to plot. Is assumed to have entries that correspond
            to the parameters in `params_to_vary` variable of the
            instance that the method is called upon.
        xticks : bool, optional, default = True
            Whether or not ticks on the x-axis shall be drawn.
        yticks : bool, optional, default = True
            Whether or not ticks on the y-axis shall be drawn.

        Returns
        -------
        ~matplotlib.axes.Axes
            A matplotlib axes object with the plot attached to it. Can
            be further edited or simply plotted by calling `plt.show()`
            after calling this function.
        """
        ax = MatrixWithUnits.plot(matrix, *args, **kwargs)

        tick_labels = (
            self.params_to_vary
            if not isinstance(self.params_to_vary, str)
            else [self.params_to_vary]
        )

        from ..plotting import latexparams

        tick_labels = [latexparams.get(param, param) for param in tick_labels]
        tick_locs = np.arange(0, len(tick_labels)) + 0.5

        if xticks:
            ax.set_xticks(
                tick_locs,
                tick_labels,
                rotation=45,
                horizontalalignment='right',
                rotation_mode='anchor',
            )
        if yticks:
            ax.set_yticks(
                tick_locs,
                tick_labels,
                rotation=45,
                verticalalignment='baseline',
                rotation_mode='anchor',
            )
        ax.tick_params(length=0)

        return ax

    def plot(
        self, only_fisher: bool = False, only_fisher_inverse: bool = False
    ) -> None:
        # NOT final version

        if only_fisher:
            self.plot_matrix(self.fisher)
        elif only_fisher_inverse:
            self.plot_matrix(self.fisher_inverse)
        else:
            self.plot_matrix(self.fisher)
            self.plot_matrix(self.fisher_inverse)

    # Plans for plotting: make one function plot_uncertainty where
    # color denotes uncertainty in fisher_inverse. And then one general
    # function plot where output is plot of fisher and fisher_inverse

    @staticmethod
    def get_wf_generator(
        approximant: str,
        domain: Literal['frequency', 'time'] = 'frequency',
        *args,
        **kwargs,
    ) -> Callable[[dict[str, u.Quantity]], FrequencySeries]:
        """
        Generates a function that fulfils the requirements of the
        :code:`wf_generator` argument of a ``FisherMatrix`` by calling
        :code:`~gw_signal_tools.waveform_utils.get_wf_generator`.

        Parameters
        ----------
        approximant : str
            Name of a waveform model that is accepted by the
            ``~lalsimulation.gwsignal.core.waveform.
            LALCompactBinaryCoalescenceGenerator`` class.
        domain : Literal['frequency', 'time'], optional, default = 'frequency'
            String representing the domain where the Fisher matrix is
            computed. Accepted values are :code:`'frequency'` and
            :code:`'time'`.

        Returns
        -------
        Callable[[dict[str, ~astropy.units.Quantity]], ~gwpy.frequencyseries.FrequencySeries]
            Function that takes dicionary of waveform parameters as
            input and produces a waveform (stored in a GWPy
            ``FrequencySeries``). Can, for example, be used as input
            to :code:`wf_generator` argument during initialization of a
            ``FisherMatrix``.

        See Also
        --------
        gw_signal_tools.waveform_utils.get_strain :
            Function that is wrapped here. All arguments provided in
            addition to the mandatory ones are passed to this function
            (just like `domain` is as well).
        """
        return get_wf_generator(approximant, domain, *args, **kwargs)

    # -- Some Python class related goodies
    _print_slots = ('params_to_vary', )#'point', )#'is_projected', )
    _repr_helper = Array._repr_helper
    __repr__ = Array.__repr__
    __str__ = Array.__str__

    def __copy__(self) -> FisherMatrix:
        new_matrix = FisherMatrix(
            point=self.point,
            params_to_vary=self.params_to_vary,
            wf_generator=self.wf_generator,
            direct_computation=False,
            **self.metadata,
        )
        new_matrix._wf_generator = self.wf_generator  # Avoid another wrapper call
        new_matrix._wf_generator = self.wf_generator  # Avoid another wrapper call
        new_matrix._fisher = self.fisher.copy()
        new_matrix._fisher_inverse = self.fisher_inverse.copy()
        new_matrix._is_projected = self.is_projected

        # -- Note: since deriv_info is a dictionary of dictionaries and
        # -- then has arrays in there, we have to make a deepcopy
        from copy import deepcopy
        new_matrix._deriv_info = deepcopy(self.deriv_info)

        return new_matrix

    def copy(self) -> FisherMatrix:
        return self.__copy__()
