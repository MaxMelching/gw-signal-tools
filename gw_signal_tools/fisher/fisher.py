# ----- Standard Lib Imports -----
from __future__ import annotations  # Enables type hinting own type in a class
from typing import Optional, Any, Literal, Callable

# ----- Third Party Imports -----
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
from gwpy.frequencyseries import FrequencySeries
import astropy.units as u

# ----- Local Package Imports -----
from gw_signal_tools import preferred_unit_system, logger
from ..inner_product import (
    inner_product, norm, optimize_overlap, get_default_opt_params
)
from ..waveform_utils import get_wf_generator
from ..types import MatrixWithUnits
from .fisher_utils import fisher_matrix, get_waveform_derivative_1D_with_convergence


__doc__ = """
Module for the ``FisherMatrix`` class.
"""


class FisherMatrix:
    r"""
    A data type tailored to Fisher matrices. It stores the Fisher matrix
    itself, along with its inverse.

    Parameters
    ----------
    wf_params_at_point : dict[str, u.Quantity]
        Point in parameter space at which the Fisher matrix is
        evaluated, encoded as key-value-pairs. Given as input to
        :code:`wf_generator`.
    params_to_vary : str or list[str]
        Parameter(s) with respect to which the derivatives will be
        computed, the norms of which constitute the Fisher matrix.
        Must be compatible with :code:`param_to_vary` input to the
        function :code:`~gw_signal_tools.fisher.fisher_utils.
        get_waveform_derivative_1D_with_convergence`, i.e. either
        :code:`'tc'` (equivalent: :code:`'time'`), :code:`'psi'`
        (equivalent up to a factor: :code:`'phase' = 2*'psi'`) or a key
        in :code:`wf_params_at_point`.
        
        For time and phase shifts, analytical derivatives are applied.
        This is possible because they contribute only to a factor
        :math:`\exp(i \cdot 2 \psi - i \cdot 2 \pi \cdot f \cdot t_c)`
        in the waveform generated by :code:`wf_generator`. They
        correspond to the parameters typically called coalescence time
        :math:`t_c` and polarization angle :math:`\psi`.
    wf_generator : Callable[[dict[str, ~astropy.units.Quantity]], ~gwpy.frequencyseries.FrequencySeries]
        Arbitrary function that is used for waveform generation. The
        required signature means that it has one non-optional argument,
        which is expected to accept the input provided in
        :code:`wf_params_at_point`, while the output must be a ``~gwpy.
        frequencyseries.FrequencySeries`` (the standard output of
        LAL gwsignal generators) because it carries information about
        value, frequencies and units, which are all required for the
        calculations that are carried out.

        A convenient option is to use the method
        :code:`~gw_signal_tools.waveform_utils.get_wf_generator`, which
        generates a suitable function from a few arguments.
    direct_computation : boolean, optional, default = True
        Whether to compute the Fisher matrix upon intialization of the
        class. Usually, this should be the preferred behaviour, but in
        certain cases one might want to save the computation time (e.g.
        if a systematic error shall be computed, where the Fisher
        matrix might be computed in some optimized point and not the one
        given by :code:`wf_params_at_point`).
    metadata :
        All other keyword arguments will be treated as input for
        metadata of the Fisher matrix. This metadata consists of
        information relevant for derivative calculation. In particular,
        all settings for the inner products that are involved all the
        time can be specified here (e.g. the power spectral density or
        frequency range).

    See Also
    --------
    gwsignal.fisher_utils.fisher_matrix :
        Routine used for calculation of the Fisher matrix.
    gwsignal.fisher_utils.get_waveform_derivative_1D_with_convergence :
        Routine used for calculation of involved derivatives. Used by
        ~gwsignal.fisher_utils.fisher_matrix.
    numpy.linalg.inv : Routine used for inversion of the Fisher matrix.

    Notes
    -----
    In principle, instances of this class constain much more information
    than "just" the Fisher matrix ``FisherMatrix.fisher``, for example
    its inverse ``FisherMatrix.fisher_inverse``. However, to provide an
    intuitive behaviour, remembering the class name, certain operations
    return attributes related only to the Fisher matrix. Array-
    conversion, for example, returns the array representation of
    ``FisherMatrix.fisher``.
    """

    default_metadata = {
        # First three are chosen to match default of derivative function
        'convergence_check': 'diff_norm',
        'break_upon_convergence': True,
        'convergence_threshold': 0.001,
        'return_info': True
    }

    _preferred_unit_sys = preferred_unit_system
    # Idea: display stuff in these units, i.e. apply .to_system to each matrix before saving them
    # -> even better idea: one could apply .to_system to every input
    # parameter for conversion, the functions will just keep units
    # TODO: make setter etc. for it

    def __init__(self,
        wf_params_at_point: dict[str, u.Quantity],
        params_to_vary: str | list[str],
        wf_generator: Callable[[dict[str, u.Quantity]], FrequencySeries],
        direct_computation: bool = True,
        **metadata
    ) -> None:
        """Initialize a ``FisherMatrix``."""
        self.wf_params_at_point = wf_params_at_point
        if isinstance(params_to_vary, str):
            self.params_to_vary = [params_to_vary]
        else:
            self.params_to_vary = params_to_vary.copy()
        self.wf_generator = wf_generator
        self.metadata = self.default_metadata | metadata

        if len(self.metadata) > len(self.default_metadata):
            # Arguments for inner product may have been given
            from inspect import signature
            fisher_args = list(signature(fisher_matrix).parameters)
            fisher_args.remove('inner_prod_kwargs')

            # Start with metadata, then remove all potential arguments
            # for Fisher. Leaves keywords for inner product
            self._inner_prod_kwargs = self.metadata.copy()
            for key in fisher_args:
                self._inner_prod_kwargs.pop(key, None)
        else:
            self._inner_prod_kwargs = {}
    
        if direct_computation:
            self._calc_fisher()
            # TODO: decide if this is really needed. Could also just
            # not allow new computation if this param is False
    
    def _calc_fisher(self):
        result = fisher_matrix(
            self.wf_params_at_point,
            self.params_to_vary,
            self.wf_generator,
            **self.metadata
        )

        if self.metadata['return_info']:
            self._fisher, self._deriv_info = result
            plt.close('all')  # Avoid too many open axes
        else:
            self._fisher = result

            # self._deriv_info = {'general_info': 'There is no info available.'}
            self._deriv_info = {}

        if (cond_numb := self.cond()) > 1e15:
            # Conservative threshold choice for double precision,
            # as quoted e.g. in gwbench paper
            logger.info(
                f'This Fisher matrix has a condition number of {cond_numb}, '
                'meaning it is ill-conditioned.'
            )

    @property
    def fisher(self) -> MatrixWithUnits:
        """
        Actual Fisher matrix associated with this class.

        :type: `~gw_signal_tools.matrix_with_units.MatrixWithUnits`
        """
        try:
            return self._fisher
        except AttributeError:
            self._calc_fisher()

            return self._fisher
    
    @property
    def value(self) -> np.ndarray:
        """
        Value of Fisher matrix associated with this class.

        :type: `~numpy.ndarray`
        """
        return self.fisher.value
    
    @property
    def unit(self) -> np.ndarray:
        """
        Unit of Fisher matrix associated with this class.

        :type: `~numpy.ndarray`
        """
        return self.fisher.unit

    @property
    def fisher_inverse(self) -> MatrixWithUnits:
        """
        Inverse of Fisher matrix associated with this class.

        :type: `~gw_signal_tools.matrix_with_units.MatrixWithUnits`
        """
        # TODO: decide if it shall be computed upon call or upon calculation of Fisher
        try:
            self._fisher_inverse
            # return self._fisher_inverse  # type: ignore
            # Explanation of ignore: neither can type be inferred nor hinted
        except AttributeError:
            # Inverse is called for the first time or has been deleted
            self._fisher_inverse = MatrixWithUnits.inv(self.fisher)

            # return self._fisher_inverse
        
            if (cond_numb := self.cond()) > 1e15:
                # Conservative threshold choice for double precision,
                # as quoted e.g. in gwbench paper
                logger.info(
                    f'This Fisher matrix has a condition number of {cond_numb}, '
                    'meaning it is ill-conditioned.'
                )
            # TODO: this indentation is better, right? Because otherwise,
            # we have SVD for each access to inverse matrix
        
        return self._fisher_inverse
    
    def __getattr__(self, attr):
        if attr == 'fisher' or attr == '_fisher':
            # If call goes here, that means the fisher and _fisher property
            # have not been set yet (perhaps because direct_computation=False).
            # Thus we have to calculate them first and then return
            self._calc_fisher()

            return self.__getattribute__(attr)
        else:
            return MatrixWithUnits.__getattribute__(self.fisher, attr)

    @property
    def deriv_info(self) -> dict:
        # TODO: self._deriv_info is available... Soooo, shall we something with it?
        try:
            self._deriv_info
        except AttributeError:
            self._deriv_info = {}
        
        return self._deriv_info
    
    def get_param_indices(self, params: str | list[str]) -> list[int]:
        """
        Get indices that correspond to certain parameter names in
        :code:`self.params_to_vary`.

        Parameters
        ----------
        params : str | list[str]
            Parameter(s) that indices shall be calculated for.

        Returns
        -------
        list[int]
            Indices of :code:`params` in :code:`self.params_to_vary`.
        """
        if isinstance(params, str):
            params = [params]
        
        for param in params:
            assert param in self.params_to_vary, (
                f'Parameter \'{param}\' was not used to calculate the Fisher '
                'matrix (which can also mean it was projected out).')

        _params = np.array(params)
        _params_to_vary = np.array(self.params_to_vary)
        # param_indices = [np.argwhere(param == _params_to_vary)[0,0] for param in _params_to_vary[np.isin(_params_to_vary, _params)]]
        param_indices = [np.argwhere(param == _params_to_vary)[0,0] for param in _params[np.isin(_params, _params_to_vary)]]

        return param_indices

    def get_sub_matrix_indices(self, params: str | list[str]
                               ) -> tuple[np.ndarray, ...]:
        """
        Get indices for all matrix components of this instance that
        contain the given set of parameters. In other words, one can
        apply these indices for slicing in order to filter out only the
        matrix components that belong to `params`.

        Parameters
        ----------
        params : str | list[str]
            Parameters that indices shall be extracted for.

        Returns
        -------
        tuple[np.ndarray, ...]
            Index grid of :code:`params`.
        
        See Also
        --------
        gw_signal_tools.fisher.fisher.FisherMatrix.get_param_indices :
            Function used to get indices that correspond to
            :code:`params` in :code:`self.params_to_vary`.
        numpy.ix_ :
            Function used to get index grid from indices that correspond
            to :code:`params` in :code:`self.params_to_vary`.
        """
        param_indices = self.get_param_indices(params)
        index_grid = np.ix_(param_indices, param_indices)

        return index_grid

    def update_attrs(self,
        new_wf_params_at_point: Optional[dict[str, u.Quantity]] = None,
        new_params_to_vary: Optional[str | list[str]] = None,
        new_wf_generator: Optional[Callable[[dict[str, u.Quantity]],
                                            FrequencySeries]] = None,
        **new_metadata
    ) -> FisherMatrix:
        """
        Generate a Fisher matrix with properties like the current
        instance has, but selected updates.
        Note that this creates a new instance of ``FisherMatrix`` since
        updating properties would require new calculation anyway.

        Parameters
        ----------
        new_wf_params_at_point : dict[str, u.Quantity]
        Point in parameter space at which the Fisher matrix is
        evaluated, encoded as key-value-pairs. Given as input to
        :code:`wf_generator`.
        new_params_to_vary : str or list[str]
            Parameter(s) with respect to which the derivatives will be
            computed, the norms of which constitute the Fisher matrix.
            Must be compatible with :code:`param_to_vary` input to the
            function :code:`~gw_signal_tools.fisher.fisher_utils.
            get_waveform_derivative_1D_with_convergence`, i.e. either
            :code:`'tc'` (equivalent: :code:`'time'`), :code:`'psi'`
            (equivalent up to a factor: :code:`'phase' = 2*'psi'`) or a
            key in :code:`wf_params_at_point`.

            Note that for this function, it is not required to specify a
            completely novel set. Updating only selected parameters is
            suppported
        new_wf_generator : Callable[[dict[str, ~astropy.units.Quantity]], ~gwpy.frequencyseries.FrequencySeries]
            Arbitrary function that is used for waveform generation. The
            required signature means that it has one non-optional
            argument, which is expected to accept the input provided in
            :code:`wf_params_at_point`, while the output must be a
            ``~gwpy.frequencyseries.FrequencySeries`` (the standard
            output of LAL gwsignal generators) because it carries
            information about value, frequencies and units, which are
            all required for the calculations that are carried out.

            Convenient options are the methods
            :code:`~gw_signal_tools.waveform_utils.get_wf_generator`
            or :code:`FisherMatrix.get_wf_generator`, which generate a
            suitable function from a few arguments.

        Returns
        -------
        ~gw_signal_tools.fisher_matrix.FisherMatrix
            New Fisher matrix, calculated with updated metadata.
        """
        if new_wf_params_at_point is None:
            new_wf_params_at_point = self.wf_params_at_point

        if new_params_to_vary is None:
            new_params_to_vary = self.params_to_vary

        if new_wf_generator is None:
            new_wf_generator = self.wf_generator
        
        if len(new_metadata) > 0:
            _new_metadata = self.metadata | new_metadata
        else:
            _new_metadata = self.metadata

        return FisherMatrix(new_wf_params_at_point, new_params_to_vary,
                            new_wf_generator, **_new_metadata)
    
    def project_fisher(self, params: str | list[str]) -> FisherMatrix:
        """
        Project Fisher matrix so that its components now live in the
        orthogonal subspace to certain parameters (corresponds to
        optimizing with respect to them).

        Parameters
        ----------
        params : str or list[str]
            Parameter or list of parameters to project out. Must have
            been given in :code:`params_to_vary` upon initialization of
            the ``FisherMatrix`` instance.

        Returns
        -------
        ~gw_signal_tools.matrix_with_units.MatrixWithUnits
            Matrix with same shape as initial Fisher matrix, but
            potentially different component values.
        """
        if isinstance(params, str):
            params = [params]

        # ----- Prepare FisherMatrix instance for projected Fisher -----
        out = self.copy()
        for param in params:
            out.params_to_vary.remove(param)
            #  Also look at deriv_info, pop params there
            out._deriv_info.pop(param, None)
        
        # ----- Perform projection -----
        fisher_val = self.fisher.value
        index_grid = self.get_sub_matrix_indices(params)
        sub_matrix = fisher_val[index_grid]
        if (cond_numb := np.linalg.cond(sub_matrix, p='fro')) > 1e15:
            logger.info(
                'Submatrix used for projection has a condition number of '
                f'{cond_numb}, meaning it is ill-conditioned.'
            )
        sub_matrix_inv = np.linalg.inv(sub_matrix)

        n = len(self.params_to_vary)  # Equal to self.fisher.shape[0]
        full_inv = np.zeros((n, n))
        full_inv[index_grid] = sub_matrix_inv
        full_inv = MatrixWithUnits(full_inv, self.unit**-1)

        fisher = self.fisher
        index_grid_out = self.get_sub_matrix_indices(out.params_to_vary)
        out._fisher = (fisher - fisher @ full_inv @ fisher)[index_grid_out]
        out._is_projected = True
        out._fisher_inverse = MatrixWithUnits.inv(out.fisher)
        # Inverse must be set because otherwise it is self.fisher_inverse

        return out
    
    @property
    def is_projected(self):
        """
        Information on whether or not the matrix was obtained via
        calculation only or via calculation and subsequent projection.
        In the latter case, one cannot reproduce the result by
        calculating the matrix again with the same parameters.

        :type: boolean
        """
        try:
            return self._is_projected
        except AttributeError:
            self._is_projected = False
            return False
    
    def statistical_error(self, params: Optional[str | list[str]] = None) -> MatrixWithUnits:
        r"""
        Calculates the :math:`1-\sigma` statistical error

        .. math:: \Delta \theta^\mu = \sqrt{\Gamma^{-1}_{\mu \mu}}

        for the selected parameters.

        Parameters
        ----------
        params : str | list[str], optional, default = None
            Parameter(s) to calculate error for. In case it is None (the
            default), the error for all parameters from :code:`self.
            params_to_vary` is calculated. Can also be a string or list
            of strings, but these have to match elements of :code:`self.
            params_to_vary`.

        Returns
        -------
        ~gw_signal_tools.matrix_with_units.MatrixWithUnits
            Vector of statistical errors. Indices match indices of
            :code:`params_to_vary` variable that has been used to
            initialize the class.

        Notes
        -----
        Calculating this does not make sense if a PSD for no noise is
        used during the Fisher matrix calculations.
        """
        if params is not None:
            param_indices = self.get_param_indices(params)
        else:
            # Take all parameters
            param_indices = len(self.params_to_vary)*[True]
        
        return MatrixWithUnits.sqrt(self.fisher_inverse.diagonal()[param_indices])

    def systematic_error(self,
        reference_wf_generator: Callable[[dict[str, u.Quantity]], FrequencySeries],
        params: Optional[str | list[str]] = None,
        optimize: bool | str | list[str] = True,
        optimize_fisher: Optional[str | list[str]] = None,
        return_opt_info: bool = False,
        **inner_prod_kwargs
    ) -> MatrixWithUnits | tuple[MatrixWithUnits, dict[str, Any]]:
        r"""
        Calculates the systematic error

        .. math::
            \Delta \theta^\mu = \sum_{\nu} \Gamma^{-1}_{\mu \nu} \langle
            \frac{\partial h}{\partial \theta^\nu}, \delta h \rangle

        where :math:`\delta h = h_2 - h`. Here, :math:`h` is the
        waveform model used to calculate the current Fisher matrix
        instance and :math:`h_2` is a second model, with respect to
        which the systematic error
        :math:`\Delta \theta = \theta -\theta_2` is computed/estimated.
        
        Here :math:`\theta_2` are the parameters that correspond to the
        "real"/injected signal :math:`h_2(\theta_2)`, whose recovery
        using the second model :math:`h` yielded "best-fitting" signal
        parameters :math:`\theta` (which correspond to
        :code:`self.wf_params_at_point`). In other words, this function
        calculates the displacement of :code:`self.wf_generators`'s best
        guess from best guess of :code:`reference_model`.

        -> MIGHT CHANGE; if new understanding is True, then self.wf_params_at_point
           can be both theta and theta_2 if optimize=False (should yield
           pretty much the same results), but must actually be theta_2 if optimize=True

        Parameters
        ----------
        reference_wf_generator : Callable[[dict[str, ~astropy.units.Quantity]], ~gwpy.frequencyseries.FrequencySeries]
            Waveform generator for "reference model" that the systematic
            error is computed with respect to.
        params : str | list[str], optional, default = None
            Parameter(s) to return error for. In case it is None (the
            default), the error for all parameters from :code:`self.
            params_to_vary` is calculated. Can also be a string or list
            of strings, but these have to match elements of :code:`self.
            params_to_vary`.

            Note that this argument does not determine the parameters
            that enter in the error calculation (i.e. in the summation
            involved). These parameters are given by the ones given as
            :code:`params_to_vary` to the Fisher matrix instance that
            this method is called upon.
        optimize : boolean | str | list[str], optional, default = True
            Option that allows the to control the optimization procedure
            that is used. Can be True or False to switch automatic
            version on and off, but also a list with parameter names
            that the optimization will be carried out for. Using True is
            recommended because it has been shown that estimates become
            more reliable in that case, so this is the default.

            If it is given as a list, the corresponding parameters must
            be in the instances ``wf_params_at_point`` dictionary or
            :code:`'time'`, :code:`'phase'`. They need not be part of
            :code:`params`.

            Note that passing any kind of optimization of the inner
            product as a keyword will also result in this parameter
            being added to the optimized parameters (if it was not
            present before). For details, refer to the documentation of
            :code:`~gw_signal_tools.inner_product.optimize_overlap`.
        optimize_fisher : str | list[str], optional, default = None
            Parameters to optimize the Fisher matrix over, i.e. to
            project out of it. Must be in :code:`params_to_vary`
            attribute of the instance that this method is called upon.

            Note that they will not appear in the returned error anymore
            because they do not appear in the Fisher matrix used for the
            calculation that determines the output.
        return_opt_info : bool, optional, default = False
            Whether to return information on the calculations along with
            result.
        inner_prod_kwargs : 
            Key word arguments used for the calculations here, i.e. for
            waveform difference and more. These will be combined with
            the inner product arguments that have been passed to the
            Fisher matrix instance (but the arguments passed to the
            routine have a higher priority, i.e. they will overwrite
            the ones that have already been given to the Fisher matrix).

        Returns
        -------
        ~gw_signal_tools.matrix_with_units.MatrixWithUnits | tuple[~gw_signal_tools.matrix_with_units.MatrixWithUnits, dict[str, Any]]
            Column vector containing the systematic errors and
            dictionary with information about the calculation.
        """
        if isinstance(optimize, str):
            optimize = [optimize]
        
        if isinstance(optimize_fisher, str):
            optimize_fisher = [optimize_fisher]

        optimization_info = {}
        
        # Update keywords from initial input to the instance
        inner_prod_kwargs = self._inner_prod_kwargs | inner_prod_kwargs

        # ----- Get Fisher matrix and delta h to use. This -----
        # ----- depends on whether or not optimization of them  -----
        # ----- over certain parameters shall be carried out -----
        if ((opt_is_bool := isinstance(optimize, bool) and optimize)
            or isinstance(optimize, list)):
            # Order is crucial, opt_is_bool needs to be defined
            if opt_is_bool:
                opt_params = get_default_opt_params(self.wf_params_at_point,
                                                    self.wf_generator)
                # Not leaving at none is important, we check for this below
                
                optimization_info['general'] = 'Default optimization was carried out.'
            else:
                # Is list
                opt_params = optimize
            
                optimization_info['general'] = 'Custom optimization was carried out.'

            # Do optimization, get optimal parameters
            opt_wf_1, opt_wf_2, opt_vals = optimize_overlap(
                wf_params=self.wf_params_at_point,
                fixed_wf_generator=reference_wf_generator,
                vary_wf_generator=self.wf_generator,
                opt_params=opt_params,
                **inner_prod_kwargs
            )
            delta_h = opt_wf_1 - opt_wf_2
            # delta_h = reference_wf_generator(self.wf_params_at_point) \
            #     - self.wf_generator(self.wf_params_at_point)

            opt_wf_params = self.wf_params_at_point | opt_vals
            optimization_info['opt_params'] = opt_wf_params.copy()
            # TODO: decide if tc, psi should be included in here or not (I think it does make sense to do so)

            # Remove parameters that are not used in wf generation
            time_shift = opt_vals.pop('tc', 0.*u.s) + opt_vals.pop('time', 0.*u.s)
            phase_shift = 2.*opt_vals.pop('psi', 0.*u.rad) + opt_vals.pop('phase', 0.*u.rad)  # 2 due to separate interpretation of phase, psi
            # Idea with addition: only one of them will be non-zero, giving
            # multiple would not make sense due to their equivalency
            

            if len(opt_vals) == 0:
                # Means that only time and/or phase were optimized over.
                # These do not influence the Fisher values, so no need
                # to recalculate (expensive)
                opt_fisher = self
            else:
                opt_wf_params.pop('tc', None)
                opt_wf_params.pop('time', None)
                opt_wf_params.pop('psi', None)
                opt_wf_params.pop('phase', None)

                opt_fisher = FisherMatrix(
                    opt_wf_params,
                    self.params_to_vary,
                    self.wf_generator,
                    **(self.metadata | {'return_info': True} | inner_prod_kwargs)
                )
            

            if optimize_fisher is not None:
                opt_fisher = opt_fisher.project_fisher(optimize_fisher)

                optimization_info['general'] += (
                    ' Fisher Matrix optimization was carried out as well.'
                )

                optimization_info['fisher_opt_params'] = optimize_fisher
            
            fisher_inverse = opt_fisher.fisher_inverse

            # logger.info(f'The optimized Fisher matrix is:\n{opt_fisher}')
            optimization_info['opt_fisher'] = opt_fisher            

            # Get stored derivatives from Fisher calculation
            derivs = [
                opt_fisher.deriv_info[param]['deriv'] for param in opt_fisher.params_to_vary
            ]

            # For Fisher matrix, time and phase shift have no influence, but
            # for pure derivatives, they do!
            for i, deriv in enumerate(derivs):
                derivs[i] = deriv * np.exp(-2.j*np.pi*deriv.frequencies*time_shift + 1.j*phase_shift)
        elif isinstance(optimize, bool) and not optimize:
            delta_h = reference_wf_generator(self.wf_params_at_point) \
                - self.wf_generator(self.wf_params_at_point)

            if optimize_fisher is not None:
                opt_fisher = self.project_fisher(optimize_fisher)
        
                optimization_info['general'] = (
                    'No optimization of the waveform difference was done, '
                    'but Fisher Matrix optimization was carried out.'
                )

                optimization_info['fisher_opt_params'] = optimize_fisher
                optimization_info['opt_fisher'] = opt_fisher
            else:
                opt_fisher = self
                # TODO: maybe also check if inner_prod_kwargs != init_inner_prod_kwargs,
                # can make difference in inner product calculation

                optimization_info['general'] = 'No optimization was carried out.'
            
            fisher_inverse = opt_fisher.fisher_inverse

            if opt_fisher.metadata['return_info']:
                derivs = [
                    opt_fisher.deriv_info[param]['deriv'] for param in opt_fisher.params_to_vary
                ]
            else:
                # NOTE: it does make sense to calculate derivs for the
                # parameters in params only because this argument is meant
                # to determine return. For error, parameters that are not in
                # in params still play a role and have to be accounted for.
                derivs = [
                    get_waveform_derivative_1D_with_convergence(
                        opt_fisher.wf_params_at_point,
                        param_to_vary,
                        opt_fisher.wf_generator,
                        **opt_fisher.metadata
                    ) for param_to_vary in opt_fisher.params_to_vary
                ]

            opt_params = None
        else:
            raise ValueError('Given `optimize` input not accepted.')
        
        # ----- Now calculation of systematic error -----
        vector = MatrixWithUnits.from_numpy_array(np.zeros((len(derivs), 1)))
        for i, deriv in enumerate(derivs):
            vector[i] = inner_product(delta_h, deriv, **inner_prod_kwargs)
        optimization_info['deriv_vector'] = vector
        
        fisher_bias = fisher_inverse @ vector


        # Bias from Fisher calculation might not be the only one we have
        # to account for, some parameters might change in optimization
        # procedure (has to be taken into account as well).
        if opt_params is not None:
            # opt_bias = MatrixWithUnits.from_numpy_array(np.zeros(fisher_bias.shape))
            opt_bias = 0.*fisher_bias  # Get correct shape+units with value of zero
            
            # Do not loop over params, some of them might have been
            # projected out of opt_fisher
            for param in opt_fisher.params_to_vary:
                # TODO: check if enumerate works too
                i = opt_fisher.get_param_indices(param)
                
                if param in ['tc', 'time']:
                    opt_bias[i] = time_shift
                elif param == 'psi':
                    opt_bias[i] = 0.5*phase_shift.value*u.rad.compose(units=self._preferred_unit_sys)[0]
                elif param == 'phase':
                    opt_bias[i] = phase_shift.value*u.rad.compose(units=self._preferred_unit_sys)[0]
                else:
                    wf_param_val = self.wf_params_at_point[param]
                    opt_bias[i] = opt_vals.get(param, wf_param_val) - wf_param_val

            fisher_bias += opt_bias
            optimization_info['opt_bias'] = opt_bias

        # Check which params shall be returned
        if params is not None:
            if isinstance(params, str):
                params = [params]
            param_indices = opt_fisher.get_param_indices(params)

            fisher_bias = fisher_bias[param_indices]
        
        if return_opt_info is False:
            return fisher_bias
        else:
            return fisher_bias, optimization_info
    
    def snr(self, **inner_prod_kwargs):
        """
        Calculate the signal-to-noise ratio (SNR) of the signal that
        `self.wf_generator` produces at `self.wf_params_at_point`.

        Parameters
        ----------
        inner_prod_kwargs :
            Any keyword argument given here will be passed to the inner
            product calculation. Enables e.g. testing SNR with different
            PSD while leaving all other arguments the same.

        Returns
        -------
        ~astropy.units.Quantity :
            SNR, i.e. norm of signal.
        """
        signal = self.wf_generator(self.wf_params_at_point)
        return norm(signal, **(self._inner_prod_kwargs | inner_prod_kwargs))

    def plot_matrix(self, matrix: MatrixWithUnits, xticks: bool = True,
                    yticks: bool = True, *args, **kwargs) -> mpl.axes.Axes:
        """
        Plotting routine specifically for matrices in a ``FisherMatrix``
        instance. Extends `MatrixWithUnits.plot` by adding labels for
        parameters.

        Parameters
        ----------
        matrix : MatrixWithUnits
            Matrix to plot. Is assumed to have entries that correspond
            to the parameters in `params_to_vary` variable of the
            instance that the method is called upon.
        xticks : bool, optional, default = True
            Whether or not ticks on the x-axis shall be drawn.
        yticks : bool, optional, default = True
            Whether or not ticks on the y-axis shall be drawn.

        Returns
        -------
        ~matplotlib.axes.Axes
            A matplotlib axes object with the plot attached to it. Can
            be further edited or simply plotted by calling `plt.show()`
            after calling this function.
        """
        ax = MatrixWithUnits.plot(matrix, *args, **kwargs)

        tick_labels = self.params_to_vary if not isinstance(self.params_to_vary, str) else [self.params_to_vary]
        from ..fisher import latexparams
        tick_labels = [latexparams[param] if param in latexparams else param for param in tick_labels]
        tick_locs = np.arange(0, len(tick_labels)) + 0.5

        if xticks:
            ax.set_xticks(tick_locs, tick_labels, rotation=45,
                        horizontalalignment='right', rotation_mode='anchor')
        if yticks:
            ax.set_yticks(tick_locs, tick_labels, rotation=45,
                        verticalalignment='baseline', rotation_mode='anchor')
        ax.tick_params(length=0)

        # -> rotation is good idea if param not in displayparams, otherwise looks strange

        return ax

    def plot(self, only_fisher: bool = False, only_fisher_inverse: bool = False) -> None:
        # NOT final version

        if only_fisher:
            self.plot_matrix(self.fisher)
        elif only_fisher_inverse:
            self.plot_matrix(self.fisher_inverse)
        else:
            self.plot_matrix(self.fisher)
            self.plot_matrix(self.fisher_inverse)

    # Plans for plotting: make one function plot_uncertainty where
    # color denotes uncertainty in fisher_inverse. And then one general
    # function plot where output is plot of fisher and fisher_inverse

    @staticmethod
    def get_wf_generator(
        approximant: str,
        domain: Literal['frequency', 'time'] = 'frequency',
        *args, **kwargs
    ) -> Callable[[dict[str, u.Quantity]], FrequencySeries]:
        """
        Generates a function that fulfils the requirements of the
        :code:`wf_generator` argument of a ``FisherMatrix`` by calling
        :code:`~gw_signal_tools.waveform_utils.get_wf_generator`.

        Parameters
        ----------
        approximant : str
            Name of a waveform model that is accepted by the
            ``~lalsimulation.gwsignal.core.waveform.
            LALCompactBinaryCoalescenceGenerator`` class.
        domain : Literal['frequency', 'time'], optional, default = 'frequency'
            String representing the domain where the Fisher matrix is
            computed. Accepted values are :code:`'frequency'` and
            :code:`'time'`.

        Returns
        -------
        Callable[[dict[str, ~astropy.units.Quantity]], ~gwpy.frequencyseries.FrequencySeries]
            Function that takes dicionary of waveform parameters as
            input and produces a waveform (stored in a GWPy
            ``FrequencySeries``). Can, for example, be used as input
            to :code:`wf_generator` argument during initialization of a
            ``FisherMatrix``.

        See Also
        --------
        gw_signal_tools.waveform_utils.get_strain :
            Function that is wrapped here. All arguments provided in
            addition to the mandatory ones are passed to this function
            (just like `domain` is as well).
        """
        return get_wf_generator(approximant, domain, *args, **kwargs)
    

    # ----- Set some Python class related goodies -----
    def __repr__(self) -> str:
        # return self.fisher.__repr__()
        # TODO: make custom one with more information

        from shutil import get_terminal_size
        terminal_width = get_terminal_size()[0]

        def get_name_header(name: str) -> str:
            return f"{' ' + name + ' ':-^{terminal_width}}"
        
        return f'''
{get_name_header('Generation Parameters')}
{self.params_to_vary.__repr__()}
\n
{get_name_header('Fisher Matrix')}
{self.fisher.__repr__()}
\n
{get_name_header('Fisher Matrix Inverse')}
{self.fisher_inverse.__repr__()}
        '''
    
    def __copy__(self) -> FisherMatrix:
        new_matrix = FisherMatrix(
            self.wf_params_at_point,
            self.params_to_vary,
            self.wf_generator,
            direct_computation=False,
            **self.metadata
        )
        
        new_matrix._fisher = self.fisher.copy()
        new_matrix._fisher_inverse = self.fisher_inverse.copy()
        new_matrix._deriv_info = self.deriv_info.copy()
        new_matrix._is_projected = self.is_projected

        return new_matrix
    
    def copy(self) -> FisherMatrix:
        return self.__copy__()
