# -- Standard Lib Imports
from __future__ import annotations  # Enables type hinting own type in a class
from typing import Optional, Any, Callable

# -- Third Party Imports
from gwpy.frequencyseries import FrequencySeries
import astropy.units as u

# -- Local Package Imports
from ..logging import logger
from ..waveform.inner_product import norm
from .fisher import FisherMatrix
from ..types import MatrixWithUnits, Detector


__doc__ = """
Module for the ``FisherMatrixNetwork`` class.
"""

__all__ = ('FisherMatrixNetwork',)


class FisherMatrixNetwork(FisherMatrix):
    r"""
    Extension of the ``FisherMatrix`` class to a network of
    gravitational wave (GW) detectors. The structure of both classes is
    very similar, but for a network there is an additional argument
    that is needed for instantiation. This argument called `detectors`
    is - as the name already suggests - needed as a way to account for
    the fact that multiple detectors are taken into account now.

    Parameters
    ----------
    point : dict[str, ~astropy.units.Quantity]
        Point in parameter space at which the Fisher matrix is
        evaluated, encoded as key-value pairs representing
        parameter-value pairs. Given as input to :code:`wf_generator`.
    params_to_vary : str or list[str]
        Parameter(s) with respect to which the derivatives will be
        computed, the norms of which constitute the Fisher matrix.
        Must be compatible with :code:`param_to_vary` input to the
        function :code:`~gw_signal_tools.fisher.fisher_utils.
        get_waveform_derivative_1D_with_convergence`, i.e. either
        :code:`'tc'` (equivalent: :code:`'time'`), :code:`'psi'`
        (equivalent up to a factor: :code:`'phase' = 2*'psi'`) or a key
        in :code:`point`.

        For time and phase shifts, analytical derivatives are applied.
        This is possible because they contribute only to a factor
        :math:`\exp(i \cdot 2 \psi - i \cdot 2 \pi \cdot f \cdot t_c)`
        in the waveform generated by :code:`wf_generator`. They
        correspond to the parameters typically called coalescence time
        :math:`t_c` and polarization angle :math:`\psi`.
    wf_generator :
        Arbitrary function that is used for waveform generation. The
        required signature means that it has one non-optional argument,
        which is expected to accept the input provided in
        :code:`point`, while the output must be a ``~gwpy.
        frequencyseries.FrequencySeries`` (the standard output of
        LAL gwsignal generators) because it carries information about
        value, frequencies and units, which are all required for the
        calculations that are carried out.

        Must accept extrinsic parameters now, otherwise having
        multiple detectors does not make sense.

        A convenient option is to use the method
        :code:`~gw_signal_tools.waveform_utils.get_wf_generator`, which
        generates a suitable function from a few arguments.
    detectors : ~gw_signal_tools.types.Detector or list[~gw_signal_tools.types.Detector]
        A list of the detectors that constitute the network. They have
        to be represented as instances of the ``Detector`` class from
        `gw_signal_tools.types`.

        In principle, a single ``Detector`` is also accepted, but then
        one could also just use ``FisherMatrix``.
    direct_computation : boolean, optional, default = True
        Whether to compute the Fisher matrix upon intialization of the
        class. Usually, this should be the preferred behaviour, but in
        certain cases one might want to save the computation time (e.g.
        if a systematic error shall be computed, where the Fisher
        matrix might be computed in some optimized point and not the one
        given by :code:`point`).
    metadata :
        All other keyword arguments will be treated as input for
        metadata of the Fisher matrix. This metadata consists of
        information relevant for derivative calculation. In particular,
        all settings for the inner products that are involved all the
        time can be specified here (e.g. the power spectral density or
        frequency range).

    See Also
    --------
    gw_signal_tools.fisher.FisherMatrix :
        Base class of ``FisherMatrixNetwork``.
    """

    def __init__(
        self,
        point: dict[str, u.Quantity],
        params_to_vary: str | list[str],
        wf_generator: Callable[[dict[str, u.Quantity]], FrequencySeries],
        detectors: Detector | list[Detector],
        direct_computation: bool = True,
        **metadata,
    ) -> None:
        """Initialize a ``FisherMatrixNetwork``."""
        # -- Setup for Network specifically
        if isinstance(detectors, Detector):
            self._detectors = [detectors]
        else:
            self._detectors = detectors

        self._detector_indices = {}
        for i, det in enumerate(self.detectors):
            self._detector_indices[det.name] = i

        # -- Now we can proceed with standard Fisher setup
        # -- Note that handling of detectors prior to this call is
        # -- detrimental because self._calc_fisher needs it, which is
        # -- potentially called in the following.
        _metadata = metadata.copy()
        _metadata.pop('psd', None)
        # -- Make sure no psd keyword is present, this is always taken
        # -- from detectors. Would not make sense to pass single PSD for
        # -- a network of multiple detectors anyway.

        super().__init__(
            point=point,
            params_to_vary=params_to_vary,
            wf_generator=wf_generator,
            direct_computation=False,  # Avoid call of self._calc_fisher
            **_metadata,
        )

        self._prepare_fisher_without_calc()

        if direct_computation:
            self._calc_fisher()

    # -- Adding Network specific properties
    @property
    def detectors(self):
        """
        List of ``Detector``, constituting a detector network.

        :type: `~gw_signal_tools.types.Detector`
        """
        return self._detectors

    def _index_from_det(self, det: Detector | str):
        """Get index for detector name."""
        if isinstance(det, Detector):
            return self._detector_indices[det.name]
        elif isinstance(det, str):
            return self._detector_indices[det]
        else:  # pragma: no cover
            raise ValueError('`det` must be a ``Detector`` instance or a string.')

    def detector_fisher(self, det: Detector | str | int) -> FisherMatrix:
        """Get Fisher matrix for detector, detector name or index."""
        if isinstance(det, (Detector, str)):
            return self._fisher_for_dets[self._index_from_det(det)]
        elif isinstance(det, int):
            return self._fisher_for_dets[det]
        else:  # pragma: no cover
            raise ValueError(
                '`det` must be a ``Detector`` instance, a string representing'
                'a detector name from `self.detectors` or an index to pick '
                'from the list of detectors.'
            )

    # -- Overwriting certain FisherMatrix properties
    def __getattr__(self, name: str) -> Any:
        return super().__getattr__(name)

    def update_attrs(
        self,
        new_point: Optional[dict[str, u.Quantity]] = None,
        new_params_to_vary: Optional[str | list[str]] = None,
        new_wf_generator: Optional[
            Callable[[dict[str, u.Quantity]], FrequencySeries]
        ] = None,
        new_detectors: Optional[Detector | list[Detector]] = None,
        **new_metadata,
    ) -> FisherMatrixNetwork:
        """
        Generate a Fisher matrix network with properties like the
        currentinstance has, but selected updates.
        Note that this creates a new instance of ``FisherMatrixNetwork``
        since updating properties would require new calculation anyway.

        Parameters
        ----------
        new_point : dict[str, ~astropy.units.Quantity]
            Point in parameter space at which the Fisher matrices are
            evaluated, encoded as key-value pairs representing
            parameter-value pairs. Given as input to
            :code:`wf_generator`.
        new_params_to_vary : str or list[str]
            Parameter(s) with respect to which the derivatives will be
            computed, the norms of which constitute the Fisher matrices.
            Must be compatible with :code:`param_to_vary` input to the
            function :code:`~gw_signal_tools.fisher.fisher_utils.
            get_waveform_derivative_1D_with_convergence`, i.e. either
            :code:`'tc'` (equivalent: :code:`'time'`), :code:`'psi'`
            (equivalent up to a factor: :code:`'phase' = 2*'psi'`) or a
            key in :code:`point`.

            Note that for this function, it is not required to specify a
            completely novel set. Updating only selected parameters is
            suppported
        new_wf_generator : Callable[[dict[str, ~astropy.units.Quantity]], ~gwpy.frequencyseries.FrequencySeries]
            Arbitrary function that is used for waveform generation. The
            required signature means that it has one non-optional
            argument, which is expected to accept the input provided in
            :code:`point`, while the output must be a
            ``~gwpy.frequencyseries.FrequencySeries`` (the standard
            output of LAL gwsignal generators) because it carries
            information about value, frequencies and units, which are
            all required for the calculations that are carried out.

            Convenient options are the methods
            :code:`~gw_signal_tools.waveform_utils.get_wf_generator`
            or :code:`FisherMatrix.get_wf_generator`, which generate a
            suitable function from a few arguments.

        Returns
        -------
        ~gw_signal_tools.fisher_matrix.FisherMatrixNetwork
            New Fisher matrix, calculated with updated metadata.
        """
        if new_point is None:
            new_point = self.point

        if new_params_to_vary is None:
            new_params_to_vary = self.params_to_vary

        if new_wf_generator is None:
            new_wf_generator = self.wf_generator

        if new_detectors is None:
            new_detectors = self.detectors

        if len(new_metadata) > 0:
            _new_metadata = self.metadata | new_metadata
        else:
            _new_metadata = self.metadata

        out = FisherMatrixNetwork(
            new_point,
            new_params_to_vary,
            new_wf_generator,
            new_detectors,
            **_new_metadata,
        )
        out._wf_generator = new_wf_generator  # Avoid it is wrapped again in setter

        return out

    def _prepare_fisher_without_calc(self):
        """Initialize ``FisherMatrix`` instances for each detector."""
        self._fisher_for_dets = []

        for det in self.detectors:
            self._fisher_for_dets += [
                FisherMatrix(
                    point=self.point | {'det': det.name},
                    params_to_vary=self.params_to_vary,
                    wf_generator=self.wf_generator,
                    direct_computation=False,
                    **(self.metadata | det.inner_prod_kwargs),
                )
            ]

    def _calc_fisher(self):
        """
        Calculate the Fisher matrices for each detector and combine them
        into the network Fisher matrix by adding them together.
        """
        # -- Note: I do not think there is a way to make this more
        # -- efficient. While sensitivities and thus PSDs might be
        # -- similar, the response functions are definitely not in most
        # -- cases. Thus no shortcut can be taken.

        self._fisher = 0.0
        for i, det in enumerate(self.detectors):
            det_fisher = self._fisher_for_dets[i]

            self._fisher += det_fisher.fisher

            self._deriv_info[det.name] = det_fisher.deriv_info

        if (cond_numb := self.cond('fro')) > 1e15:  # pragma: no cover
            # -- Conservative threshold choice for double precision,
            # -- as quoted e.g. in gwbench paper
            logger.info(
                f'This Fisher matrix has a condition number of {cond_numb}, '
                'meaning it is ill-conditioned.'
            )

    def systematic_error(
        self,
        reference_wf_generator: Callable[[dict[str, u.Quantity]], FrequencySeries],
        params: str | list[str] | None = None,
        optimize: bool | str | list[str] = True,
        optimize_fisher: str | list[str] | None = None,
        return_opt_info: bool = False,
        is_true_point: bool = False,
        **inner_prod_kwargs,
    ) -> MatrixWithUnits | tuple[MatrixWithUnits, dict[str, Any]]:
        if isinstance(optimize, str):
            optimize = [optimize]

        if isinstance(optimize_fisher, str):
            optimize_fisher = [optimize_fisher]

        # -- Goal of this function: duplicate as little code as possible
        # -- -> the operations required for this (mainly matrix
        # --    multiplications) do not add significant overhead
        # --    compared to putting adjusted version of code from
        # --    FisherMatrix.sys_error here (main cost is waveform
        # --    generation and thus optimization)

        fisher = 0.0
        opt_bias = 0.0
        vector = 0.0
        # -- 0. is most convenient way to initialize here, adding a
        # -- MatrixWithUnits on top is allowed and we do not have to
        # -- worry about compatible units etc

        optimization_info = {}

        # logging.disable(logging.CRITICAL)  # TODO: only switch info stuff off maybe?
        # -- Disable logging for now, e.g. to avoid calls due to bad
        # -- condition number in inversion (we do not intend to use the
        # -- inverse matrices of each detector, calls irrelevant here).

        for i, det in enumerate(self.detectors):
            # self.detector_fisher(i).fisher  # Now already done in each FisherMatrix
            _, info = self.detector_fisher(i).systematic_error(
                reference_wf_generator=reference_wf_generator,
                params=None,  # Get all for now, filter before return
                optimize=optimize,
                optimize_fisher=optimize_fisher,
                return_opt_info=True,
                is_true_point=is_true_point,
                **inner_prod_kwargs,
            )

            optimization_info[det.name] = info

            if isinstance(optimize, bool) and not optimize:
                used_opt_bias = 0.0

                if optimize_fisher is not None:
                    used_fisher = info['opt_fisher'].fisher
                else:
                    used_fisher = self.detector_fisher(i).fisher
            else:
                # -- Some kind of optimization was carried out, thus we
                # -- can access attribute in info dictionary
                used_fisher = info['opt_fisher'].fisher
                used_opt_bias = info['opt_bias']

                opt_bias += used_fisher @ used_opt_bias

            vector += info['deriv_vector']
            fisher += used_fisher

        # logging.disable(logging.NOTSET)

        fisher_bias = MatrixWithUnits.inv(fisher) @ (vector + opt_bias)

        # -- Check which params shall be returned and then return -------------
        if params is not None:
            if isinstance(params, str):
                params = [params]

            if optimize_fisher is None:
                param_indices = self.get_param_indices(params)
            else:
                # -- Take difference of parameters
                _params = params.copy()
                for param in optimize_fisher:
                    try:
                        _params.remove(param)
                    except ValueError:
                        # -- Is not supposed to be returned, continue
                        pass

                param_indices = self.get_param_indices(_params)

            fisher_bias = fisher_bias[param_indices]

        if return_opt_info is False:
            return fisher_bias
        else:
            return fisher_bias, optimization_info

    systematic_error.__doc__ = FisherMatrix.systematic_error.__doc__

    def snr(self, **inner_prod_kwargs):
        """
        Calculate the signal-to-noise ratio (SNR) of the signal that
        `self.wf_generator` produces at `self.point`.

        Parameters
        ----------
        inner_prod_kwargs :
            Any keyword argument given here will be passed to the inner
            product calculation. Enables e.g. testing SNR with different
            PSD while leaving all other arguments the same.

        Returns
        -------
        ~astropy.units.Quantity :
            SNR, i.e. norm of signal, in the given detector network.
        """
        _inner_prod_kwargs = self._inner_prod_kwargs | inner_prod_kwargs
        _inner_prod_kwargs.pop('psd', None)  # Make sure no PSD given

        snr = 0.0
        for det in self.detectors:
            signal = self.wf_generator(self.point | {'det': det.name})
            snr += norm(signal, **(_inner_prod_kwargs | det.inner_prod_kwargs)) ** 2

        return snr**0.5

    def __copy__(self) -> FisherMatrix:
        new_network = FisherMatrixNetwork(
            point=self.point,
            params_to_vary=self.params_to_vary,
            wf_generator=self.wf_generator,
            detectors=self.detectors,
            direct_computation=False,
            **self.metadata,
        )

        new_network._fisher = self.fisher.copy()
        new_network._fisher_inverse = self.fisher_inverse.copy()
        new_network._deriv_info = self.deriv_info.copy()
        new_network._is_projected = self.is_projected

        return new_network
