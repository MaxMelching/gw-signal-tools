from typing import Optional
import logging

import numpy as np
from scipy.integrate import simpson

from gwpy.timeseries import TimeSeries
from gwpy.frequencyseries import FrequencySeries
import astropy.units as u

from .waveform_utils import (
    td_to_fd_waveform, pad_to_get_target_df, restrict_f_range
)


__doc__ = """
Implementation of noise-weighted inner product that is
common in GW data analysis and helpers for computation.
"""


def inner_product(
    signal1: TimeSeries | FrequencySeries,
    signal2: TimeSeries | FrequencySeries,
    psd: Optional[FrequencySeries] = None,
    f_range: Optional[list[float] | list[u.Quantity]] = None,
    df: Optional[float | u.Quantity] = None,
    optimize_time_and_phase: bool = False  # Call it 'compute_match'?
) -> u.Quantity | tuple[TimeSeries, u.Quantity, u.Quantity]:
    """
    Calculates the noise-weighted inner product of two signals.

    Parameters
    ----------
    signal1 : ~gwpy.timeseries.TimeSeries or
    ~gwpy.frequencyseries.FrequencySeries
        First signal
    signal2 : ~gwpy.timeseries.TimeSeries or
    ~gwpy.frequencyseries.FrequencySeries
        Second signal
    psd : ~gwpy.frequencyseries.FrequencySeries, optional,
    default = None
        Power spectral density to use in inner product. If None, it is taken
        to be 1 1/Hz at all frequencies.
    f_range : list[float] or list[~astropy.units.Quantity], optional,
    default = None
        Frequency range to compute inner product over. Is potentially
        cropped if bounds are greater than frequency range of one of the
        input signals.

        The whole argument can be None, otherwise it must have length 2.
        However, one of the bounds (or both) can still be None, which
        indicates that no boundary shall be set.
    df : float or ~astropy.units.Quantity, optional, default = None
        Distance df between samples in frequency domain to use in
        integration.
        If None, it is set to 0.0625 Hz (or whatever frequency unit is
        used in the signals), which is the default df of frequency
        domain waveforms generated by `~lalsimulation.gwsignal`.
    optimize_time_and_phase : bool, optional, default = False
        Determines if a match is computed or just a "regular" inner
        product. The match will be optimized over relative time and
        phase shifts between `signal1` and `signal2`.

    Returns
    -------
    ~astropy.units.Quantity or tuple[~gwpy.timeseries.TimeSeries,
    ~astropy.units.Quantity, ~astropy.units.Quantity]
        Inner product value with `signal1`, `signal2` inserted.

    Raises
    ------
    TypeError
        In case either one of `signal1`, `signal2`, `psd` has wrong type.
    ValueError
        In case format of `f_range` parameter is not correct.

    See also
    --------
    gw_signal_tools.waveform_utils.td_to_fd_waveform :
        Used to convert ``TimeSeries`` input to a ``FrequencySeries``.
    gwpy.frequencyseries.frequencyseries.interpolate :
        Function used to get signals to same sampling rate.
    
    Notes
    -----
    Some tips regarding the `df` parameter:
    (i) It should not be too large, otherwise results of the inner
    product may be erroneous.
    (ii) If chosen very small (e.g. in range of 0.001Hz), you should
    consider selecting only powers of two like 2**-10 Hz because these
    work best with certain function calls that utilize the Fourier
    transform of the involved signals. An indicator this might be
    necessary is a shape mismatch error.
    """

    # TODO: maybe do FT first (move else case back there), then we only need
    # to check for frequency units
    
    # ----- Handling of units -----
    if isinstance(signal1, FrequencySeries):
        frequ_unit = signal1.frequencies.unit
        signal_unit = signal1.unit
    elif isinstance(signal1, TimeSeries):
        frequ_unit = signal1.times.unit * u.Hz / u.s
        signal_unit = signal1.unit * u.s
    else:
        raise TypeError(
            '`signal2` has to be a GWpy ``TimeSeries`` or ``FrequencySeries``.'
        )

    if isinstance(signal2, FrequencySeries):
        assert frequ_unit == signal2.frequencies.unit, \
            'Need consistent frequency/time units for `signal1` and `signal2`.'
        
        assert signal_unit == signal2.unit, \
            'Need consistent units of `signal1` and `signal2`.'
    elif isinstance(signal2, TimeSeries):
        assert frequ_unit == signal2.times.unit * u.Hz / u.s, \
            'Need consistent frequency/time units for `signal1` and `signal2`.'
        
        assert signal_unit == signal2.unit * u.s, \
            'Need consistent signal units for `signal1` and `signal2`.'
    else:
        raise TypeError(
            '`signal2` has to be a GWpy ``TimeSeries`` or ``FrequencySeries``.'
        )
    

    # ----- Handling PSD -----
    if psd is None:
        from .PSDs import psd_no_noise

        psd = psd_no_noise.copy()

        # Make sure units are consistent with input. PSD is always a density,
        # i.e. strain per frequency
        psd.override_unit(1 / frequ_unit)  # TODO: change to strain/Hz once lal updates are incorporated
        if (psd_frequ_unit := psd.frequencies.unit) != frequ_unit:
            psd.frequencies *= (frequ_unit / psd_frequ_unit)
        
        
        # V2
        # psd = FrequencySeries(
        #     psd_no_noise.value / frequ_unit,
        #     frequencies=psd_no_noise.frequencies.value * frequ_unit
        # )
    
    if isinstance(psd, FrequencySeries):
        assert frequ_unit == psd.frequencies.unit, \
            'Need consistent frequency/time units for `psd` and other signals.'
        
        assert 1 / frequ_unit == psd.unit, \
            ('Need consistent signal units for psd and `signal1`, `signal2`,'
            'i.e. psd unit has to be strain per frequency.')
        # TODO: change to strain/Hz once lal updates are incorporated
    else:
        raise TypeError('`psd` has to be a GWpy ``FrequencySeries`` or None.')


    # ----- Handling df argument -----
    if df is None:
        df = 0.0625 * frequ_unit  # Default value of output of FDWaveform
    else:
        try:
            df = u.Quantity(df, unit=frequ_unit)
        except u.UnitConversionError:
            # Conversion only fails if df is already Quantity and has
            # non-matching unit, so we can assume that df.unit works
            raise ValueError(
                f'Need consistent frequency units for `df` ({df.unit}) and'
                f' signals ({frequ_unit}).'
            )


    # ----- If necessary, do fft (padding to ensure -----
    # ----- sufficient resolution in frequency domain) -----
    if isinstance(signal1, TimeSeries):
        signal1 = td_to_fd_waveform(pad_to_get_target_df(signal1, df))

    if isinstance(signal2, TimeSeries):
        signal2 = td_to_fd_waveform(pad_to_get_target_df(signal2, df))
        
    logging.debug(f'{signal_unit}, {signal1.unit}, {signal2.unit}, {psd.unit}')
    

    # ----- Handling frequency range -----
    f_lower, f_upper = [
        max([signal1.frequencies[0], signal2.frequencies[0], psd.frequencies[0]]),
        min([signal1.frequencies[-1], signal2.frequencies[-1], psd.frequencies[-1]])
    ]

    # If bounds are given, check that they fit the input data
    if f_range is not None:
        if len(f_range) != 2:
            raise ValueError(
                '`f_range` must contain lower and upper frequency bounds for'
                'integration. One of them or both can be `None`, but both'
                'have to be specified if `f_range` is given.'
            )
        
        # Check if both lower and upper are given or one of them is None
        if f_range[0] is not None:
            try:
                f_lower_new = u.Quantity(f_range[0], unit=frequ_unit)
            except u.UnitConversionError:
                # Conversion only fails if df is already Quantity and has
                # non-matching unit, so we can assume that df.unit works
                raise ValueError(
                    'Need consistent frequency units for `f_range` members'
                    f' ({f_range[0].unit}) and signals ({frequ_unit}).'
                )
        else:
            f_lower_new = f_lower
        
        if f_range[1] is not None:
            try:
                f_upper_new = u.Quantity(f_range[1], unit=frequ_unit)
            except u.UnitConversionError:
                # Conversion only fails if df is already Quantity and has
                # non-matching unit, so we can assume that df.unit works
                raise ValueError(
                    'Need consistent frequency units for `f_range` members'
                    f' ({f_range[1].unit}) and signals ({frequ_unit}).'
                )

            # TODO: implement check of f_max with Nyquist of signals -> needed?
        else:
            f_upper_new = f_upper


        # New lower bound must be greater than current lower bound,
        # otherwise no values for the range are available in signals
        if f_lower_new >= f_lower:
            f_lower = f_lower_new
        else:
            # Leave lower bound at f_lower, no update
            logging.info(
                f'Given lower bound of {f_lower_new} is smaller than '
                'values available from given signals. Taking a lower '
                f'bound of {f_lower} instead.'
            )

        # New upper bound must be smaller than current upper bound,
        # otherwise no values for the range are available in signals
        if f_upper_new <= f_upper:
            f_upper = f_upper_new
        else:
            # Leave upper bound at f_upper, no update
            logging.info(
                f'Given upper bound of {f_upper_new} is larger than '
                'values available from given signals. Taking an upper '
                f'bound of {f_upper} instead.'
            )

    logging.debug([f_lower, f_upper])


    # ----- Get signals to same frequencies, i.e. make df -----
    # ----- equal (if necessary) and then restrict range -----
    df_val = df.value  # interpolate wants dimensionless df

    psd_unit = psd.unit  # Has to be kept as long as GWPy bug present
    
    # signal1 = signal1.interpolate(df_val) #if not np.isclose(signal1.df, df, atol=0.0, rtol=0.01) else signal1#.copy()
    # signal2 = signal2.interpolate(df_val) #if not np.isclose(signal2.df, df, atol=0.0, rtol=0.01) else signal2#.copy()
    # psd = psd.interpolate(df_val) #if not np.isclose(psd.df, df, atol=0.0, rtol=0.01) else psd#.copy()
    # # Perhaps faster because interpolate does not seem to copy epoch

    # # epochs = [signal1.epoch, signal2.epoch, psd.epoch]

    # signal1.epoch = None
    # signal2.epoch = None
    # psd.epoch = None


    # We do see performance gain when doing this instead of interpolating each time
    # -> in principle, this is custom copying
    signal1 = signal1.interpolate(df_val) if not np.isclose(signal1.df, df, atol=0.0, rtol=0.01) else FrequencySeries(
        signal1.value,  # TODO: see if unit is copied -> can we just give signal1 in here? NOPE, this would copy epch as well; give unit manually
        # frequencies=signal1.frequencies,
        f0=signal1.f0,
        df=signal1.df,
        # epoch=None
    )

    signal2 = signal2.interpolate(df_val) if not np.isclose(signal2.df, df, atol=0.0, rtol=0.01) else FrequencySeries(
        signal2.value,
        # frequencies=signal2.frequencies,
        f0=signal2.f0,
        df=signal2.df,
        # epoch=None
    )

    psd = psd.interpolate(df_val) if not np.isclose(psd.df, df, atol=0.0, rtol=0.01) else FrequencySeries(
        psd.value,
        # frequencies=psd.frequencies,
        f0=psd.f0,
        df=psd.df,
        # epoch=None
    )

    # Could also try to do this in a separate function
    # signal1 = get_signal_at_target_df(signal1, df=df)
    # signal2 = get_signal_at_target_df(signal2, df=df)
    # psd = get_signal_at_target_df(psd, df=df)

    # NOTE: these lines are temporary and supposed to fix a bug in interpolate
    if signal1.unit != signal_unit:
        signal1 *= (signal_unit / signal1.unit)
    if signal2.unit != signal_unit:
        signal2 *= (signal_unit / signal2.unit)
    if psd.unit != psd_unit:
        psd *= (psd_unit / psd.unit)


    if not optimize_time_and_phase:
        # signal1 = signal1.crop(start=f_lower, end=f_upper)
        # signal2 = signal2.crop(start=f_lower, end=f_upper)
        # psd = psd.crop(start=f_lower, end=f_upper)

        # TODO: check if rounding needed due to use of `floor` in crop?
        signal1 = signal1.crop(start=f_lower + 0.9 * df, end=f_upper)
        signal2 = signal2.crop(start=f_lower + 0.9 * df, end=f_upper)
        psd = psd.crop(start=f_lower + 0.9 * df, end=f_upper)

        # signal1.epoch, signal2.epoch, psd.epoch = epochs

        return inner_product_computation(signal1, signal2, psd)
    else:
        # More complicated because fft routines expect certain frequency
        # ranges. Thus checking if requirements are fulfilled
        if f_lower >= 0.0 * frequ_unit:
            signal1 = restrict_f_range(signal1, f_range=[f_lower, f_upper], pad_to_f_zero=True,
                                       copy=False, cut_upper=True)
            signal2 = restrict_f_range(signal2, f_range=[f_lower, f_upper], pad_to_f_zero=True,
                                       copy=False, cut_upper=True)
            psd = restrict_f_range(psd, f_range=[f_lower, f_upper], fill_val=1.0,
                                   pad_to_f_zero=True, copy=False, cut_upper=True)
        else:
            signal1 = restrict_f_range(signal1, f_range=[f_lower, f_upper], pad_to_f_zero=False,
                                       copy=False, cut_upper=True)
            signal2 = restrict_f_range(signal2, f_range=[f_lower, f_upper], pad_to_f_zero=False,
                                       copy=False, cut_upper=True)
            psd = restrict_f_range(psd, f_range=[f_lower, f_upper], fill_val=1.0,
                                   pad_to_f_zero=False, copy=False, cut_upper=True)

        # if (f0 := max(signal1.f0, signal2.f0, psd.f0)) == 0:
        #     signal1 = signal1.crop(end=f_upper)
        #     signal2 = signal2.crop(end=f_upper)
        #     psd = psd.crop(end=f_upper)

        #     # Is cropping really the smartest thing to do? Because setting
        #     # to zero would increase time domain resolution, right? Which
        #     # would be very desirable

        #     number_to_fill = int((f_lower.value - 0.0) / df_val)  # Symbolic -0.0
        #     logging.info(number_to_fill)

        #     signal1[:number_to_fill] = np.zeros(number_to_fill) << signal_unit
        #     signal2[:number_to_fill] = np.zeros(number_to_fill) << signal_unit
        #     psd[:number_to_fill] = np.ones(number_to_fill) << psd.unit

        #     # signal1 = restrict_f_range(signal1, f_range=[f_lower, f_upper], pad_to_f_zero=True,
        #     #                            copy=True, cut_upper=True)
        #     # signal2 = restrict_f_range(signal2, f_range=[f_lower, f_upper], pad_to_f_zero=True,
        #     #                            copy=True, cut_upper=True)
        #     # psd = restrict_f_range(psd, f_range=[f_lower, f_upper], fill_val=1.0,
        #     #                        pad_to_f_zero=True, copy=True, cut_upper=True)
            
        #     logging.info(signal1.frequencies)
        #     logging.info(signal2.frequencies)
        #     logging.info(psd.frequencies)
        # elif f0 > 0:
        #     signal1 = signal1.crop(start=f_lower + 0.9 * df, end=f_upper)
        #     signal2 = signal2.crop(start=f_lower + 0.9 * df, end=f_upper)
        #     psd = psd.crop(start=f_lower + 0.9 * df, end=f_upper)

        #     # irfft wants start at f=0, so we may have to pad signals with zeros
        #     number_to_append = int((f_lower.value - 0.0) / df_val)  # Symbolic -0.0

        #     f_series_to_pad = FrequencySeries(
        #         np.zeros(number_to_append),
        #         unit=signal_unit,
        #         f0=0.0,
        #         df=df,
        #         dtype=complex  # TODO: use signal1.dtype?
        #     )


        #     try:
        #         # Note: `pad` argument of append does not help, does what we do
        #         signal1 = f_series_to_pad.append(signal1, inplace=False)

        #         # f_series_to_pad *= signal2.unit / f_series_to_pad.unit  # Right now, we assure signal1 and signal2 have same unit
        #         signal2 = f_series_to_pad.append(signal2, inplace=False)

                
        #         f_series_to_pad.override_unit(psd.unit)
        #         f_series_to_pad.fill(1.0 * f_series_to_pad.unit)
        #         # 1.0 and not 0.0 to avoid division by zero
        #         # Contribution is zero anyway because signals are zero there

        #         psd = f_series_to_pad.append(psd, inplace=False)
        #     except ValueError as err:
        #         err_msg = str(err)

        #         if 'Cannot append discontiguous FrequencySeries' in err_msg:
        #             raise ValueError(
        #                 'Lower frequency bound and frequency spacing `df` do not '
        #                 'match, cannot smoothly continue signals to f=0 (required '
        #                 'for Fourier transform). This could be fixed by specifying'
        #                 ' a lower bound that is some integer multiple of the given'
        #                 ' `df` (if none was given, it is equal to 0.0625, where '
        #                 'the unit is derived from the signal frequencies) or by '
        #                 'adjusting the given `df`. Note that the source of this '
        #                 'error might be a single signal out of the inputs, for '
        #                 'instance one that does not start at f=0.'
        #             )
        #         else:
        #             # Raise error that would have been raised without exception 
        #             raise ValueError(err_msg)
        # else:
        #     number_to_append = abs(int((f_upper.abs().value - f_lower.abs().value) / df_val))

        #     assert np.ifftshift(signal1.frequencies) != 0.0 * frequ_unit, \
        #         ('signal1 has a negative starting frequency, but not the '
        #          'frequency range expected by `~numpy.fft.fft`. This is '
        #          'required when calling with `optimize_time_and_phase=True`.')

        #     if f_upper.abs() == f_lower.abs():
        #         pass
        #     elif f_upper.abs() > f_lower.abs():
        #         f_series_to_pad = FrequencySeries(
        #             np.zeros(number_to_append),
        #             unit=signal_unit,
        #             f0=-f_upper,
        #             df=df,
        #             dtype=complex  # TODO: use signal1.dtype?
        #         )


        #         try:
        #             # Note: `pad` argument of append does not help, does what we do
        #             signal1 = f_series_to_pad.append(signal1, inplace=False)

        #             # f_series_to_pad *= signal2.unit / f_series_to_pad.unit  # Right now, we assure signal1 and signal2 have same unit
        #             signal2 = f_series_to_pad.append(signal2, inplace=False)

                    
        #             f_series_to_pad.override_unit(psd.unit)
        #             f_series_to_pad.fill(1.0 * f_series_to_pad.unit)
        #             # 1.0 and not 0.0 to avoid division by zero
        #             # Contribution is zero anyway because signals are zero there

        #             psd = f_series_to_pad.append(psd, inplace=False)
        #         except ValueError as err:
        #             err_msg = str(err)

        #             if 'Cannot append discontiguous FrequencySeries' in err_msg:
        #                 raise ValueError(
        #                     'Lower frequency bound and frequency spacing `df` do not '
        #                     'match, cannot smoothly continue signals to f=0 (required '
        #                     'for Fourier transform). This could be fixed by specifying'
        #                     ' a lower bound that is some integer multiple of the given'
        #                     ' `df` (if none was given, it is equal to 0.0625, where '
        #                     'the unit is derived from the signal frequencies) or by '
        #                     'adjusting the given `df`. Note that the source of this '
        #                     'error might be a single signal out of the inputs, for '
        #                     'instance one that does not start at f=0.'
        #                 )
        #             else:
        #                 # Raise error that would have been raised without exception 
        #                 raise ValueError(err_msg)
        #     else:        
        #         f_series_to_pad = FrequencySeries(
        #             np.zeros(number_to_append),
        #             unit=signal_unit,
        #             f0=-f_lower,
        #             df=df,
        #             dtype=complex  # TODO: use signal1.dtype?
        #         )


        #         try:
        #             # Note: `pad` argument of append does not help, does what we do
        #             signal1 = signal1.append(f_series_to_pad, inplace=False)

        #             # f_series_to_pad *= signal2.unit / f_series_to_pad.unit  # Right now, we assure signal1 and signal2 have same unit
        #             signal2 = signal2.append(f_series_to_pad, inplace=False)

                    
        #             f_series_to_pad.override_unit(psd.unit)
        #             f_series_to_pad.fill(1.0 * f_series_to_pad.unit)
        #             # 1.0 and not 0.0 to avoid division by zero
        #             # Contribution is zero anyway because signals are zero there

        #             psd = psd.append(f_series_to_pad, inplace=False)
        #         except ValueError as err:
        #             err_msg = str(err)

        #             if 'Cannot append discontiguous FrequencySeries' in err_msg:
        #                 raise ValueError(
        #                     'Lower frequency bound and frequency spacing `df` do not '
        #                     'match, cannot smoothly continue signals to f=0 (required '
        #                     'for Fourier transform). This could be fixed by specifying'
        #                     ' a lower bound that is some integer multiple of the given'
        #                     ' `df` (if none was given, it is equal to 0.0625, where '
        #                     'the unit is derived from the signal frequencies) or by '
        #                     'adjusting the given `df`. Note that the source of this '
        #                     'error might be a single signal out of the inputs, for '
        #                     'instance one that does not start at f=0.'
        #                 )
        #             else:
        #                 # Raise error that would have been raised without exception 
        #                 raise ValueError(err_msg)


        # TODO: implementation using built-in function
        # -> done; but for some reason this seems to be less efficient...
        # signal1 = signal1.pad(number_to_append, mode='constant', constant_values=0.0)
        # signal2 = signal2.pad(number_to_append, mode='constant', constant_values=0.0)
        # psd = psd.pad(number_to_append, mode='constant', constant_values=1.0)
        # -> could utilize 'linear_ramp' option mentioned above here...
        # Potentially useful... -> nope, see comments above

        # signal1.epoch, signal2.epoch, psd.epoch = epochs

        return optimized_inner_product(signal1, signal2, psd)


def inner_product_computation(
    signal1: FrequencySeries,
    signal2: FrequencySeries,
    psd: FrequencySeries
) -> u.Quantity:
    """
    Lower level function for inner product calculation. Assumes that
    signal conditioning has been done so that they contain values at the
    same frequencies and then carries out the actual computation.

    Parameters
    ----------
    signal1 : ~gwpy.frequencyseries.FrequencySeries
        First signal to put into inner product.
    signal2 : ~gwpy.frequencyseries.FrequencySeries
        Second signal to put into inner product.
    psd : ~gwpy.frequencyseries.FrequencySeries
        Power spectral density to use in inner product.

    Returns
    -------
    ~astropy.units
        Inner product value with `signal1`, `signal2` inserted.
    
    See also
    --------
    scipy.integrate.simpson : Used for evaluation of inner product.
    """

    # ----- Assure same distance of samples -----
    assert (np.isclose(signal1.df, psd.df, rtol=0.01)
            and np.isclose(signal2.df, psd.df, rtol=0.01)), \
        'Signals must have equal frequency spacing.'
    
    # Second step: make sure frequencies are sufficiently equal.
    # Maximum deviation allowed between the is given df, which
    # determines accuracy the signals have been sampled with.
    custom_error_msg = (
        'Frequency samples of input signals are not equal. This might be '
        'due to `df` being too large. If `df` is already small, consider '
        'choosing a (negative) power of two as these seem to work best.'
    )

    try:
        assert (np.all(np.isclose(signal1.frequencies, signal2.frequencies,
                                  atol=0.0, rtol=0.01))
                and np.all(np.isclose(signal1.frequencies, psd.frequencies,
                                      atol=0.0, rtol=0.01))), \
            custom_error_msg
    except ValueError:
        # Due to unequal sample size. Since this is automatically checked by
        # numpy, we can be sure that signal1.size = signal2.size = psd.size
        raise ValueError(custom_error_msg)
    
    # if (freq_unit := signal1.frequencies.unit) == u.Hz:
    #     # freq_unit = freq_unit.to(1/u.s)
    #     freq_unit = freq_unit

    return 4.0 * np.real(
        simpson(y=signal1 * signal2.conjugate() / psd, x=signal1.frequencies)
    # ) * (signal1.unit * signal2.unit / psd.unit * signal1.frequencies.unit)
    # ) * (signal1.unit * signal2.unit / psd.unit * signal1.frequencies.unit).decompose()  # Also resets scale, unwanted
    ) * (signal1.unit * signal2.unit / psd.unit * signal1.frequencies.unit).si  # Also resets scale, unwanted -> uhhh but value unaffected, only scale of unit. I guess that is the best we can do for now
    # ) * (signal1.unit * signal2.unit / psd.unit * freq_unit)
    # ) * (signal1.unit * signal2.unit / psd.unit * signal1.frequencies.unit * u.s / u.s)  # Cancellation works for dimensionless at least
    # ) * (((signal1.unit * signal2.unit) * signal1.frequencies.unit) / psd.unit)
    # ) * (((signal1.unit * signal2.unit) / psd.unit) * signal1.frequencies.unit)
    # ) * (signal1.unit * signal2.unit * 1/psd.unit * signal1.frequencies.unit)  # No way... Things to cancel correctly here if end unit is dimensionless
    # ) * (signal1.unit * signal2.unit * signal1.frequencies.unit * 1/psd.unit)  # No difference to line above


def optimized_inner_product(
    signal1: FrequencySeries,
    signal2: FrequencySeries,
    psd: FrequencySeries,
) -> tuple[TimeSeries, u.Quantity, u.Quantity]:
    """
    Lower level function for inner product calculation. Assumes that
    signal conditioning has been done so that they contain values at the
    same frequencies and then carries out the actual computation.

    In contrast to `inner_product_computation`, this function optimizes
    the inner product over time and phase shifts.

    Parameters
    ----------
    signal1 : ~gwpy.frequencyseries.FrequencySeries
        First signal to put into inner product.
    signal2 : ~gwpy.frequencyseries.FrequencySeries
        Second signal to put into inner product.
    psd : ~gwpy.frequencyseries.FrequencySeries
        Power spectral density to use in inner product.

    Returns
    -------
    tuple[~gwpy.timeseries.TimeSeries, ~astropy.units.Quantity,
    ~astropy.units.Quantity]
        A tuple with three values:
        (i) a ``TimeSeries`` where values of the inner product for
        different relative time shifts between `signal1`, `signal2`
        are stored (optimization over phase is not carried out)
        (ii) maximum absolute value of (i), corresponds to maximization
        of inner product over relative time and phase shifts
        (iii) time at which maximum value (ii) occurs in (i)
    """

    # ----- First step: assure same distance of samples -----
    assert (np.isclose(signal1.df, psd.df, atol=0.0, rtol=0.01)
            and np.isclose(signal2.df, psd.df, atol=0.0, rtol=0.01)), \
        'Signals must have equal frequency spacing.'
    # TODO: change checks to quantity_close?
    
    # ----- Second step: make sure all signals start at valid frequencies -----
    assert ((np.isclose(signal1.f0, 0.0, atol=0.0, rtol=0.01)
             and np.isclose(signal2.f0, 0.0, atol=0.0, rtol=0.01)
             and np.isclose(psd.f0, 0.0, atol=0.0, rtol=0.01)) or
             # TODO: think about condition again, for second argument zero this
             # effectively means we test for equality (which may be valid, right?
             # Fourier needs exactly zero)
            (np.isclose(-signal1.f0, signal1.frequencies[-1], atol=0.0, rtol=0.01)
             and np.isclose(-signal2.f0, signal2.frequencies[-1], atol=0.0, rtol=0.01)
             and np.isclose(-psd.f0, psd.frequencies[-1], atol=0.0, rtol=0.01))), \
        ('All signals must start at f=0 or span the same interval from '
        '0 to f_max and f_min to 0.')
            # TODO: think about second condition again. atol of df would also
            # be reasonable, right? For equal sample size, this condition
            # cannot be fulfilled

    # ----- Third step: assure frequencies are sufficiently equal. -----
    # ----- Maximum deviation allowed between the is given df, which -----
    # ----- determines accuracy the signals have been sampled with. -----
    custom_error_msg = (
        'Frequency samples of input signals are not equal. This might be '
        'due to `df` being too large. If `df` is already small, consider '
        'choosing a (negative) power of two as these seem to work best.'
    )
    # Is perhaps because interpolate uses fft, which works best with powers of two
    try:
        assert (np.all(np.isclose(signal1.frequencies, signal2.frequencies,
                                  atol=0.0, rtol=0.01))
                and np.all(np.isclose(signal1.frequencies, psd.frequencies,
                                      atol=0.0, rtol=0.01))), \
            custom_error_msg
    except ValueError:
        # Due to unequal sample size. Since this is automatically checked by
        # numpy, we can be sure that signal1.size = signal2.size = psd.size
        raise ValueError(custom_error_msg)
    
    # ----- Fourth step: computations -----
    dft_vals = (signal1 * signal2.conjugate() / psd)

    # Append zeros so that ifft can be used
    if np.isclose(0.0, dft_vals.f0.value, atol=0.0, rtol=0.01):
        logging.debug('PERFORMING RFFT')
        full_dft_vals = np.append(dft_vals.value, np.zeros(dft_vals.size - 1))
    else:
        logging.debug('PERFORMING FFT')
        full_dft_vals = np.fft.fftshift(dft_vals.value)

    dt = (1.0 / (full_dft_vals.size * signal1.df)).si

    match_series = 4.0 * TimeSeries(
        np.fft.ifft(full_dft_vals / dt.value),  # Discrete -> continuous
        unit=(signal1.unit * signal2.unit / psd.unit / dt.unit).si,
        t0=0.0 * dt.unit,
        dt=dt
    )

    match_result = match_series.abs().max()

    # Handle wrap-around of signal
    number_to_roll = match_series.size // 2  # Arbitrary value, no deep meaning
    match_series = np.roll(match_series, shift=number_to_roll)
    match_series.shift(-match_series.times[number_to_roll])

    # Compute peak time
    peak_index = np.argmax(match_series)
    peak_time = match_series.times[peak_index]
    
    return match_series, match_result, peak_time


def norm(
    signal: TimeSeries | FrequencySeries,
    *args,
    **kwargs
) -> u.Quantity | tuple[TimeSeries, u.Quantity, u.Quantity]:
    """
    Wrapper function for calculation of the norm of the given `signal`
    (i.e. square root of inner product between `signal` and `signal`,
    its SNR) as measured by the noise-weighted inner product
    implemented in `inner_product`.

    Parameters
    ----------
    signal : ~gwpy.timeseries.TimeSeries or
    ~gwpy.frequencyseries.FrequencySeries
        Signal to compute norm for.
    *args, **kwargs
        Additional arguments, will be passed to `inner_product` function.

    Returns
    -------
    ~astropy.units.Quantity or tuple[~gwpy.timeseries.TimeSeries,
    ~astropy.units.Quantity, ~astropy.units.Quantity]
        Norm of `signal`, i.e. square root of inner product of `signal`
        with itself.

        If `optimize_time_and_phase = True`, a tuple is returned that
        contains a ``TimeSeries``, the aforementioned norm and a time.
        See `optimized_inner_product` for details on the return.
    
    See also
    --------
    gw_signal_tools.inner_product.inner_product :
        Arguments are passed to this function for calculations.
    """

    out = inner_product(signal, signal, *args, **kwargs)

    if isinstance(out, (float, u.Quantity)):
        return np.sqrt(out)
    else:
        return np.sqrt(out[0]), np.sqrt(out[1]), out[2]


def overlap(
    signal1: TimeSeries | FrequencySeries,
    signal2: TimeSeries | FrequencySeries,
    *args,
    **kwargs
) -> u.Quantity | tuple[TimeSeries, u.Quantity, u.Quantity]:
    """
    Wrapper for calculation of the overlap of two given signals as
    measured by the noise-weighted inner product implemented in
    `inner_product`. This means the signals are normalized to have unit
    norm (with respect to this inner product) and then inserted into
    `inner_product`.

    Parameters
    ----------
    signal1 : ~gwpy.timeseries.TimeSeries or
    ~gwpy.frequencyseries.FrequencySeries
        First signal.
    signal2 : ~gwpy.timeseries.TimeSeries or
    ~gwpy.frequencyseries.FrequencySeries
        Second signal.
    *args, **kwargs
        Additional arguments, will be passed to `inner_product` function.

    Returns
    -------
    ~astropy.units.Quantity or tuple[~gwpy.timeseries.TimeSeries,
    ~astropy.units.Quantity, ~astropy.units.Quantity]
        Overlap of `signal1` and `signal2`.

        If `optimize_time_and_phase = True`, a tuple is returned that
        contains a ``TimeSeries``, the aforementioned norm and a time.
        See `optimized_inner_product` for details on the return.
    
    See also
    --------
    gw_signal_tools.inner_product.inner_product :
        Arguments are passed to this function for calculations.
    """

    out = inner_product(signal1, signal2, *args, **kwargs)

    normalization = 1.0  # Default value

    if isinstance(norm1 := norm(signal1, *args, **kwargs), (float, u.Quantity)):
        normalization *= norm1
    else:
        normalization *= norm1[1]

    if isinstance(norm2 := norm(signal2, *args, **kwargs), (float, u.Quantity)):
        normalization *= norm2
    else:
        normalization *= norm2[1]


    if isinstance(out, (float, u.Quantity)):
        return out / normalization
    else:
        return out[0] / normalization, out[1] / normalization, out[2]
