# -- Standard Lib Imports
# from functools import cached_property  # TODO: use for some stuff?
from typing import Callable, Optional, Literal, Any

# -- Third Party Imports
import numpy as np
import astropy.units as u
from gwpy.frequencyseries import FrequencySeries
from gwpy.timeseries import TimeSeries
import matplotlib.pyplot as plt
import matplotlib as mpl

# -- Local Package Imports
from ..logging import logger
from .inner_product import norm, inner_product, param_bounds
from .nd_deriv import (
    WaveformDerivativeNumdifftools, WaveformDerivativeAmplitudePhase
)


__doc__ = """
Module for the ``WaveformDerivative`` and
``WaveformDerivativeGWSignaltools`` classes.
"""

__all__ = ('WaveformDerivative', 'WaveformDerivativeGWSignaltools')


class WaveformDerivative():
    r"""
    Constructor class for numerical derivative of waveforms. This class
    allows to choose between different implementations by passing the
    .code:`deriv_routine` argument. All other arguments are passed on to
    the selected derivative class.

    Parameters
    ----------
    deriv_routine : Literal['gw_signal_tools', 'numdifftools', 'amplitude_phase']
        Available routines.
    
    Returns
    -------
    Instance of requested class.

    Notes
    -----
    Here we compare the different available derivative routines.

        - 'gw_signal_tools': usually the fastest method, but can can
        lack accuracy for certain configurations (since it only refines
        estimate for whole frequency range, not parts of it)

        - 'numdifftools': can do adaptive refinement only for certain
        frequencies where convergence is slower, making it potentially
        more reliable than the previous routine. However, this also
        requires more waveform calls, making the calculation slower.
        
        - 'amplitude_phase': may be beneficial for accuracy in case
        strain oscillates fast and thus has steep derivative. Then,
        looking at amplitude and phase separately should yield much more
        well-posed functions. For usual applications though, it may be
        significantly slower than the other routines. After all, two
        derivatives have to be calculated, which means it involves the
        waveform calls. But in case other routines fail, it might be
        worth a try. Moreover, this issue depends on whether waveform
        caching is activated or not.
    """
    def __new__(cls, *args, **kw_args):
        deriv_routine = kw_args.pop('deriv_routine', 'gw_signal_tools')

        match deriv_routine:
            case 'gw_signal_tools':
                return WaveformDerivativeGWSignaltools(*args, **kw_args)
            case 'numdifftools':
                return WaveformDerivativeNumdifftools(*args, **kw_args)
            case 'amplitude_phase':
                return WaveformDerivativeAmplitudePhase(*args, **kw_args)
            case _:
                raise ValueError(f"Invalid deriv_routine '{deriv_routine}'.")


class WaveformDerivativeGWSignaltools():
    r"""
    Calculate the derivative of an arbitrary waveform with respect to
    an arbitrary input parameter in frequency domain, using a selection
    of finite difference methods and a variable criterion to check the
    "quality" of approximation.

    Parameters
    ----------
    point : dict[str, ~astropy.units.Quantity]
        Point in parameter space at which the derivative is evaluated,
        encoded as key-value pairs representing parameter-value pairs.

        In principle, the keys can be arbitrary, only two requirements
        have to be fulfilled: (i) the dictionary must be accepted by
        :code:`wf_generator` since it is given as input to this functoin
        and (ii) :code:`param_to_vary` has to be accessible as a key
        (except one of the special cases mentioned in the description of
        :code:`params_to_vary` is true).
    param_to_vary : str
        Parameter with respect to which the derivative is taken. Must be
        a key in :code:`point` or one of :code:`'time'`,
        :code:`'phase'`.
        
        For time and phase shifts, analytical derivatives are applied.
        This is possible because they contribute only to a factor
        :math:`\exp(i \cdot phase - i \cdot 2 \pi \cdot f \cdot time)`
        in the waveform generated by `wf_generator`, i.e. they are
        global phase and time shifts.
        Beware that the polarization angle :code:`psi` might be
        degenerate with :code:`phase`, if you are using the complex
        strain combination :math:`h = h_+ \pm i \, h_{\times}`.

        The last analytical derivative is the one for the luminosity
        distance :math:`D_L`, which enters in waveforms only as an
        amplitude factor :math:`1/D_L`. Note that can only be done
        if the parameter recognized, i.e. if it is called `'distance'`.
    wf_generator : Callable[[dict[str, ~astropy.units.Quantity]], ~gwpy.frequencyseries.FrequencySeries]
        Arbitrary function that is used for waveform generation. The
        required signature means that it has one non-optional argument,
        which is expected to accept the input provided in
        :code:`point`, while the output must be a ``~gwpy.
        frequencyseries.FrequencySeries`` (the standard output of
        LAL gwsignal generators) because it carries information about
        value, frequencies and units, which are all required for the
        calculations that are carried out.

        A convenient option is to use the method
        :code:`~gw_signal_tools.waveform_utils.get_wf_generator`, which
        generates a suitable function from a few arguments.
    step_sizes : list[float], optional, default = None
        Step sizes used in the numerical differention. Based on the
        evaluation point, these are used as relative or absolute steps.
    start_step_size: float, optional, default = 1e-2
        Alternative way to control the relative step sizes. Determines
        the largest relative step size that is tried.
    convergence_check : Literal['diff_norm', 'mismatch'], optional, default = None
        Criterion used to asses stability of the result. Currently, two
        are available:

            * diff_norm: calculates the norm of the difference of two
              consecutive derivatives (using the function
              :code:`~gw_signal_tools.inner_product.norm`). This is
              compared to the norm of the most recent derivative and if
              their fraction is smaller than some threshold (specified
              in :code:`convergence_threshold`), the result is taken to
              be converged because the differences become negligible on
              the relevant scales (provided by the norm of the
              derivative).
            * mismatch: calculates the mismatch between consecutive
              derivatives (also using the function
              :code:`~gw_signal_tools.inner_product.norm`), which is
              defined as :math:`1-overlap`. Again, the result is taken
              to be converged if this mismatch falls under a certain
              threshold, provided by :code:`convergence_threshold`.

        For larger differences, they might produce different results,
        but their behaviour for small distances should be very similar
        because they coincide in the infinitesimal limit (they induce
        the same metric).
    convergence_threshold : float, optional, default = None
        Threshold that is used to decide if result is converged. This
        will be the case once the value of the criterion specified in
        :code:`convergence_check` is smaller than
        :code:`convergence_threshold` two iterations in a row.
    break_upon_convergence : bool, optional, default = True
        Whether to break upon the convergence described previously
        (difference smaller than given threshold two times in a row) or
        not. If not, results for all step sizes are calculated and the
        one with minimal convergence criterion value is selected.
    inner_prod_kwargs :
        All additional keyword arguments are passed to the inner product
        function during the corresponding calculations.

    Returns
    -------
    ~gwpy.frequencyseries.FrequencySeries or tuple[~gwpy.frequencyseries.FrequencySeries, dict[str, Any]]
        Derivative in frequency space with respect to
        :code:`param_to_vary`. If :code:`return_info = True`, also a
        dictionary with information about the result.

    Raises
    ------
    ValueError
        If an invalid value for convergence_check is provided.
    AssertionError
        If an invalid :code:`params_to_vary` is provided.
    
    See Also
    --------
    gw_signal_tools.inner_product.norm :
        Function used to create the involved inner products.

    Notes
    -----
    In principle, one can also pass a time domain generator as
    `wf_generator`, but then one might encounter errors due to signal
    lengths that change when waveforms for multiple parameter values are
    generated. In that case, the required operations are not possible.
    """
    def __init__(
        self,
        point: dict[str, u.Quantity],
        param_to_vary: str,
        wf_generator: Callable[[dict[str, u.Quantity]], FrequencySeries | TimeSeries],
        step_sizes: Optional[list[float] | np.ndarray] = None,
        start_step_size: Optional[float] = 1e-2,
        convergence_check: Optional[Literal['diff_norm', 'mismatch']] = None,
        convergence_threshold: Optional[float] = None,
        break_upon_convergence: bool = True,
        max_refine_numb: Optional[int] = 3,
        double_convergence: bool = True,  # Whether to demand double convergence or not
        deriv_formula: str = 'five_point',
        # return_info: bool = False,
        **inner_prod_kwargs
    ) -> None:
        self.point = point
        self.param_to_vary = param_to_vary
        self.wf_generator = wf_generator

        if step_sizes is None:
            self.step_sizes = np.reshape(np.outer([start_step_size/10**i for i in range(5)], [5, 1]), -1)[1:]
            # Indexing makes sure we do not start at 5*start_step_size
        else:
            if isinstance(step_sizes, float):
                step_sizes = [step_sizes]
            
            if len(step_sizes) == 1:
                self.max_refine_numb = max_refine_numb = 1

            self.step_sizes = step_sizes
        
        self.convergence_check = convergence_check
        self.convergence_threshold = convergence_threshold
        
        self.break_upon_convergence = break_upon_convergence
        self.double_convergence = double_convergence

        self.max_refine_numb = max_refine_numb

        self.deriv_formula = deriv_formula

        self.inner_prod_kwargs = inner_prod_kwargs
        self.inner_prod_kwargs['return_opt_info'] = False
        # Ensure float output of inner_product, even if optimization on

    # -- Properties that are set based on input
    @property
    def point(self) -> dict[str, u.Quantity]:
        """
        Point in parameter space at which waveform is differentiated,
        encoded as key-value pairs representing parameter-value pairs.

        :type: `dict[str, ~astropy.units.Quantity]`
        """
        return self._point
    
    @point.setter
    def point(self, point: dict[str, u.Quantity]) -> None:
        self._point = point
        try:
            self.wf = self.wf_generator(self.point)
        except AttributeError:
            # Class has just been initialized, no wf_generator yet
            pass

        if hasattr(self, '_deriv'):
            # -- Derivative that was calculated is not valid anymore
            del self._deriv

    @property
    def param_to_vary(self):
        """
        Parameter that derivative is taken with respect to.

        :type: `str`
        """
        return self._param_to_vary
    
    @param_to_vary.setter
    def param_to_vary(self, param: str):
        if (param != 'time' and param != 'phase'):
            # TODO: could also add distance here. Has analytical
            # derivative too, so strictly speaking it is not required
            # to be in point
            assert param in self.point

        self._param_to_vary = param

        if hasattr(self, '_deriv'):
            # -- Derivative that was calculated is not valid anymore
            del self._deriv

    @property
    def wf_generator(self):
        """
        Generator for waveform model that is differentiated.

        :type: `Callable[[dict[str, ~astropy.units.Quantity]], ~gwpy.frequencyseries.FrequencySeries | ~gwpy.timeseries.TimeSeries]`
        """
        return self._wf_generator
    
    @wf_generator.setter
    def wf_generator(self, generator: Callable[[dict[str, u.Quantity]], FrequencySeries | TimeSeries]) -> None:
        self._wf_generator = generator
        self.wf = generator(self.point)

        if hasattr(self, '_deriv'):
            # -- Derivative that was calculated is not valid anymore
            del self._deriv
    
    # @property
    # def step_size(self):
    #     return self._step_size
    # @property
    # def step_sizes(self):
    #     return self._step_size_collection[-1]
    
    # @step_sizes.setter
    # def step_sizes(self, steps):
    #     # -- Make sure _step_size_collection is already defined
    #     try:
    #         self._step_size_collection
    #     except AttributeError:
    #         self._step_size_collection = []
        
    #     self._step_size_collection += steps
    #     # TODO: do we have to make sure it is list that we append here?

    @property
    def step_sizes(self) -> dict[int, list[int]]:
        return self._step_sizes
    
    @step_sizes.setter
    def step_sizes(self, step_sizes: list[int]):
        self._step_sizes = step_sizes
    
    @property
    def convergence_check(self) -> str:
        return self._convergence_check
    
    @convergence_check.setter
    def convergence_check(self, convergence_check: Optional[str]) -> None:
        if convergence_check is None:
            convergence_check = 'diff_norm'
        else:
            if convergence_check not in ['mismatch', 'diff_norm']:
                raise ValueError(
                        'Invalid value for `convergence_check`.'
                    )
        
        self._convergence_check = convergence_check

        if hasattr(self, '_deriv'):
            # -- Derivative that was calculated is not valid anymore
            del self._deriv
    
    @property
    def convergence_threshold(self) -> float:
        return self._convergence_threshold
    
    @convergence_threshold.setter
    def convergence_threshold(self, convergence_threshold: Optional[float]) -> None:
        if convergence_threshold is None:
            match self.convergence_check:
                case 'diff_norm':
                    convergence_threshold = 0.001
                case 'mismatch':
                    convergence_threshold = 0.001
        
        self._convergence_threshold = convergence_threshold

        if hasattr(self, '_deriv'):
            # -- Derivative that was calculated is not valid anymore
            del self._deriv

    @property
    def max_refine_numb(self) -> int:
        return self._max_refine_numb
    
    @max_refine_numb.setter
    def max_refine_numb(self, num: int) -> None:
        self._max_refine_numb = int(num)

        if hasattr(self, '_deriv'):
            # -- Derivative that was calculated is not valid anymore
            del self._deriv
    
    # -- Internally used properties
    @property
    def param_center_val(self):
        """
        Value of `self.param_to_vary` at which derivative is taken by
        default.

        :type: `~astropy.units.Quantity`
        """
        return self.point[self.param_to_vary]
    # TODO: is this required? -> yup, fairly frequently accessed

    # @property
    # def wf(self) -> FrequencySeries:
        # return self.wf_generator(self.point)
    # But then we would loose advantage of storing it, right?
    # -> even cached_property would not be useful
    # -> maybe out own custom cacher would help here. But not used for now
    @property
    def wf(self) -> FrequencySeries | TimeSeries:
        """
        The waveform produced by `self.wf_generator` at `self.point`.

        :type: `~gwpy.frequencyseries.FrequencySeries` | `~gwpy.timeseries.TimeSeries`
        """
        return self._wf
    
    @wf.setter
    def wf(self, wf: FrequencySeries | TimeSeries) -> None:
        self._wf = wf

    @property
    def deriv(self):
        """
        The derivative at the selected point.

        :type: `~gwpy.frequencyseries.FrequencySeries` | `~gwpy.timeseries.TimeSeries`
        """
        if hasattr(self, '_deriv'):
            # -- Derivative was already computed, just return. We make
            # -- sure that all relevant settings remained the same in
            # -- the corresponding setters, otherwise _deriv deleted
            return self._deriv
        
        # -- Check if parameter has analytical derivative
        if self.param_to_vary == 'time':
            deriv = self.wf * (-1.j * 2. * np.pi * self.wf.frequencies)

            derivative_norm = norm(deriv, **self.inner_prod_kwargs)**2

            self.deriv_info = {
                'norm_squared': derivative_norm,
                'description': 'This derivative is exact.'
            }
            return deriv
        elif self.param_to_vary == 'phase':
            deriv = self.wf * 1.j / u.rad
            
            derivative_norm = norm(deriv, **self.inner_prod_kwargs)**2

            self.deriv_info = {
                'norm_squared': derivative_norm,
                'description': 'This derivative is exact.'
            }
            return deriv
        elif self.param_to_vary == 'distance':
            deriv = (-1./self.point['distance']) * self.wf

            derivative_norm = norm(deriv, **self.inner_prod_kwargs)**2

            self.deriv_info = {
                'norm_squared': derivative_norm,
                'description': 'This derivative is exact.'
            }
            return deriv
        
        # TODO: automatically adjust deriv_formula here if needed
        # -> of course with logger.info output

        # -- Test for valid point
        self.test_point(0.)

        self.is_converged = False
        self.refine_numb = 0

        for self.refine_numb in range(self.max_refine_numb):
            # -- Initialize value storage
            self._derivative_vals = []
            self._deriv_norms = []
            self._convergence_vals = []
            # TODO: then maybe we should reset the step sizes as well?

            self._iterate_through_step_sizes()
            
            # Check if step sizes shall be refined. This is be done if no breaking
            # upon convergence is wanted or if no convergence was reached yet
            if not self.break_upon_convergence or not self.is_converged:
                # TODO: remove break_upon_convergence and just handle that via convergence_threshold?
                # I.e. set to 0.0 if no breaking wanted
                
                if np.all(np.equal(self._convergence_vals, np.inf)):
                    # Only invalid step sizes for this parameter, we
                    # have to decrease further
                    self.min_dev_index = len(self.step_sizes) - 1
                else:
                    self.min_dev_index = np.nanargmin(self._convergence_vals)  # type: ignore
                # Explanation of ignore: it seems like a signedinteger is returned
                # by nanargmin, violates static checking for int. Note that we do
                # use nan-version here just in case something goes wrong in norm or
                # so, making it zero (should not happen, though)

                if self.refine_numb < (self.max_refine_numb - 1):
                    self._update_step_sizes()

                    try:
                        if self._step_size_too_small:
                            break
                    except AttributeError:
                        pass
            else:
                break

        if not self.is_converged:
            # logger.info(
            #     'Calculations using the selected step sizes did not converge '
            #     f'for parameter `{self.param_to_vary}` using convergence check method '
            #     f'`{self.convergence_check}`, even after {self.max_refine_numb} refinements of '
            #     'step sizes. The minimal value of the criterion was '
            #     f'{self._convergence_vals[self.min_dev_index]}, ' + ((f'which is above the '
            #     f'selected threshold of {self.convergence_threshold}. ')
            #     if self._convergence_vals[self.min_dev_index] > self.convergence_threshold else (
            #     f'which is below the selected threshold of {self.convergence_threshold}'
            #     ', but the previous and following value were not.')) +
            #     'If you are not satisfied with the result (for an eye test, you '
            #     'can plot the `convergence_plot` value returned in case '
            #     '`return_info=True`), consider changing the initial step sizes.'
            # )

            logger.info('NO CONVERGENCE')

            # TODO: rewrite this text. Also make sure that self._convergence_vals etc are all defined
            # -> maybe make them properties and there we check this, set them
            #    otherwise?
        
        self.deriv_info = {
            'norm_squared': self._deriv_norms[self.min_dev_index],
            'final_step_size': self.step_sizes[self.min_dev_index],
            'final_convergence_val': self._convergence_vals[self.min_dev_index],
            'number_of_refinements': self.refine_numb,
            'final_set_of_step_sizes': self.step_sizes,
            'deriv_formula': self.deriv_formula
        }
        
        self._deriv = self._derivative_vals[self.min_dev_index]
        return self._deriv    
    
    def _check_converged(self):
        """
        Check if derivative has converged, according to the selected
        convergence check (either two or three consecutive values of
        convergence checker must be below `self.convergence_threshold`).
        """
        if self.double_convergence:
            if (len(self._convergence_vals) >= 2
                and (self._convergence_vals[-1] <= self.convergence_threshold)
                and (self._convergence_vals[-2] <= self.convergence_threshold)):
                # Double checking is more robust
                self.is_converged = True  # Remains true, is never set to False again
        else:
            if (self._convergence_vals[-1] <= self.convergence_threshold):
                self.is_converged = True  # Remains true, is never set to False again
                # We use five-point stencil, which converges fast, so
                # that it is justified to interpret two consecutive
                # results being very similar as convergence
                # -> testing revealed that double_convergence leads to more
                #    consistent results, thus we leave for now


    def _update_step_sizes(self):
        """
        Calculate new set of step sizes based on current ones. These
        will be centered aroud the step size where the current minimal
        deviation between two step sizes occurred.
        """
        # Cut steps made around step size with best criterion value in half
        # compared to current steps (we take average step size in case
        # difference to left and right is unequal)
        current_best_step = self.step_sizes[self.min_dev_index]

        if self.abs_or_rel_step_size(current_best_step).value < 1e-8:
            logger.info('Step size became too small, no convergence can be reached.')
            # self.step_sizes = []
            # self.max_refine_numb = self.refine_numb
            self._step_size_too_small = True
        else:
            # Refine in same way that we do with start_step_size
            self.step_sizes = np.reshape(
                np.outer(
                    [current_best_step/10**i for i in range(4)],
                    [5, 1]
                ),
                -1
            )[1:]  # Indexing makes sure we do not start at 5*start_step_size

    
    def _iterate_through_step_sizes(self):
        """
        Calculate derivatives for current `self.step_sizes`, checking
        if values converge in the meantime.
        """
        # for i, step_size in enumerate(self.step_sizes[-1]):
        for i, step_size in enumerate(self.step_sizes):
            self.test_point(step_size)

            try:
                deriv_param = self.deriv_routine(step_size)
            except ValueError as err:
                err_msg = str(err)

                if 'Input domain error' in err_msg:
                    logger.info(
                        f'{step_size} is not a valid step size for a parameter'
                        f' value of {self.param_center_val}. '
                        'Skipping this step size.'
                    )

                    # Still have to append something to lists, otherwise
                    # indices become inconsistent with step_sizes
                    self._derivative_vals += [0.0]
                    self._deriv_norms += [np.inf]
                    self._convergence_vals += [np.inf]
                    continue
                else:
                    raise ValueError(err_msg)

            derivative_norm = norm(deriv_param, **self.inner_prod_kwargs)**2

            self._derivative_vals += [deriv_param]
            self._deriv_norms += [derivative_norm]

            self._calc_convergence_val()
            self._check_converged()

            if self.is_converged and self.break_upon_convergence:
                # -- Update best fit
                self.min_dev_index = i  # Then it can also be used to access step_sizes
                break

    def _calc_convergence_val(self):
        """
        Calculates the value of the criterion `self.convergence_check`
        for the current values in `self._derivative_vals`.
        """
        if len(self._derivative_vals) >= 2:
            match self.convergence_check:
                case 'diff_norm':
                    crit_val = norm(
                        self._derivative_vals[-1] - self._derivative_vals[-2],
                        **self.inner_prod_kwargs
                    ) / np.sqrt(self._deriv_norms[-1])
                case 'mismatch':
                    # Compute mismatch, using that we already know norms
                    crit_val = 1. - inner_product(
                        self._derivative_vals[-1],
                        self._derivative_vals[-2],
                        **self.inner_prod_kwargs
                    ) / np.sqrt(self._deriv_norms[-1] * self._deriv_norms[-2])
        else:
            crit_val = np.inf
        
        self._convergence_vals += [crit_val]
            
    
    # Idea: this is what we call and what actually returns the derivative
    # TODO: maybe we can create fancy __call__ logic? Where params_at_point are passed?
    # -> could make this optional argument in __init__ then? Nah, this
    # is not possible. 
    def __call__(self, new_point: Optional[dict[str, u.Quantity]] = None) -> FrequencySeries | TimeSeries:
        if new_point is not None:
            if isinstance(new_point, u.Quantity):
                self.point[self.param_to_vary] = new_point
            else:
                self.point[self.param_to_vary] = new_point*self.param_center_val.unit
        return self.deriv
    
    _param_bound_storage = param_bounds.copy()
    param_bounds = WaveformDerivativeNumdifftools.param_bounds

    # TODO: what other parameters are relevant in this regard?
    # Maybe spins?

    def test_point(self, step_size: float) -> None:
        """
        Check if `self.point` contains potentially tricky
        values, e.g. mass ratios close to 1. If yes, a subsequent
        adjustment takes place.

        Parameters
        ----------
        step_size : float
            Current step size that produced an 'Input domain error'.
        """
        step_size = self.abs_or_rel_step_size(step_size)
        # -- This is important, determines step size that is actually
        # -- used by the routine (also adds proper unit)

        default_bounds = (-np.inf, np.inf)
        lower_bound, upper_bound = self._param_bound_storage.get(
            self.param_to_vary, default_bounds)
        if self.param_to_vary == 'mass_ratio':
            # -- Depending on chosen convention, bounds might have to be corrected
            if self.param_center_val > 1:
                lower_bound, upper_bound = self._param_bound_storage.get(
                    self.param_to_vary, default_bounds)
        
        lower_violation = self._lower_point_checker(step_size, lower_bound)
        upper_violation = self._upper_point_checker(step_size, upper_bound)
        
        if lower_violation and upper_violation:
            # -- Step size simply too large, no need to change
            # -- deriv_routine here, we just wait for next iteration
            pass
        elif lower_violation and not upper_violation:
            self.deriv_formula = 'forward'
        elif not lower_violation and upper_violation:
            self.deriv_formula = 'backward'
    
    def _lower_point_checker(self, step_size: float, boundary: float) -> bool:
        # TODO: maybe use value of step size here?
        if self.deriv_formula == 'five_point':
            return ((self.param_center_val - 2.*step_size <= boundary)
                    or (self.param_center_val - step_size <= boundary))
        else:
            return self.param_center_val - step_size <= boundary

    def _upper_point_checker(self, step_size: float, boundary: float) -> bool:
        if self.deriv_formula == 'five_point':
            return ((self.param_center_val + 2.*step_size >= boundary)
                    or (self.param_center_val + step_size >= boundary))
        else:
            return self.param_center_val + step_size >= boundary

    @property
    def deriv_formula(self) -> str:
        """
        (Function) name of the derivative formula that is used.

        :type: `str`
        """
        return self._deriv_formula
    
    @deriv_formula.setter
    def deriv_formula(self, formula: str) -> None:
        # -- Check for valid formula, then set it
        # assert formula in self.__dict__, (
        #     f'Invalid formula name {formula} is given. Available options are '
        #     '`forward`, `backward`, `central`, `five_point` or any custom '
        #     'attribute that might be set by you.'
        # )
        # TODO: or rather make class attribute _allowed_deriv_routines
        # where we store these default ones? And people can inherit
        # from class and then add their own names + attribute to that

        # TODO: shit, actually does not work

        self._deriv_formula = formula

        if hasattr(self, '_deriv'):
            # -- Derivative that was calculated is not valid anymore
            del self._deriv
    
    def deriv_routine(self, *args, **kw_args):
        """Caller that allows access to currently set derivative formula."""
        # return self.__getattribute__(self.deriv_formula)(self, *args, **kw_args)
        # return self.__getattribute__(self.deriv_formula)(*args, **kw_args)
        # -- using __call__ would perhaps make more clear what happens
        # return self.__getattribute__(self.deriv_formula).__call__(self, *args, **kw_args)
        return self.__getattribute__(self.deriv_formula).__call__(*args, **kw_args)

    def abs_or_rel_step_size(self, step_size) -> u.Quantity:
        """
        Choose relative or absolute step size, based on
        `self.param_center_val` (the value of `self.param_to_vary` in
        `self.point`).
        """
        if np.log10(self.param_center_val.value) < 1:
            step_size = np.abs(u.Quantity(step_size,
                                          unit=self.param_center_val.unit))
        else:
            step_size = np.abs(u.Quantity(step_size * self.param_center_val,
                                          unit=self.param_center_val.unit))
        
        return step_size


    # TODO: check again if this implementation is really most efficient.
    # Something like "return (wf2 - wf1) / step_size" seems like nice option too

    def forward(self, step_size: float) -> FrequencySeries | TimeSeries:
        """
        Calculates the forward difference of `self.wf_generator` at
        `self.point` with respect to `self.param_to_vary` using the
        given `step_size`.
        """
        step_size = self.abs_or_rel_step_size(step_size)
        wf_p1 = self.wf_generator(self.point | {
            self.param_to_vary: self.param_center_val + step_size
        })

        deriv_series = wf_p1 - self.wf
        deriv_series /= step_size

        return deriv_series
    
    def backward(self, step_size: float) -> FrequencySeries | TimeSeries:
        """
        Calculates the backward difference of `self.wf_generator` at
        `self.point` with respect to `self.param_to_vary` using the
        given `step_size`.
        """
        step_size = self.abs_or_rel_step_size(step_size)
        wf_m1 = self.wf_generator(self.point | {
            self.param_to_vary: self.param_center_val - step_size
        })

        deriv_series = self.wf - wf_m1
        deriv_series /= step_size

        return deriv_series
    
    def central(self, step_size: float) -> FrequencySeries | TimeSeries:
        """
        Calculates the central difference of `self.wf_generator` at
        `self.point` with respect to `self.param_to_vary` using the
        given `step_size`.
        """
        step_size = self.abs_or_rel_step_size(step_size)
        param_vals = self.param_center_val + np.array([-1., 1.])*step_size

        waveforms = [
            self.wf_generator(
                self.point | {self.param_to_vary: param_val}
            ) for param_val in param_vals
        ]

        deriv_series = waveforms[1] - waveforms[0]
        deriv_series /= 2.*step_size

        return deriv_series
    
    def five_point(self, step_size: float) -> FrequencySeries | TimeSeries:
        """
        Calculates the five point stencil of `self.wf_generator` at
        `self.point` with respect to `self.param_to_vary` using the
        given `step_size`.
        """
        step_size = self.abs_or_rel_step_size(step_size)
        param_vals = self.param_center_val + np.array([-2., -1., 1., 2.])*step_size

        waveforms = [
            self.wf_generator(
                self.point | {self.param_to_vary: param_val}
            ) for param_val in param_vals
        ]

        deriv_series = (waveforms[0] - 8.*waveforms[1]
                        + 8.*waveforms[2] - waveforms[3])
        deriv_series /= 12.*step_size

        return deriv_series


    # -- Information related properties
    @property
    def deriv_info(self) -> dict[str, Any]:
        """
        Information about the calculated derivative, given as a
        dictionary. All keys from this dictionary are also accessible
        as a class attribute.
        """
        return self._deriv_info
    
    @deriv_info.setter
    def deriv_info(self, info: dict[str, Any]):
        for key, val in info.items():
            # -- Make each key from deriv_info available as attribute
            setattr(self, key, val)
        
        self._deriv_info = info
    
    def convergence_plot(self) -> mpl.axes.Axes:
        """
        Plot estimates for the different step sizes that have been
        calculated.

        Returns
        -------
        matplotlib.axes.Axes
            Matplotlib axis with the plot.

        Raises
        ------
        RuntimeError
            If no derivates have been calculated.
        """
        from ..plotting import latexparams
        # -- Note: importing here is nice because then, custom additions
        # -- will not cause an error

        if len(self._derivative_vals) == 0:
            raise RuntimeError('No derivative was calculated. '
                               'Cannot generate plot.')

        fig = plt.figure()
        ax = fig.subplots(nrows=2, sharex=True)

        for i, deriv_val in enumerate(self._derivative_vals):
            ax[0].plot(
                deriv_val.real,
                '--',
                label=f'{self.step_sizes[i]:.3e}'
            )
            ax[1].plot(deriv_val.imag, '--')

        fig.legend(
            title='Step Sizes',
            bbox_to_anchor=(0.96, 0.5),
            loc='center left'
        )
        
        fig.suptitle(f'Parameter: {latexparams.get(self.param_to_vary, self.param_to_vary)}')
        if isinstance(deriv_val, TimeSeries):
            ax[1].set_xlabel(rf'$t$ [{deriv_val.xindex.unit:latex}]')
        elif isinstance(deriv_val, FrequencySeries):
            ax[1].set_xlabel(rf'$f$ [{deriv_val.xindex.unit:latex}]')
        # -- else we do not know what xindex is, no label

        ax[0].set_ylabel('Derivative Re')
        ax[1].set_ylabel('Derivative Im')

        return ax
