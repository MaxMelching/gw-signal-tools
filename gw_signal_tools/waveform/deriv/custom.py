# -- Standard Lib Imports
from __future__ import annotations  # Needed for "if TYPE_CHECKING" block

from typing import Optional, Literal, NamedTuple, TYPE_CHECKING
# from functools import cached_property  # TODO: use for some stuff?

# -- Third Party Imports
import numpy as np
import astropy.units as u
import matplotlib.pyplot as plt
import matplotlib as mpl

if TYPE_CHECKING:
    from gwpy.frequencyseries import FrequencySeries
    from gwpy.timeseries import TimeSeries
    from numpy.typing import NDArray

# -- Local Package Imports
from .ana_derivs import ana_deriv_map
from .base import WaveformDerivativeBase
from ...logging import logger
from ..inner_product import norm, inner_product, param_bounds as _param_bounds
from ...types import FDWFGen


__doc__ = """Module for the ``WaveformDerivativeGWSignaltools`` class."""

__all__ = ('WaveformDerivativeGWSignaltools',)


class WaveformDerivativeGWSignaltools(WaveformDerivativeBase):
    r"""
    Calculate the derivative of an arbitrary waveform with respect to
    an arbitrary input parameter in frequency domain, using a selection
    of finite difference methods and a variable criterion to check the
    "quality" of approximation.

    Parameters
    ----------
    point : dict[str, ~astropy.units.Quantity]
        Point in parameter space at which the derivative is evaluated,
        encoded as key-value pairs representing parameter-value pairs.

        In principle, the keys can be arbitrary, only two requirements
        have to be fulfilled: (i) the dictionary must be accepted by
        :code:`wf_generator` since it is given as input to this function
        and (ii) :code:`param_to_vary` has to be accessible as a key
        (except one of the special cases mentioned in the description of
        :code:`params_to_vary` is true).
    param_to_vary : str
        Parameter with respect to which the derivative is taken. Must be
        a key in :code:`point` or one of :code:`'time'`,
        :code:`'phase'`.

        For time and phase shifts, analytical derivatives are applied.
        This is possible because they contribute only to a factor
        :math:`\exp(i \cdot phase - i \cdot 2 \pi \cdot f \cdot time)`
        in the waveform generated by `wf_generator`, i.e. they are
        global phase and time shifts.
        Beware that the polarization angle :code:`psi` might be
        degenerate with :code:`phase`, if you are using the complex
        strain combination :math:`h = h_+ \pm i \, h_{\times}`.

        The last analytical derivative is the one for the luminosity
        distance :math:`D_L`, which enters in waveforms only as an
        amplitude factor :math:`1/D_L`. Note that can only be done
        if the parameter recognized, i.e. if it is called `'distance'`.
    wf_generator : ~gw_signal_tools.types.FDWFGen
        Arbitrary function that is used for waveform generation. The
        required signature means that it has one non-optional argument,
        which is expected to accept the input provided in
        :code:`point`, while the output must be a ``~gwpy.
        frequencyseries.FrequencySeries`` (the standard output of
        LAL gwsignal generators) because it carries information about
        value, frequencies and units, which are all required for the
        calculations that are carried out.

        A convenient option is to use the method
        :code:`~gw_signal_tools.waveform.get_wf_generator`, which
        generates a suitable function from a few arguments.
    step_sizes : list[float], optional, default = None
        Step sizes used in the numerical differentiation. Based on the
        evaluation point, these are used as relative or absolute steps.
    start_step_size: float, optional, default = 1e-2
        Alternative way to control the relative step sizes. Determines
        the largest relative step size that is tried.
    convergence_check : Literal['diff_norm', 'mismatch'], optional, default = None
        Criterion used to asses stability of the result. Currently, two
        are available:

            * diff_norm: calculates the norm of the difference of two
              consecutive derivatives (using the function
              :code:`~gw_signal_tools.inner_product.norm`). This is
              compared to the norm of the most recent derivative and if
              their fraction is smaller than some threshold (specified
              in :code:`convergence_threshold`), the result is taken to
              be converged because the differences become negligible on
              the relevant scales (provided by the norm of the
              derivative).
            * mismatch: calculates the mismatch between consecutive
              derivatives (also using the function
              :code:`~gw_signal_tools.inner_product.norm`), which is
              defined as :math:`1-overlap`. Again, the result is taken
              to be converged if this mismatch falls under a certain
              threshold, provided by :code:`convergence_threshold`.

        For larger differences, they might produce different results,
        but their behaviour for small distances should be very similar
        because they coincide in the infinitesimal limit (they induce
        the same metric).
    convergence_threshold : float, optional, default = None
        Threshold that is used to decide if result is converged. This
        will be the case once the value of the criterion specified in
        :code:`convergence_check` is smaller than
        :code:`convergence_threshold` two iterations in a row.
    break_upon_convergence : bool, optional, default = True
        Whether to break upon the convergence described previously
        (difference smaller than given threshold two times in a row) or
        not. If not, results for all step sizes are calculated and the
        one with minimal convergence criterion value is selected.
    inner_prod_kwargs :
        All additional keyword arguments are passed to the inner product
        function during the corresponding calculations.

    Returns
    -------
    ~gwpy.frequencyseries.FrequencySeries or tuple[~gwpy.frequencyseries.FrequencySeries, dict[str, Any]]
        Derivative in frequency space with respect to
        :code:`param_to_vary`. If :code:`return_info = True`, also a
        dictionary with information about the result.

    Raises
    ------
    ValueError
        If an invalid value for convergence_check is provided.
    AssertionError
        If an invalid :code:`params_to_vary` is provided.

    See Also
    --------
    gw_signal_tools.inner_product.norm :
        Function used to create the involved inner products.

    Notes
    -----
    In principle, one can also pass a time domain generator as
    `wf_generator`, but then one might encounter errors due to signal
    lengths that change when waveforms for multiple parameter values are
    generated. In that case, the required operations are not possible.
    """

    def __init__(
        self,
        point: dict[str, u.Quantity],
        param_to_vary: str,
        wf_generator: FDWFGen,
        step_sizes: Optional[list[float] | NDArray[np.float64]] = None,
        start_step_size: Optional[float] = 1e-2,
        convergence_check: Optional[Literal['diff_norm', 'mismatch']] = None,
        convergence_threshold: Optional[float] = None,
        break_upon_convergence: bool = True,
        max_refine_numb: Optional[int] = 3,
        double_convergence: bool = True,  # Whether to demand double convergence or not
        deriv_formula: str = 'five_point',
        # return_info: bool = False,
        **inner_prod_kwargs,
    ) -> None:
        self.point = point
        self.param_to_vary = param_to_vary
        self.wf_generator = wf_generator
        self._param_bound_storage = _param_bounds.copy()
        self._ana_derivs = ana_deriv_map.copy()
        # super().__init__(
        #     point=point,
        #     param_to_vary=param_to_vary,
        #     wf_generator=wf_generator,
        # )

        if step_sizes is None:
            self.step_sizes = np.reshape(
                np.outer([start_step_size / 10**i for i in range(5)], [5, 1]), -1
            )[1:]
            # Indexing makes sure we do not start at 5*start_step_size
        else:
            if isinstance(step_sizes, float):
                step_sizes = [step_sizes]

            if len(step_sizes) == 1:
                self.max_refine_numb = max_refine_numb = 1

            self.step_sizes = step_sizes

        self.convergence_check = convergence_check
        self.convergence_threshold = convergence_threshold

        self.break_upon_convergence = break_upon_convergence
        self.double_convergence = double_convergence

        self.max_refine_numb = max_refine_numb

        self.deriv_formula = deriv_formula

        self.inner_prod_kwargs = inner_prod_kwargs
        self.inner_prod_kwargs['return_opt_info'] = False
        # Ensure float output of inner_product, even if optimization on

    # -- Properties that are set based on input
    @property
    def point(self) -> dict[str, u.Quantity]:
        """
        Point in parameter space at which waveform is differentiated,
        encoded as key-value pairs representing parameter-value pairs.

        :type: `dict[str, ~astropy.units.Quantity]`
        """
        return self._point

    @point.setter
    def point(self, point: dict[str, u.Quantity]) -> None:
        self._point = point
        try:
            self.wf = self.wf_generator(self.point)
        except AttributeError:
            # Class has just been initialized, no wf_generator yet
            pass

    @property
    def param_to_vary(self) -> str:
        """
        Parameter that derivative is taken with respect to.

        :type: `str`
        """
        return self._param_to_vary

    @param_to_vary.setter
    def param_to_vary(self, param: str):
        if param != 'time' and param != 'phase':
            # TODO: could also add distance here. Has analytical
            # derivative too, so strictly speaking it is not required
            # to be in point
            assert param in self.point

        self._param_to_vary = param

    @property
    def wf_generator(self) -> FDWFGen:
        """
        Generator for waveform model that is differentiated.

        :type: `~gw_signal_tools.types.FDWFGen`
        """
        return self._wf_generator

    @wf_generator.setter
    def wf_generator(self, generator: FDWFGen) -> None:
        self._wf_generator = generator
        self.wf = generator(self.point)

    # @property
    # def step_size(self):
    #     return self._step_size
    # @property
    # def step_sizes(self):
    #     return self._step_size_collection[-1]

    # @step_sizes.setter
    # def step_sizes(self, steps):
    #     # -- Make sure _step_size_collection is already defined
    #     try:
    #         self._step_size_collection
    #     except AttributeError:
    #         self._step_size_collection = []

    #     self._step_size_collection += steps
    #     # TODO: do we have to make sure it is list that we append here?

    @property
    def step_sizes(self) -> list[float] | NDArray[np.float64]:
        return self._step_sizes

    @step_sizes.setter
    def step_sizes(self, step_sizes: list[float] | NDArray[np.float64]):
        self._step_sizes = step_sizes

    @property
    def convergence_check(self) -> str:
        return self._convergence_check

    @convergence_check.setter
    def convergence_check(self, convergence_check: Optional[str]) -> None:
        if convergence_check is None:
            convergence_check = 'diff_norm'
        else:
            if convergence_check not in ['mismatch', 'diff_norm']:
                raise ValueError('Invalid value for `convergence_check`.')

        self._convergence_check = convergence_check

    @property
    def convergence_threshold(self) -> float:
        return self._convergence_threshold

    @convergence_threshold.setter
    def convergence_threshold(self, convergence_threshold: Optional[float]) -> None:
        if convergence_threshold is None:
            if self.convergence_check == 'diff_norm':
                convergence_threshold = 0.001
            elif self.convergence_check == 'mismatch':
                convergence_threshold = 0.001

        self._convergence_threshold = convergence_threshold

    @property
    def max_refine_numb(self) -> int:
        return self._max_refine_numb

    @max_refine_numb.setter
    def max_refine_numb(self, num: int) -> None:
        self._max_refine_numb = int(num)

    # -- Internally used properties
    @property
    def param_center_val(self):
        """
        Value of `self.param_to_vary` at which derivative is taken by
        default.

        :type: `~astropy.units.Quantity`
        """
        return self.point[self.param_to_vary]

    # TODO: is this required? -> yup, fairly frequently accessed

    # @property
    # def wf(self) -> FrequencySeries:
    # return self.wf_generator(self.point)
    # But then we would loose advantage of storing it, right?
    # -> even cached_property would not be useful
    # -> maybe out own custom cacher would help here. But not used for now
    @property
    def wf(self) -> FrequencySeries | TimeSeries:
        """
        The waveform produced by `self.wf_generator` at `self.point`.

        :type: `~gwpy.frequencyseries.FrequencySeries` | `~gwpy.timeseries.TimeSeries`
        """
        return self._wf

    @wf.setter
    def wf(self, wf: FrequencySeries | TimeSeries) -> None:
        self._wf = wf

    def __call__(
        self, x: Optional[float | u.Quantity] = None
    ) -> FrequencySeries | TimeSeries:
        if x is not None:
            x = x.to_value(self.param_center_val.unit)
            self.point[self.param_to_vary] = x * self.param_center_val.unit

        # -- Check if parameter has analytical derivative
        if self.param_to_vary in self._ana_derivs:
            deriv = self._ana_derivs[self.param_to_vary](self.point, self.wf_generator)
            derivative_norm = norm(deriv, **self.inner_prod_kwargs) ** 2
            self.info = self.DerivInfo(
                is_exact_deriv=True, norm_squared=derivative_norm
            )
            return deriv

        # -- Test for valid point
        # -- -> we do not do that for analytical derivatives, error for
        # --    invalid point will come from calling (or it might not;
        # --    but in that case, we should also not raise errors here).
        self._current_step_size = 0.0
        self.test_point(self.point)

        self.is_converged = False
        self.refine_numb = 0

        for self.refine_numb in range(self.max_refine_numb):
            # -- Initialize value storage
            self._derivative_vals: list[FrequencySeries | TimeSeries] = []
            self._deriv_norms: list[u.Quantity] = []
            self._convergence_vals: list[u.Quantity] = []
            # TODO: then maybe we should reset the step sizes as well?

            self._iterate_through_step_sizes()

            # Check if step sizes shall be refined. This is be done if no breaking
            # upon convergence is wanted or if no convergence was reached yet
            if not self.break_upon_convergence or not self.is_converged:
                # TODO: remove break_upon_convergence and just handle that via convergence_threshold?
                # I.e. set to 0.0 if no breaking wanted

                if np.all(np.equal(self._convergence_vals, np.inf)):
                    # Only invalid step sizes for this parameter, we
                    # have to decrease further
                    self.min_dev_index = len(self.step_sizes) - 1
                else:
                    self.min_dev_index = np.nanargmin(self._convergence_vals)  # type: ignore
                # Explanation of ignore: it seems like a signedinteger is returned
                # by nanargmin, violates static checking for int. Note that we do
                # use nan-version here just in case something goes wrong in norm or
                # so, making it zero (should not happen, though)

                if self.refine_numb < (self.max_refine_numb - 1):
                    self._update_step_sizes()

                    try:
                        if self._step_size_too_small:
                            break
                    except AttributeError:
                        pass
            else:
                break

        if not self.is_converged:
            # logger.info(
            #     'Calculations using the selected step sizes did not converge '
            #     f'for parameter `{self.param_to_vary}` using convergence check method '
            #     f'`{self.convergence_check}`, even after {self.max_refine_numb} refinements of '
            #     'step sizes. The minimal value of the criterion was '
            #     f'{self._convergence_vals[self.min_dev_index]}, ' + ((f'which is above the '
            #     f'selected threshold of {self.convergence_threshold}. ')
            #     if self._convergence_vals[self.min_dev_index] > self.convergence_threshold else (
            #     f'which is below the selected threshold of {self.convergence_threshold}'
            #     ', but the previous and following value were not.')) +
            #     'If you are not satisfied with the result (for an eye test, you '
            #     'can plot the `convergence_plot` value returned in case '
            #     '`return_info=True`), consider changing the initial step sizes.'
            # )

            logger.info('NO CONVERGENCE')

            # TODO: rewrite this text. Also make sure that self._convergence_vals etc are all defined
            # -> maybe make them properties and there we check this, set them
            #    otherwise?

        self.info = {
            'norm_squared': self._deriv_norms[self.min_dev_index],
            'final_step_size': self.step_sizes[self.min_dev_index],
            'final_convergence_val': self._convergence_vals[self.min_dev_index],
            'number_of_refinements': self.refine_numb,
            'final_set_of_step_sizes': self.step_sizes,
            'deriv_formula': self.deriv_formula,
        }

        self._deriv = self._derivative_vals[self.min_dev_index]
        return self._deriv

    __call__.__doc__ = WaveformDerivativeBase.__call__.__doc__

    def _check_converged(self):
        """
        Check if derivative has converged, according to the selected
        convergence check (either two or three consecutive values of
        convergence checker must be below `self.convergence_threshold`).
        """
        if self.double_convergence:
            if (
                len(self._convergence_vals) >= 2
                and (self._convergence_vals[-1] <= self.convergence_threshold)
                and (self._convergence_vals[-2] <= self.convergence_threshold)
            ):
                # Double checking is more robust
                self.is_converged = True  # Remains true, is never set to False again
        else:
            if self._convergence_vals[-1] <= self.convergence_threshold:
                self.is_converged = True  # Remains true, is never set to False again
                # We use five-point stencil, which converges fast, so
                # that it is justified to interpret two consecutive
                # results being very similar as convergence
                # -> testing revealed that double_convergence leads to more
                #    consistent results, thus we leave for now

    def _update_step_sizes(self):
        """
        Calculate new set of step sizes based on current ones. These
        will be centered aroud the step size where the current minimal
        deviation between two step sizes occurred.
        """
        # Cut steps made around step size with best criterion value in half
        # compared to current steps (we take average step size in case
        # difference to left and right is unequal)
        current_best_step = self.step_sizes[self.min_dev_index]

        if self.abs_or_rel_step_size(current_best_step).value < 1e-8:
            logger.info('Step size became too small, no convergence can be reached.')
            # self.step_sizes = []
            # self.max_refine_numb = self.refine_numb
            self._step_size_too_small = True
        else:
            # Refine in same way that we do with start_step_size
            self.step_sizes = np.reshape(
                np.outer([current_best_step / 10**i for i in range(4)], [5, 1]), -1
            )[1:]  # Indexing makes sure we do not start at 5*start_step_size

    def _iterate_through_step_sizes(self):
        """
        Calculate derivatives for current `self.step_sizes`, checking
        if values converge in the meantime.
        """
        # for i, step_size in enumerate(self.step_sizes[-1]):
        for i, step_size in enumerate(self.step_sizes):
            self._current_step_size = step_size
            self.test_point(self.point)

            try:
                deriv_param = self.deriv_routine(step_size)
            except ValueError as err:
                err_msg = str(err)

                if 'Input domain error' in err_msg:
                    logger.info(
                        f'{step_size} is not a valid step size for a parameter'
                        f' value of {self.param_center_val}. '
                        'Skipping this step size.'
                    )

                    # Still have to append something to lists, otherwise
                    # indices become inconsistent with step_sizes
                    self._derivative_vals += [0.0]
                    self._deriv_norms += [np.inf]
                    self._convergence_vals += [np.inf]
                    continue
                else:
                    raise err  # raise from err?

            derivative_norm = norm(deriv_param, **self.inner_prod_kwargs) ** 2

            self._derivative_vals += [deriv_param]
            self._deriv_norms += [derivative_norm]

            self._calc_convergence_val()
            self._check_converged()

            if self.is_converged and self.break_upon_convergence:
                # -- Update best fit
                self.min_dev_index = i  # Then it can also be used to access step_sizes
                break

    def _calc_convergence_val(self):
        """
        Calculates the value of the criterion `self.convergence_check`
        for the current values in `self._derivative_vals`.
        """
        if len(self._derivative_vals) >= 2:
            if self.convergence_check == 'diff_norm':
                crit_val = norm(
                    self._derivative_vals[-1] - self._derivative_vals[-2],
                    **self.inner_prod_kwargs,
                ) / np.sqrt(self._deriv_norms[-1])
            elif self.convergence_check == 'mismatch':
                # Compute mismatch, using that we already know norms
                crit_val = 1.0 - inner_product(
                    self._derivative_vals[-1],
                    self._derivative_vals[-2],
                    **self.inner_prod_kwargs,
                ) / np.sqrt(self._deriv_norms[-1] * self._deriv_norms[-2])
        else:
            crit_val = np.inf

        self._convergence_vals += [crit_val]

    # TODO: what other parameters are relevant in this regard?
    # Maybe spins?

    def test_point(
        self, point: dict[str, u.Quantity], step: Optional[float] = None
    ) -> None:
        """
        Check if `point` contains potentially tricky values, e.g.
        mass ratios close to 1. If yes, a subsequent adjustment of step
        sizes etc may be performed.

        Parameters
        ----------
        step : float
            Current step size to be checked.
        """
        if step is None:
            step = self.abs_or_rel_step_size(self._current_step_size)
        # -- This is important, determines step size that is actually
        # -- used by the routine (also adds proper unit)

        default_bounds = (-np.inf, np.inf)
        lower_bound, upper_bound = self.param_bounds.get(
            self.param_to_vary, default_bounds
        )
        if (self.param_to_vary == 'mass_ratio') and (self.param_center_val > 1):
            # -- In this convention, bounds have to be corrected
            lower_bound, upper_bound = self.param_bounds.get(
                'inverse_mass_ratio', default_bounds
            )

        lower_violation = self._lower_point_checker(point, step, lower_bound)
        upper_violation = self._upper_point_checker(point, step, upper_bound)

        if lower_violation and upper_violation:
            # -- Step size simply too large, no need to change
            # -- deriv_routine here, we just wait for next iteration
            pass
        elif lower_violation and not upper_violation:
            self.deriv_formula = 'forward'
        elif not lower_violation and upper_violation:
            self.deriv_formula = 'backward'

    def _lower_point_checker(
        self, point: dict[str, u.Quantity], step_size: float, boundary: float
    ) -> bool:
        # TODO: maybe use value of step size here?
        if self.deriv_formula == 'five_point':
            return (point[self.param_to_vary] - 2.0 * step_size <= boundary) or (
                point[self.param_to_vary] - step_size <= boundary
            )
        else:
            return point[self.param_to_vary] - step_size <= boundary

    def _upper_point_checker(
        self, point: dict[str, u.Quantity], step_size: float, boundary: float
    ) -> bool:
        if self.deriv_formula == 'five_point':
            return (point[self.param_to_vary] + 2.0 * step_size >= boundary) or (
                point[self.param_to_vary] + step_size >= boundary
            )
        else:
            return point[self.param_to_vary] + step_size >= boundary

    @property
    def deriv_formula(self) -> str:
        """
        (Function) name of the derivative formula that is used.

        :type: `str`
        """
        return self._deriv_formula

    @deriv_formula.setter
    def deriv_formula(self, formula: str) -> None:
        # -- Check for valid formula, then set it
        # assert formula in self.__dict__, (
        #     f'Invalid formula name {formula} is given. Available options are '
        #     '`forward`, `backward`, `central`, `five_point` or any custom '
        #     'attribute that might be set by you.'
        # )
        # TODO: or rather make class attribute _allowed_deriv_routines
        # where we store these default ones? And people can inherit
        # from class and then add their own names + attribute to that

        # TODO: shit, actually does not work

        self._deriv_formula = formula

    def deriv_routine(self, *args, **kw_args):
        """Caller that allows access to currently set derivative formula."""
        # return self.__getattribute__(self.deriv_formula)(self, *args, **kw_args)
        # return self.__getattribute__(self.deriv_formula)(*args, **kw_args)
        # -- using __call__ would perhaps make more clear what happens
        # return self.__getattribute__(self.deriv_formula).__call__(self, *args, **kw_args)
        return self.__getattribute__(self.deriv_formula).__call__(*args, **kw_args)

    def abs_or_rel_step_size(self, step_size) -> u.Quantity:
        """
        Choose relative or absolute step size, based on
        `self.param_center_val` (the value of `self.param_to_vary` in
        `self.point`).
        """
        if np.log10(self.param_center_val.value) < 1:
            step_size = np.abs(u.Quantity(step_size, unit=self.param_center_val.unit))
        else:
            step_size = np.abs(
                u.Quantity(
                    step_size * self.param_center_val, unit=self.param_center_val.unit
                )
            )

        return step_size

    # TODO: check again if this implementation is really most efficient.
    # Something like "return (wf2 - wf1) / step_size" seems like nice option too

    def forward(self, step_size: float) -> FrequencySeries | TimeSeries:
        """
        Calculates the forward difference of `self.wf_generator` at
        `self.point` with respect to `self.param_to_vary` using the
        given `step_size`.
        """
        step_size = self.abs_or_rel_step_size(step_size)
        wf_p1 = self.wf_generator(
            self.point | {self.param_to_vary: self.param_center_val + step_size}
        )

        deriv_series = wf_p1 - self.wf
        deriv_series /= step_size

        return deriv_series

    def backward(self, step_size: float) -> FrequencySeries | TimeSeries:
        """
        Calculates the backward difference of `self.wf_generator` at
        `self.point` with respect to `self.param_to_vary` using the
        given `step_size`.
        """
        step_size = self.abs_or_rel_step_size(step_size)
        wf_m1 = self.wf_generator(
            self.point | {self.param_to_vary: self.param_center_val - step_size}
        )

        deriv_series = self.wf - wf_m1
        deriv_series /= step_size

        return deriv_series

    def central(self, step_size: float) -> FrequencySeries | TimeSeries:
        """
        Calculates the central difference of `self.wf_generator` at
        `self.point` with respect to `self.param_to_vary` using the
        given `step_size`.
        """
        step_size = self.abs_or_rel_step_size(step_size)
        param_vals = self.param_center_val + np.array([-1.0, 1.0]) * step_size

        waveforms = [
            self.wf_generator(self.point | {self.param_to_vary: param_val})
            for param_val in param_vals
        ]

        deriv_series = waveforms[1] - waveforms[0]
        deriv_series /= 2.0 * step_size

        return deriv_series

    def five_point(self, step_size: float) -> FrequencySeries | TimeSeries:
        """
        Calculates the five point stencil of `self.wf_generator` at
        `self.point` with respect to `self.param_to_vary` using the
        given `step_size`.
        """
        step_size = self.abs_or_rel_step_size(step_size)
        param_vals = (
            self.param_center_val + np.array([-2.0, -1.0, 1.0, 2.0]) * step_size
        )

        waveforms = [
            self.wf_generator(self.point | {self.param_to_vary: param_val})
            for param_val in param_vals
        ]

        deriv_series = (
            waveforms[0] - 8.0 * waveforms[1] + 8.0 * waveforms[2] - waveforms[3]
        )
        deriv_series /= 12.0 * step_size

        return deriv_series

    # -- Information related properties
    class DerivInfo(NamedTuple):
        """Derivative information for ``WaveformDerivativeGWSignaltools``."""

        deriv_formula: str | None = None
        """Derivative formula that was used."""
        final_convergence_val: float | None = None
        """Final value of the convergence criterion."""
        final_set_of_step_sizes: list[float] | NDArray[np.float64] | None = None
        """Final set of step sizes that were used for the derivative."""
        final_step_size: float | None = None
        """Final step size used for the derivative."""
        is_exact_deriv: bool = False
        """Whether derivative is exact (analytical) or not."""
        norm_squared: float = np.nan
        """Squared norm of the derivative."""
        number_of_refinements: int | None = None
        """Number of step size refinements that were performed."""

    def convergence_plot(self) -> mpl.axes.Axes:
        """
        Plot estimates for the different step sizes that have been
        calculated.

        Returns
        -------
        matplotlib.axes.Axes
            Matplotlib axis with the plot.

        Raises
        ------
        RuntimeError
            If no derivates have been calculated.
        """
        from ...plotting import latexparams

        # -- Note: importing here is nice because then, custom additions
        # -- will not cause an error

        if len(self._derivative_vals) == 0:
            raise RuntimeError('No derivative was calculated. Cannot generate plot.')

        fig = plt.figure()
        ax = fig.subplots(nrows=2, sharex=True)

        for i, deriv_val in enumerate(self._derivative_vals):
            ax[0].plot(deriv_val.real, '--', label=f'{self.step_sizes[i]:.3e}')
            ax[1].plot(deriv_val.imag, '--')

        fig.legend(title='Step Sizes', bbox_to_anchor=(0.96, 0.5), loc='center left')

        fig.suptitle(
            f'Parameter: {latexparams.get(self.param_to_vary, self.param_to_vary)}'
        )
        # if isinstance(deriv_val, TimeSeries):
        #     ax[1].set_xlabel(rf'$t$ [{deriv_val.xindex.unit:latex}]')
        # elif isinstance(deriv_val, FrequencySeries):
        #     ax[1].set_xlabel(rf'$f$ [{deriv_val.xindex.unit:latex}]')
        # # -- else we do not know what xindex is, no label

        ax[0].set_ylabel('Derivative Re')
        ax[1].set_ylabel('Derivative Im')

        return ax
