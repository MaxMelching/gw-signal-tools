# -- Standard Lib Imports
from typing import Callable, Any

# -- Third Party Imports
import numdifftools as nd
import astropy.units as u
import numpy as np

# -- Local Package Imports
from ..inner_product import param_bounds
from .deriv_base import WaveformDerivativeBase
from ...types import WFGen


__doc__ = """Module for ``WaveformDerivativeNumdifftools`` class."""

__all__ = ('WaveformDerivativeNumdifftools',)


class WaveformDerivativeNumdifftools(nd.Derivative, WaveformDerivativeBase):
    r"""
    Wrapper around :code:`numdifftools.Derivative` class specifically
    for waveform callers from new LAL interface.

    Parameters
    ----------
    point : dict[str, ~astropy.units.Quantity]
        Point in parameter space at which the derivative is evaluated,
        encoded as key-value pairs representing parameter-value pairs.

        In principle, the keys can be arbitrary, only two requirements
        have to be fulfilled: (i) the dictionary must be accepted by
        :code:`wf_generator` since it is given as input to this function
        and (ii) :code:`param_to_vary` has to be accessible as a key
        (except one of the special cases mentioned in the description of
        :code:`params_to_vary` is true).
    param_to_vary : str
        Parameter with respect to which the derivative is taken. Must be
        a key in :code:`point` or one of :code:`'time'`,
        :code:`'phase'`.

        For time and phase shifts, analytical derivatives are applied.
        This is possible because they contribute only to a factor
        :math:`\exp(i \cdot phase - i \cdot 2 \pi \cdot f \cdot time)`
        in the waveform generated by `wf_generator`, i.e. they are
        global phase and time shifts.
        Beware that the polarization angle :code:`psi` might be
        degenerate with :code:`phase`, if you are using the complex
        strain combination :math:`h = h_+ \pm i \, h_{\times}`.

        The last analytical derivative is the one for the luminosity
        distance :math:`D_L`, which enters in waveforms only as an
        amplitude factor :math:`1/D_L`. Note that can only be done
        if the parameter recognized, i.e. if it is called `'distance'`.
    wf_generator : ~gw_signal_tools.types.FDWFGen
        Arbitrary function that is used for waveform generation. The
        required signature means that it has one non-optional argument,
        which is expected to accept the input provided in
        :code:`point`, while the output must be a ``~gwpy.
        frequencyseries.FrequencySeries`` (the standard output of
        LAL gwsignal generators) because it carries information about
        value, frequencies and units, which are all required for the
        calculations that are carried out.

        A convenient option is to use the method
        :code:`~gw_signal_tools.waveform.get_wf_generator`, which
        generates a suitable function from a few arguments.
    args, kwds :
        All other positional and keyword arguments are passed on as such
        to the :code:`numdifftools.Derivative` class.

    Notes
    -----
    For a time domain model, you as a user have to make sure that output
    always has the same size (and is defined on same times)!!! Otherwise
    the required operations will not work.

    Custom attributes defined by us are :code:`.deriv` and
    :code:`.deriv_info`, which have analogous names to the ones defined
    in :code:`gw_signal_tools.WaveformDerivativeGWSignaltools`.


    Arbitrary function that is used for waveform generation. The
    required signature means that it has one non-optional argument,
    which is expected to accept the input provided in
    :code:`self.point`.
    """

    def __init__(
        self,
        point: dict[str, u.Quantity],
        param_to_vary: str,
        wf_generator: WFGen,
        *args,
        **kwds,
    ) -> None:
        # -- Check if parameter has analytical derivative
        if param_to_vary == 'time':
            wf = wf_generator(point)
            deriv = wf * (-1.0j * 2.0 * np.pi * wf.frequencies)

            self.deriv_info = {'description': 'This derivative is exact.'}
            self._ana_deriv = deriv
            return None
        elif param_to_vary == 'phase':
            wf = wf_generator(point)
            deriv = wf * 1.0j / u.rad

            self.deriv_info = {'description': 'This derivative is exact.'}
            self._ana_deriv = deriv
            return None

        self._param_center_val = point[param_to_vary]
        param_unit = self.param_center_val.unit
        self._wf_generator = wf_generator
        self._point = point
        self._param_to_vary = param_to_vary

        if 'base_step' not in kwds:
            # -- Set maximum step size. To verify, one can print e.g.
            # -- the steps in Derivative._derivative_nonzero_order
            kwds['base_step'] = self._default_base_step
        elif isinstance(_base_step := kwds['base_step'], u.Quantity):
            kwds['base_step'] = _base_step.to_value(self.param_center_val.unit)

        def fun(x):
            return self.wf_generator(point | {param_to_vary: x * param_unit})

        # -- Next line stores this function in self.fun

        super().__init__(fun, *args, **kwds)

        WaveformDerivativeBase.__init__(self)

    def __call__(self, x=None) -> Any:
        """
        Get derivative at :code:`x`.

        Parameters
        ----------
        x : Any, optional, default = None
            Parameter value at which the derivative is calculated. By
            default, the corresponding value from :code:`self.point`
            are chosen.

        Returns
        -------
        Derivative, put into whatever type :code:`self.wf_generator`
        has. This should, in principle, be either a GWpy
        :code:``FrequencySeries`` or a GWpy :code:``TimeSeries`` (in
        accordance with standard LAL output types), but this function
        only rely on GWPy :code:``Series`` properties being defined and
        thus the output could also be of this type.

        Notes
        -----
        Information gathered during calculation is stored in the
        :code:`self.deriv_info` property.
        """
        # -- Check if analytical derivative has already been calculated
        if hasattr(self, '_ana_deriv'):
            return self._ana_deriv

        # -- Check selected arguments
        if x is None:
            x = self.param_center_val.value
        elif isinstance(x, u.Quantity):
            x = x.to_value(self.param_center_val.unit)

        # -- Check if parameter has analytical derivative (cannot be in
        # -- previous check because dependent on point)
        if self.param_to_vary == 'distance':
            dist_val = x * self.param_center_val.unit
            wf = self.wf_generator(self.point | {'distance': dist_val})
            deriv = (-1.0 / dist_val) * wf

            self.deriv_info = {'description': 'This derivative is exact.'}
            return deriv

        # -- Test for valid point, potentially adjusting method
        self.test_base_step()

        self.full_output = True
        deriv, info = super().__call__(x)
        self.deriv_info = info._asdict()

        param_unit = self.param_center_val.unit

        wf = self.fun(x)
        # Idea: use type that wf_generator returns to have flexibility
        # with respect to whether TimeSeries/FrequencySeries is passed
        out = type(wf)(data=deriv, xindex=wf.xindex, unit=wf.unit / param_unit)

        self.error_estimate = type(wf)(
            data=info.error_estimate, xindex=wf.xindex, unit=wf.unit / param_unit
        )
        self.deriv_info['error_estimate'] = self.error_estimate

        return out

    @property
    def _default_base_step(self) -> float:
        """Largest step size used by default."""
        _par_val = self.param_center_val.value
        return 1e-2 * (_par_val if _par_val != 0.0 else 1.0)
        # -- If case needed to avoid zero step size

        # if _par_val == 0. or np.log10(_par_val) < 1:
        #     return 1e-2
        # else:
        #     return 1e-2*_par_val

    _param_bound_storage = param_bounds.copy()
    param_bounds = WaveformDerivativeBase.param_bounds

    def test_base_step(self) -> None:
        """
        Check if `self.point` contains potentially tricky values, e.g.
        mass ratios close to 1. If yes, a subsequent adjustment takes
        place.
        """
        default_bounds = (-np.inf, np.inf)
        lower_bound, upper_bound = self._param_bound_storage.get(
            self.param_to_vary, default_bounds
        )
        if self.param_to_vary == 'mass_ratio':
            # -- Depending on chosen convention, bounds might have to be corrected
            if self.param_center_val > 1:
                lower_bound, upper_bound = self._param_bound_storage.get(
                    self.param_to_vary, default_bounds
                )

        _base_step = self.step.base_step
        _par_val = self.param_center_val.value
        lower_violation = _par_val - _base_step <= lower_bound
        upper_violation = _par_val + _base_step >= upper_bound

        # -- Check if base_step needs change
        if lower_violation and upper_violation:
            self.step.base_step = min(_base_step / 2.0, self._default_base_step)
        elif lower_violation and not upper_violation:
            # -- Can only happen if method is not forward yet
            self.method = 'forward'
            self.step.base_step = min(_base_step / 2.0, self._default_base_step)
        elif not lower_violation and upper_violation:
            # -- Can only happen if method is not backward yet
            self.method = 'backward'
            self.step.base_step = min(_base_step / 2.0, self._default_base_step)


import numdifftools

if numdifftools.__version__ <= '0.9.41':  # pragma: no cover
    # -- Now: fix bug in nd.Derivative, complex input throws error. This is
    # -- due to numpy changes that were not (yet?) addressed by numdifftools
    from numdifftools.limits import _Limit
    import numpy as np
    import warnings


    def _add_error_to_outliers_fixed(der, trim_fact=10):  # pragma: no cover
        """
        discard any estimate that differs wildly from the
        median of all estimates. A factor of 10 to 1 in either
        direction is probably wild enough here. The actual
        trimming factor is defined as a parameter.
        """
        if np.iscomplexobj(der):
            return np.sqrt(
                _add_error_to_outliers_fixed(np.real(der), trim_fact) ** 2
                + _add_error_to_outliers_fixed(np.imag(der), trim_fact) ** 2
            )

        try:
            if np.any(np.isnan(der)):
                p25, median, p75 = np.nanpercentile(der, [25, 50, 75], axis=0)
            else:
                p25, median, p75 = np.percentile(der, [25, 50, 75], axis=0)

            iqr = np.abs(p75 - p25)
        except ValueError as msg:
            warnings.warn(str(msg))
            return 0 * der

        a_median = np.abs(median)
        outliers = (
            (abs(der) < (a_median / trim_fact)) + (abs(der) > (a_median * trim_fact))
        ) * (a_median > 1e-8) + ((der < p25 - 1.5 * iqr) + (p75 + 1.5 * iqr < der))
        errors = outliers * np.abs(der - median)
        return errors


    _Limit._add_error_to_outliers = staticmethod(_add_error_to_outliers_fixed)
