# -- Standard Lib Imports
from __future__ import annotations  # Needed for "if TYPE_CHECKING" block
from typing import TYPE_CHECKING, Optional, NamedTuple, Any

# -- Third Party Imports
import numdifftools as nd
import astropy.units as u
import numpy as np

if TYPE_CHECKING:
    from gwpy.types import Series
    from numpy.typing import NDArray

# -- Local Package Imports
from .base import WaveformDerivativeBase
from ...logging import logger
from ...types import WFGen


__doc__ = """Module for ``WaveformDerivativeNumdifftools`` class."""

__all__ = ('WaveformDerivativeNumdifftools',)


class WaveformDerivativeNumdifftools(WaveformDerivativeBase):
    r"""
    Wrapper around :code:`~numdifftools.Derivative` class specifically
    for waveform callers from the LAL waveforms interface `gwsignal`.

    Parameters
    ----------
    point : dict[str, ~astropy.units.Quantity]
        Point in parameter space at which the derivative is evaluated,
        encoded as key-value pairs representing parameter-value pairs.

        In principle, the keys can be arbitrary, only two requirements
        have to be fulfilled: (i) the dictionary must be accepted by
        :code:`wf_generator` since it is given as input to this function
        and (ii) :code:`param_to_vary` has to be accessible as a key
        (except one of the special cases mentioned in the description of
        :code:`params_to_vary` is true).
    param_to_vary : str
        Parameter with respect to which the derivative is taken. Must be
        a key in :code:`point` or one of :code:`'time'`,
        :code:`'phase'`.

        For time and phase shifts, analytical derivatives are applied.
        This is possible because they contribute only to a factor
        :math:`\exp(i \cdot phase - i \cdot 2 \pi \cdot f \cdot time)`
        in the waveform generated by `wf_generator`, i.e. they are
        global phase and time shifts.
        Beware that the polarization angle :code:`psi` might be
        degenerate with :code:`phase`, if you are using the complex
        strain combination :math:`h = h_+ \pm i \, h_{\times}`.

        The last analytical derivative is the one for the luminosity
        distance :math:`D_L`, which enters in waveforms only as an
        amplitude factor :math:`1/D_L`. Note that can only be done
        if the parameter recognized, i.e. if it is called `'distance'`.
    wf_generator : ~gw_signal_tools.types.FDWFGen
        Arbitrary function that is used for waveform generation. The
        required signature means that it has one non-optional argument,
        which is expected to accept the input provided in
        :code:`point`, while the output must be a ``~gwpy.
        frequencyseries.FrequencySeries`` (the standard output of
        LAL gwsignal generators) because it carries information about
        value, frequencies and units, which are all required for the
        calculations that are carried out.

        A convenient option is to use the method
        :code:`~gw_signal_tools.waveform.get_wf_generator`, which
        generates a suitable function from a few arguments.
    args, kwds :
        All other positional and keyword arguments are passed on as such
        to the :code:`~numdifftools.Derivative` class.

    Notes
    -----
    For a time domain model, you as a user have to make sure that output
    always has the same size (and is defined on same times)!!! Otherwise
    the required operations will not work.

    Custom attributes defined by us are :code:`.deriv` and
    :code:`.info`, which have analogous names to the ones defined
    in :code:`~gw_signal_tools.waveform.deriv.
    WaveformDerivativeGWSignaltools`.


    Arbitrary function that is used for waveform generation. The
    required signature means that it has one non-optional argument,
    which is expected to accept the input provided in
    :code:`self.point`.
    """

    def __init__(
        self,
        point: dict[str, u.Quantity],
        param_to_vary: str,
        wf_generator: WFGen,
        *args,
        **kwds,
    ) -> None:
        # -- Initialize WaveformDerivativeBase attributes
        super().__init__(
            point,
            param_to_vary,
            wf_generator,
        )

        # -- Prepare nd.Derivative initialization
        param_unit = self.param_center_val.unit

        if 'base_step' not in kwds:
            # -- Set maximum step size. To verify, one can print e.g.
            # -- the steps in Derivative._derivative_nonzero_order
            kwds['base_step'] = self._default_base_step
        elif isinstance(_base_step := kwds['base_step'], u.Quantity):
            kwds['base_step'] = _base_step.to_value(param_unit)

        def fun(x):
            return self.wf_generator(point | {param_to_vary: x * param_unit})

        # -- Initialize nd.Derivative attributes (among others, stores fun in self.fun)
        self._nd_deriv = nd.Derivative(fun, *args, **kwds)

    def __call__(self, x: Optional[float | u.Quantity] = None) -> Series:
        # -- Check selected arguments
        try:
            if x is None:
                x = self.param_center_val.value
            elif isinstance(x, u.Quantity):
                x = x.to_value(self.param_center_val.unit)

            # -- Test for valid point, potentially adjusting method
            self.test_point(
                self.point | {self.param_to_vary: x * self.param_center_val.unit}
            )
        except KeyError as e:
            if (
                str(e).strip("'") == self.param_to_vary
            ) and self.param_to_vary in self._ana_derivs:
                # -- Explanation: param_to_vary not in point, but has
                # -- analytical derivative, which might not require
                # -- the value in point (e.g., time, phase)
                x = None
                pass
            else:
                raise

        # -- Check if analytical derivative exists
        if self.param_to_vary in self._ana_derivs:
            eval_point = (
                self.point | {self.param_to_vary: x * self.param_center_val.unit}
                if x is not None
                else self.point
            )
            deriv = self._ana_derivs[self.param_to_vary](self, eval_point)
            wf = self.wf_generator(eval_point)
            self.info = self.DerivInfo(is_exact_deriv=True, f_value=wf)
            return deriv

        self.nd_deriv.full_output = True
        deriv, info = self.nd_deriv.__call__(x)
        self.info = self.DerivInfo(**info._asdict())

        param_unit = self.param_center_val.unit

        wf = self.nd_deriv.fun(x)
        # -- Idea: use type that wf_generator returns to have flexibility
        # -- with respect to whether TimeSeries/FrequencySeries is passed
        out = type(wf)(data=deriv, xindex=wf.xindex, unit=wf.unit / param_unit)

        self.info = self.info._replace(
            error_estimate=type(wf)(
                data=info.error_estimate, xindex=wf.xindex, unit=wf.unit / param_unit
            )
        )

        return out

    __call__.__doc__ = WaveformDerivativeBase.__call__.__doc__

    @property
    def _default_base_step(self) -> float:
        """Largest step size used by default."""
        _par_val = self.param_center_val.value
        return 1e-2 * (_par_val if _par_val != 0.0 else 1.0)
        # -- If case needed to avoid zero step size

        # if _par_val == 0. or np.log10(_par_val) < 1:
        #     return 1e-2
        # else:
        #     return 1e-2*_par_val

    def test_point(self, point: dict[str, u.Quantity]) -> None:
        """
        Check if `point` contains potentially tricky values, e.g.
        mass ratios close to 1. If yes, a subsequent adjustment of step
        sizes etc may be performed.
        """
        default_bounds = (-np.inf, np.inf)
        lower_bound, upper_bound = self.param_bounds.get(
            self.param_to_vary, default_bounds
        )
        if (self.param_to_vary == 'mass_ratio') and (self.param_center_val > 1):
            # -- In this convention, bounds have to be corrected
            lower_bound, upper_bound = self.param_bounds.get(
                'inverse_mass_ratio', default_bounds
            )

        _base_step = self.nd_deriv.step.base_step
        assert _base_step > 0.0, (
            'Reached step size of zero, cannot proceed.'
        )  # pragma: no cover

        _par_val = point[self.param_to_vary].value

        def violation(step):
            return (
                _par_val - step <= lower_bound,
                _par_val + step >= upper_bound,
            )

        lower_violation, upper_violation = violation(_base_step)

        if any((lower_violation, upper_violation)):
            logger.info(
                f"Parameter '{self.param_to_vary}' at value "
                f'{self.param_center_val} is close to bounds; adjusting step '
                'size/method. If this message appears repeatedly, consider '
                'adjusting parameter bounds or initial values.'
            )

        # TODO: try to get step size based on distance of _par_val to violated bounds?

        # -- Check if base_step needs change
        if lower_violation and upper_violation:
            self.nd_deriv.step.base_step = min(
                _base_step / 2.0, self._default_base_step
            )

            if any(violation(self.nd_deriv.step.base_step)):
                self.test_point(point)  # Recursive call until step size is small enough
        elif lower_violation and not upper_violation:
            # -- Can only happen if method is not forward yet
            self.nd_deriv.step.base_step = min(
                _base_step / 2.0, self._default_base_step
            )

            if violation(self.nd_deriv.step.base_step)[0]:
                # -- Too close to lower bound still, change method
                self.nd_deriv.method = 'forward'
        elif not lower_violation and upper_violation:
            # -- Can only happen if method is not backward yet
            self.nd_deriv.step.base_step = min(
                _base_step / 2.0, self._default_base_step
            )

            if violation(self.nd_deriv.step.base_step)[1]:
                # -- Too close to upper bound still, change method
                self.nd_deriv.method = 'backward'

    class DerivInfo(NamedTuple):
        """Namedtuple for derivative information."""

        error_estimate: Optional[NDArray | Series] = None
        """Estimated error in the derivative."""
        f_value: Optional[NDArray | u.Quantity] = None
        """Function value at the evaluation point."""
        final_step: Optional[NDArray] = None
        """Final step size used for the derivative."""
        index: Optional[NDArray] = None
        """Index of the best derivative estimate (used internally by numdifftools)."""
        is_exact_deriv: bool = False
        """Whether derivative is exact (analytical) or not."""

    @property
    def nd_deriv(self) -> nd.Derivative:
        """
        Wrapper that calculates derivative of waveform.

        :type: `~numdifftools.core.Derivative`
        """
        return self._nd_deriv

    def __getattr__(self, name: str) -> Any:
        try:
            return super().__getattr__(name)
        except AttributeError:
            if hasattr(self.nd_deriv, name):
                return getattr(self.nd_deriv, name)
            raise  # Re-raise the AttributeError


if nd.__version__ <= '0.9.41':  # pragma: no cover
    # -- Now: fix bug in nd.Derivative, complex input throws error. This is
    # -- due to numpy changes that were not (yet) addressed by numdifftools
    from numdifftools.limits import _Limit
    import warnings

    def _add_error_to_outliers_fixed(der, trim_fact=2):  # pragma: no cover
        """
        discard any estimate that differs wildly from the
        median of all estimates. A factor of 10 to 1 in either
        direction is probably wild enough here. The actual
        trimming factor is defined as a parameter.
        """
        if np.iscomplexobj(der):
            return np.sqrt(
                _add_error_to_outliers_fixed(np.real(der), trim_fact) ** 2
                + _add_error_to_outliers_fixed(np.imag(der), trim_fact) ** 2
            )

        try:
            if np.any(np.isnan(der)):
                p25, median, p75 = np.nanpercentile(der, [25, 50, 75], axis=0)
            else:
                p25, median, p75 = np.percentile(der, [25, 50, 75], axis=0)

            iqr = np.abs(p75 - p25)
        except ValueError as msg:
            warnings.warn(str(msg))
            return 0 * der

        a_median = np.abs(median)
        outliers = (
            (abs(der) < (a_median / trim_fact)) + (abs(der) > (a_median * trim_fact))
        ) * (a_median > 1e-8) + ((der < p25 - 1.5 * iqr) + (p75 + 1.5 * iqr < der))
        errors = outliers * np.abs(der - median)
        return errors

    _Limit._add_error_to_outliers = staticmethod(_add_error_to_outliers_fixed)
