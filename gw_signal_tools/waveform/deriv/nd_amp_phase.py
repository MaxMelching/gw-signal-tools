# -- Standard Lib Imports
from __future__ import annotations  # Needed for "if TYPE_CHECKING" block
from typing import Callable, TYPE_CHECKING, Optional, NamedTuple

# -- Third Party Imports
import numdifftools as nd
import astropy.units as u
import numpy as np

if TYPE_CHECKING:
    from gwpy.types import Series
    from numpy.typing import NDArray

# -- Local Package Imports
from .base import WaveformDerivativeBase
from .nd import WaveformDerivativeNumdifftools
from ...logging import logger
from ...types import WFGen


__doc__ = """Module for ``WaveformDerivativeAmplitudePhase`` class."""

__all__ = ('WaveformDerivativeAmplitudePhase',)


class WaveformDerivativeAmplitudePhase(WaveformDerivativeBase):
    r"""
    Similar in spirit to the `~gw_signal_tools.waveform.deriv.deriv_nd.WaveformDerivativeNumdifftools`
    class, in the sense that it is a wrapper around
    :code:`~numdifftools.Derivative` class specifically for waveform
    callers from the LAL waveforms interface `gwsignal`.

    However, it does the actual calculation in a different way that is
    based on the chain rule. More on that in the Notes section.

    Parameters
    ----------
    point : dict[str, ~astropy.units.Quantity]
        Point in parameter space at which the derivative is evaluated,
        encoded as key-value pairs representing parameter-value pairs.

        In principle, the keys can be arbitrary, only two requirements
        have to be fulfilled: (i) the dictionary must be accepted by
        :code:`wf_generator` since it is given as input to this function
        and (ii) :code:`param_to_vary` has to be accessible as a key
        (except one of the special cases mentioned in the description of
        :code:`params_to_vary` is true).
    param_to_vary : str
        Parameter with respect to which the derivative is taken. Must be
        a key in :code:`point` or one of :code:`'time'`,
        :code:`'phase'`.

        For time and phase shifts, analytical derivatives are applied.
        This is possible because they contribute only to a factor
        :math:`\exp(i \cdot phase - i \cdot 2 \pi \cdot f \cdot time)`
        in the waveform generated by `wf_generator`, i.e. they are
        global phase and time shifts.
        Beware that the polarization angle :code:`psi` might be
        degenerate with :code:`phase`, if you are using the complex
        strain combination :math:`h = h_+ \pm i \, h_{\times}`.

        The last analytical derivative is the one for the luminosity
        distance :math:`D_L`, which enters in waveforms only as an
        amplitude factor :math:`1/D_L`. Note that can only be done
        if the parameter recognized, i.e. if it is called `'distance'`.
    wf_generator : ~gw_signal_tools.types.FDWFGen
        Arbitrary function that is used for waveform generation. The
        required signature means that it has one non-optional argument,
        which is expected to accept the input provided in
        :code:`point`, while the output must be a ``~gwpy.
        frequencyseries.FrequencySeries`` (the standard output of
        LAL gwsignal generators) because it carries information about
        value, frequencies and units, which are all required for the
        calculations that are carried out.

        A convenient option is to use the method
        :code:`~gw_signal_tools.waveform.get_wf_generator`, which
        generates a suitable function from a few arguments.
    args, kwds :
        All other positional and keyword arguments are passed on as such
        to the :code:`~numdifftools.Derivative` class.

    Notes
    -----
    Just like :class:``WaveformDerivativeNumdifftools``, this class uses
    routines provided by the :code:`numdifftools` package. The major
    difference is that we express :math:`h = A \cdot e^{i \cdot \phi}`
    and then calculate the derivatives :math:`\partial_{\theta^\mu} A`,
    :math:`\partial_{\theta^\mu} \phi` (:math:`\theta^\mu` is some
    arbitrary parameter). This is sufficient as the chain rule yields
    :math:`\partial_{\theta^\mu} h = (\partial_{\theta^\mu} A + i \cdot
    \partial_{\theta^\mu} \phi) e^{i \cdot \phi}`.

    This behaves potentially better mathematically, but also introduces
    some changes from a code perspective compared to the other
    derivatives: there is no straightforward way to get something like
    an overall final step size from the ones for amplitude and phase.
    Thus, structure and attributes are very different for this class.
    """

    def __init__(
        self,
        point: dict[str, u.Quantity],
        param_to_vary: str,
        wf_generator: WFGen,
        *args,
        **kwds,
    ) -> None:
        # -- Initialize WaveformDerivativeBase attributes
        super().__init__(
            point,
            param_to_vary,
            wf_generator,
        )

        # if self.param_to_vary in self._ana_derivs:
        #     return None  # -- No need to initialize numdifftools derivative

        # -- Prepare nd.Derivative initialization
        param_unit = self.param_center_val.unit

        if 'base_step' not in kwds:
            kwds['base_step'] = self._default_base_step
        elif isinstance(_base_step := kwds['base_step'], u.Quantity):
            kwds['base_step'] = _base_step.to_value(param_unit)

        def fun(x):
            return self.wf_generator(point | {param_to_vary: x * param_unit})

        def abs_wrapper(x):
            return self.abs_fun(self.fun(x).value)

        def phase_wrapper(x):
            return self.phase_fun(self.fun(x).value)

        self.fun = fun  # Needed manually because we do not init nd.Derivative on self
        self._abs_deriv = nd.Derivative(abs_wrapper, *args, **kwds)
        self._phase_deriv = nd.Derivative(phase_wrapper, *args, **kwds)

    def __call__(self, x: Optional[float | u.Quantity] = None) -> Series:
        # -- Check if analytical derivative has already been calculated
        if x is None:
            x = self.param_center_val.value
        elif isinstance(x, u.Quantity):
            x = x.to_value(self.param_center_val.unit)

        # -- Test for valid point, potentially adjusting method
        self.test_point(
            self.point | {self.param_to_vary: x * self.param_center_val.unit}
        )

        # -- Check if analytical derivative exists
        if self.param_to_vary in self._ana_derivs:
            eval_point = self.point | {
                self.param_to_vary: x * self.param_center_val.unit
            }
            deriv = self._ana_derivs[self.param_to_vary](eval_point, self.wf_generator)
            wf = self.wf_generator(eval_point)
            self.info = self.DerivInfo(is_exact_deriv=True, f_value=wf)
            return deriv

        self.abs_deriv.full_output = True
        abs_deriv, abs_info = self.abs_deriv(x)

        self.phase_deriv.full_output = True
        phase_deriv, phase_info = self.phase_deriv(x)

        param_unit = self.param_center_val.unit

        wf = self.fun(x)

        ampl = self.abs_fun(wf)
        if isinstance(ampl, u.Quantity):
            ampl = ampl.value

        phase = self.phase_fun(wf)
        if isinstance(phase, u.Quantity):
            phase = phase.value

        deriv = (abs_deriv + 1.0j * ampl * phase_deriv) * np.exp(1j * phase)

        self.info = self.DerivInfo(
            is_exact_deriv=False,
            f_value=wf,
            abs=WaveformDerivativeNumdifftools.DerivInfo(
                **abs_info._replace(
                    error_estimate=type(wf)(
                        data=abs_info.error_estimate,
                        xindex=wf.xindex,
                        unit=wf.unit / param_unit,
                    )
                )._asdict()
            ),
            phase=WaveformDerivativeNumdifftools.DerivInfo(
                **phase_info._replace(
                    error_estimate=type(wf)(
                        data=phase_info.error_estimate,
                        xindex=wf.xindex,
                        unit=wf.unit / param_unit,
                    )
                )._asdict()
            ),
        )

        # -- Use type that wf_generator returns to have flexibility
        # -- with whether TimeSeries/FrequencySeries is passed
        out = type(wf)(data=deriv, xindex=wf.frequencies, unit=wf.unit / param_unit)

        return out

    __call__.__doc__ = WaveformDerivativeBase.__call__.__doc__

    @property
    def _default_base_step(self) -> float:
        """Largest step size used by default."""
        _par_val = self.param_center_val.value
        return 1e-2 * (_par_val if _par_val != 0.0 else 1.0)
        # -- If case needed to avoid zero step size

        # if _par_val == 0. or np.log10(_par_val) < 1:
        #     return 1e-2
        # else:
        #     return 1e-2*_par_val

    def test_point(self, point: dict[str, u.Quantity]) -> None:
        """
        Check if `point` contains potentially tricky values, e.g.
        mass ratios close to 1. If yes, a subsequent adjustment of step
        sizes etc may be performed.
        """
        default_bounds = (-np.inf, np.inf)
        lower_bound, upper_bound = self.param_bounds.get(
            self.param_to_vary, default_bounds
        )
        if (self.param_to_vary == 'mass_ratio') and (self.param_center_val > 1):
            # -- In this convention, bounds have to be corrected
            lower_bound, upper_bound = self.param_bounds.get(
                'inverse_mass_ratio', default_bounds
            )

        _base_step = self.abs_deriv.step.base_step
        assert _base_step > 0.0, (
            'Reached step size of zero, cannot proceed.'
        )  # pragma: no cover
        # -- Same for phase_deriv. No need for separate treatmtent since
        # -- violations only happen for initial step size (since this
        # -- function is called repeatedly until step size is small
        # -- enough to not violate bounds anymore).

        _par_val = point[self.param_to_vary].value

        def violation(step):
            return (
                _par_val - step <= lower_bound,
                _par_val + step >= upper_bound,
            )

        lower_violation, upper_violation = violation(_base_step)

        if any((lower_violation, upper_violation)):
            logger.info(
                f"Parameter '{self.param_to_vary}' at value "
                f'{self.param_center_val} is close to bounds; adjusting step '
                'size/method. If this message appears repeatedly, consider '
                'adjusting parameter bounds or initial values.'
            )

        # -- Check if base_step needs change
        if lower_violation and upper_violation:
            self.abs_deriv.step.base_step = self.phase_deriv.step.base_step = min(
                _base_step / 2.0, self._default_base_step
            )

            if any(violation(self.abs_deriv.step.base_step)):
                self.test_point(point)  # Recursive call until step size is small enough
        elif lower_violation and not upper_violation:
            # -- Can only happen if method is not forward yet
            self.abs_deriv.step.base_step = self.phase_deriv.step.base_step = min(
                _base_step / 2.0, self._default_base_step
            )

            if violation(self.abs_deriv.step.base_step)[0]:
                # -- Too close to lower bound still, change method
                self.abs_deriv.method = self.phase_deriv.method = 'forward'
        elif not lower_violation and upper_violation:
            # -- Can only happen if method is not backward yet
            self.abs_deriv.step.base_step = self.phase_deriv.step.base_step = min(
                _base_step / 2.0, self._default_base_step
            )

            if violation(self.abs_deriv.step.base_step)[1]:
                # -- Too close to upper bound still, change method
                self.abs_deriv.method = self.phase_deriv.method = 'backward'

    class DerivInfo(NamedTuple):
        """Namedtuple for amplitude-phase derivative information."""

        abs: Optional[WaveformDerivativeNumdifftools.DerivInfo] = None
        """Information about the amplitude derivative."""
        f_value: Optional[NDArray | u.Quantity] = None
        """Function value at the evaluation point."""
        is_exact_deriv: bool = False
        """Whether derivative is exact (analytical) or not."""
        phase: Optional[WaveformDerivativeNumdifftools.DerivInfo] = None
        """Information about the phase derivative."""

    @property
    def abs_deriv(self) -> nd.Derivative:
        """
        Wrapper that calculates derivative of waveform amplitude.

        :type: `~numdifftools.core.Derivative`
        """
        return self._abs_deriv

    @property
    def abs_fun(self) -> Callable[[NDArray | u.Quantity], NDArray | u.Quantity]:
        """
        Function that calculates the waveform amplitude.

        :type: `Callable[[NDArray | u.Quantity], NDArray | u.Quantity]`
        """
        return np.abs

    @property
    def phase_deriv(self) -> nd.Derivative:
        """
        Wrapper that calculates derivative of waveform phase.

        :type: `~numdifftools.core.Derivative`
        """
        return self._phase_deriv

    @staticmethod
    def _phase_wrapper(x):  # -- Define here to avoid recreating function
        return np.unwrap(np.angle(x))

    @property
    def phase_fun(self) -> Callable[[NDArray | u.Quantity], NDArray | u.Quantity]:
        """
        Function that calculates the waveform phase.

        :type: `Callable[[NDArray | u.Quantity], NDArray | u.Quantity]`
        """
        return self._phase_wrapper


if nd.__version__ <= '0.9.41':  # pragma: no cover
    # -- Now: fix bug in nd.Derivative, complex input throws error. This is
    # -- due to numpy changes that were not (yet) addressed by numdifftools
    from numdifftools.limits import _Limit
    import warnings

    def _add_error_to_outliers_fixed(der, trim_fact=2):  # pragma: no cover
        """
        discard any estimate that differs wildly from the
        median of all estimates. A factor of 10 to 1 in either
        direction is probably wild enough here. The actual
        trimming factor is defined as a parameter.
        """
        if np.iscomplexobj(der):
            return np.sqrt(
                _add_error_to_outliers_fixed(np.real(der), trim_fact) ** 2
                + _add_error_to_outliers_fixed(np.imag(der), trim_fact) ** 2
            )

        try:
            if np.any(np.isnan(der)):
                p25, median, p75 = np.nanpercentile(der, [25, 50, 75], axis=0)
            else:
                p25, median, p75 = np.percentile(der, [25, 50, 75], axis=0)

            iqr = np.abs(p75 - p25)
        except ValueError as msg:
            warnings.warn(str(msg))
            return 0 * der

        a_median = np.abs(median)
        outliers = (
            (abs(der) < (a_median / trim_fact)) + (abs(der) > (a_median * trim_fact))
        ) * (a_median > 1e-8) + ((der < p25 - 1.5 * iqr) + (p75 + 1.5 * iqr < der))
        errors = outliers * np.abs(der - median)
        return errors

    _Limit._add_error_to_outliers = staticmethod(_add_error_to_outliers_fixed)
