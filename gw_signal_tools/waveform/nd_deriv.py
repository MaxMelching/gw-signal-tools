# -- Standard Lib Imports
from typing import Callable, Any

# -- Third Party Imports
import numdifftools as nd
import astropy.units as u
import numpy as np
from gwpy.frequencyseries import FrequencySeries
from gwpy.timeseries import TimeSeries

# -- Local Package Imports
from .inner_product import param_bounds


__doc__ = """
Module for ``WaveformDerivativeNumdifftools`` and
``WaveformDerivativeAmplitudePhase`` classes.
"""

__all__ = ('WaveformDerivativeNumdifftools', 'WaveformDerivativeAmplitudePhase')


class WaveformDerivativeNumdifftools(nd.Derivative):
    r"""
    Wrapper around :code:`numdifftools.Derivative` class specifically
    for waveform callers from new LAL interface.

    Parameters
    ----------
    point : dict[str, ~astropy.units.Quantity]
        Point in parameter space at which the derivative is evaluated,
        encoded as key-value pairs representing parameter-value pairs.

        In principle, the keys can be arbitrary, only two requirements
        have to be fulfilled: (i) the dictionary must be accepted by
        :code:`wf_generator` since it is given as input to this functoin
        and (ii) :code:`param_to_vary` has to be accessible as a key
        (except one of the special cases mentioned in the description of
        :code:`params_to_vary` is true).
    param_to_vary : str
        Parameter with respect to which the derivative is taken. Must be
        a key in :code:`point` or one of :code:`'time'`,
        :code:`'phase'`.
        
        For time and phase shifts, analytical derivatives are applied.
        This is possible because they contribute only to a factor
        :math:`\exp(i \cdot phase - i \cdot 2 \pi \cdot f \cdot time)`
        in the waveform generated by `wf_generator`, i.e. they are
        global phase and time shifts.
        Beware that the polarization angle :code:`psi` might be
        degenerate with :code:`phase`, if you are using the complex
        strain combination :math:`h = h_+ \pm i \, h_{\times}`.

        The last analytical derivative is the one for the luminosity
        distance :math:`D_L`, which enters in waveforms only as an
        amplitude factor :math:`1/D_L`. Note that can only be done
        if the parameter recognized, i.e. if it is called `'distance'`.
    wf_generator : Callable[[dict[str, ~astropy.units.Quantity]], ~gwpy.frequencyseries.FrequencySeries]
        Arbitrary function that is used for waveform generation. The
        required signature means that it has one non-optional argument,
        which is expected to accept the input provided in
        :code:`point`, while the output must be a ``~gwpy.
        frequencyseries.FrequencySeries`` (the standard output of
        LAL gwsignal generators) because it carries information about
        value, frequencies and units, which are all required for the
        calculations that are carried out.

        A convenient option is to use the method
        :code:`~gw_signal_tools.waveform_utils.get_wf_generator`, which
        generates a suitable function from a few arguments.
    args, kwds :
        All other positional and keyword arguments are passed on as such
        to the :code:`numdifftools.Derivative` class.

    Notes
    -----
    For a time domain model, you as a user have to make sure that output
    always has the same size (and is defined on same times)!!! Otherwise
    the required operations will not work.

    Custom attributes defined by us are :code:`.deriv` and
    :code:`.deriv_info`, which have analogous names to the ones defined
    in :code:`gw_signal_tools.WaveformDerivativeGWSignaltools`.


    Arbitrary function that is used for waveform generation. The
    required signature means that it has one non-optional argument,
    which is expected to accept the input provided in
    :code:`self.point`.
    """
    def __init__(
        self,
        point: dict[str, u.Quantity],
        param_to_vary: str,
        wf_generator: Callable[[dict[str, u.Quantity]], FrequencySeries | TimeSeries],
        *args,
        **kwds
    ) -> None:
        # -- Check if parameter has analytical derivative
        if param_to_vary == 'time':
            wf = wf_generator(point)
            deriv = wf * (-1.j * 2. * np.pi * wf.frequencies)

            self.deriv_info = {
                'description': 'This derivative is exact.'
            }
            self._ana_deriv = deriv
            return None
        elif param_to_vary == 'phase':
            wf = wf_generator(point)
            deriv = wf * 1.j / u.rad
            
            self.deriv_info = {
                'description': 'This derivative is exact.'
            }
            self._ana_deriv = deriv
            return None
        
        self._param_center_val = point[param_to_vary]
        param_unit = self.param_center_val.unit
        self._wf_generator = wf_generator
        self._point = point
        self._param_to_vary = param_to_vary

        if 'base_step' not in kwds:
            # -- Set maximum step size. To verify, one can print e.g.
            # -- the steps in Derivative._derivative_nonzero_order
            kwds['base_step'] = self._default_base_step
        elif isinstance(_base_step := kwds['base_step'], u.Quantity):
            kwds['base_step'] = _base_step.to_value(self.param_center_val.unit)

        def fun(x):
            return self.wf_generator(point | {param_to_vary: x*param_unit})
        # -- Next line stores this function in self.fun
        
        super().__init__(fun, *args, **kwds)
    
    def __call__(self, x=None) -> Any:
        """
        Get derivative at :code:`x`.

        Parameters
        ----------
        x : Any, optional, default = None
            Parameter value at which the derivative is calculated. By
            default, the corresponding value from :code:`self.point`
            are chosen.
        
        Returns
        -------
        Derivative, put into whatever type :code:`self.wf_generator`
        has. This should, in principle, be either a GWpy
        :code:``FrequencySeries`` or a GWpy :code:``TimeSeries`` (in
        accordance with standard LAL output types), but this function
        only rely on GWPy :code:``Series`` properties being defined and
        thus the output could also be of this type.

        Notes
        -----
        Information gathered during calculation is stored in the
        :code:`self.deriv_info` property.
        """
        # -- Check if analytical derivative has already been calculated
        if hasattr(self, '_ana_deriv'):
            return self._ana_deriv
        
        # -- Check selected arguments
        if x is None:
            x = self.param_center_val.value
        elif isinstance(x, u.Quantity):
            x = x.to_value(self.param_center_val.unit)

        # -- Check if parameter has analytical derivative (cannot be in
        # -- previous check because dependent on point)
        if self.param_to_vary == 'distance':
            dist_val = x*self.param_center_val.unit
            wf = self.wf_generator(self.point | {'distance': dist_val})
            deriv = (-1./dist_val) * wf

            self.deriv_info = {
                'description': 'This derivative is exact.'
            }
            return deriv
        
        # -- Test for valid point, potentially adjusting method
        self.test_base_step()

        self.full_output = True
        deriv, info = super().__call__(x)
        self.deriv_info = info._asdict()

        param_unit = self.param_center_val.unit

        wf = self.fun(x)
        # Idea: use type that wf_generator returns to have flexibility
        # with respect to whether TimeSeries/FrequencySeries is passed
        out = type(wf)(
            data=deriv,
            xindex=wf.xindex,
            unit=wf.unit / param_unit
        )

        self.error_estimate = type(wf)(
            data=info.error_estimate,
            xindex=wf.xindex,
            unit=wf.unit / param_unit
        )
        self.deriv_info['error_estimate'] = self.error_estimate

        return out
    
    @property
    def _default_base_step(self) -> float:
        """Largest step size used by default."""
        _par_val = self.param_center_val.value
        return 1e-2*(_par_val if _par_val != 0. else 1.)
        # -- If case needed to avoid zero step size
        
        # if _par_val == 0. or np.log10(_par_val) < 1:
        #     return 1e-2
        # else:
        #     return 1e-2*_par_val
    
    _param_bound_storage = param_bounds.copy()
    
    @property
    def param_bounds(self, param: str) -> tuple[float, float]:
        return self._param_bound_storage[param]
    
    @param_bounds.setter
    def param_bounds(self, param: str, bounds: list[float, float]) -> None:
        """
        Specify bounds for a parameter that does not have registered
        bounds yet, or update parameter bounds.

        Parameters
        ----------
        param : str
            The parameter for which bounds shall be specified.
        bounds : list[float, float]
            Lower and upper bound.
        """
        assert len(bounds) == 2, 'Need exactly one lower and one upper bound.'
        self._param_bound_storage[param] = bounds
    
    def test_base_step(self) -> None:
        """
        Check if `self.point` contains potentially tricky values, e.g.
        mass ratios close to 1. If yes, a subsequent adjustment takes
        place.
        """
        default_bounds = (-np.inf, np.inf)
        lower_bound, upper_bound = self._param_bound_storage.get(
            self.param_to_vary, default_bounds)
        if self.param_to_vary == 'mass_ratio':
            # -- Depending on chosen convention, bounds might have to be corrected
            if self.param_center_val > 1:
                lower_bound, upper_bound = self._param_bound_storage.get(
                    self.param_to_vary, default_bounds)
        
        _base_step = self.step.base_step
        _par_val = self.param_center_val.value
        lower_violation = _par_val - _base_step <= lower_bound
        upper_violation = _par_val + _base_step >= upper_bound

        # -- Check if base_step needs change
        if lower_violation and upper_violation:
            self.step.base_step = min(_base_step/2., self._default_base_step)
        elif lower_violation and not upper_violation:
            # -- Can only happen if method is not forward yet
            self.method = 'forward'
            self.step.base_step = min(_base_step/2., self._default_base_step)
        elif not lower_violation and upper_violation:
            # -- Can only happen if method is not backward yet
            self.method = 'backward'
            self.step.base_step = min(_base_step/2., self._default_base_step)
    
    # -- In case calling seems unintiutive, create attribute
    @property
    def deriv(self) -> Any:
        """Alias for calling with no arguments."""
        return self.__call__()
    
    # -- Define certain properties. These have NO setters, on purpose!
    @property
    def param_to_vary(self) -> str:
        """
        Parameter that derivative is taken with respect to.

        :type: `str`
        """
        return self._param_to_vary
    
    @property
    def param_center_val(self) -> u.Quantity:
        """
        Value of `self.param_to_vary` at which derivative is taken by
        default.

        :type: `~astropy.units.Quantity`
        """
        return self._param_center_val
    
    @property
    def wf_generator(self) -> Callable[[dict[str, u.Quantity]], FrequencySeries | TimeSeries]:
        """
        Generator for waveform model that is differentiated.

        :type: `Callable[[dict[str, ~astropy.units.Quantity]], ~gwpy.frequencyseries.FrequencySeries | ~gwpy.timeseries.TimeSeries]`
        """
        return self._wf_generator
    
    @property
    def point(self) -> dict[str, u.Quantity]:
        """
        Point in parameter space at which waveform is differentiated,
        encoded as key-value pairs representing parameter-value pairs.

        :type: `dict[str, ~astropy.units.Quantity]`
        """
        return self._point
    
    @property
    def deriv_info(self) -> dict[str, Any]:
        """
        Information about the calculated derivative, given as a
        dictionary. All keys from this dictionary are also accessible
        as a class attribute.
        """
        return self._deriv_info
    
    @deriv_info.setter
    def deriv_info(self, info: dict[str, Any]):
        for key, val in info.items():
            # -- Make each key from deriv_info available as attribute
            setattr(self, key, val)
        
        self._deriv_info = info


# -- Now: fix bug in nd.Derivative, complex input throws error. This is
# -- due to numpy changes that were not (yet?) addressed by numdifftools
from numdifftools.limits import _Limit
import numpy as np
import warnings

def _add_error_to_outliers_fixed(der, trim_fact=10):  # pragma: no cover
    """
    discard any estimate that differs wildly from the
    median of all estimates. A factor of 10 to 1 in either
    direction is probably wild enough here. The actual
    trimming factor is defined as a parameter.
    """
    if np.iscomplexobj(der):    
        return np.sqrt(
            _add_error_to_outliers_fixed(np.real(der), trim_fact)**2
            + _add_error_to_outliers_fixed(np.imag(der), trim_fact)**2
        )
    
    try:
        if np.any(np.isnan(der)):
            p25, median, p75 = np.nanpercentile(der, [25,50, 75], axis=0) 
        else:
            p25, median, p75 = np.percentile(der, [25,50, 75], axis=0)

        iqr = np.abs(p75 - p25)
    except ValueError as msg:
        warnings.warn(str(msg))
        return 0 * der

    a_median = np.abs(median)
    outliers = (((abs(der) < (a_median / trim_fact)) +
                (abs(der) > (a_median * trim_fact))) * (a_median > 1e-8) +
                ((der < p25 - 1.5 * iqr) + (p75 + 1.5 * iqr < der)))
    errors = outliers * np.abs(der - median)
    return errors

_Limit._add_error_to_outliers = staticmethod(_add_error_to_outliers_fixed)


class WaveformDerivativeAmplitudePhase():
    r"""
    Calculate the derivative of an arbitrary waveform with respect to
    an arbitrary input parameter, based on the chain rule. More on that
    in the Notes section.

    Parameters
    ----------
    point : dict[str, ~astropy.units.Quantity]
        Point in parameter space at which the derivative is evaluated,
        encoded as key-value pairs representing parameter-value pairs.

        In principle, the keys can be arbitrary, only two requirements
        have to be fulfilled: (i) the dictionary must be accepted by
        :code:`wf_generator` since it is given as input to this functoin
        and (ii) :code:`param_to_vary` has to be accessible as a key
        (except one of the special cases mentioned in the description of
        :code:`params_to_vary` is true).
    param_to_vary : str
        Parameter with respect to which the derivative is taken. Must be
        a key in :code:`point` or one of :code:`'time'`,
        :code:`'phase'`.
        
        For time and phase shifts, analytical derivatives are applied.
        This is possible because they contribute only to a factor
        :math:`\exp(i \cdot phase - i \cdot 2 \pi \cdot f \cdot time)`
        in the waveform generated by `wf_generator`, i.e. they are
        global phase and time shifts.
        Beware that the polarization angle :code:`psi` might be
        degenerate with :code:`phase`, if you are using the complex
        strain combination :math:`h = h_+ \pm i \, h_{\times}`.

        The last analytical derivative is the one for the luminosity
        distance :math:`D_L`, which enters in waveforms only as an
        amplitude factor :math:`1/D_L`. Note that can only be done
        if the parameter recognized, i.e. if it is called `'distance'`.
    wf_generator : Callable[[dict[str, ~astropy.units.Quantity]], ~gwpy.frequencyseries.FrequencySeries]
        Arbitrary function that is used for waveform generation. The
        required signature means that it has one non-optional argument,
        which is expected to accept the input provided in
        :code:`point`, while the output must be a ``~gwpy.
        frequencyseries.FrequencySeries`` (the standard output of
        LAL gwsignal generators) because it carries information about
        value, frequencies and units, which are all required for the
        calculations that are carried out.

        A convenient option is to use the method
        :code:`~gw_signal_tools.waveform_utils.get_wf_generator`, which
        generates a suitable function from a few arguments.
    args, kwds :
        All other positional and keyword arguments are passed on as such
        to the :code:`numdifftools.Derivative` class.
    
    Notes
    -----
    Just like :class:``WaveformDerivativeNumdifftools``, this class uses
    routines provided by the :code:`numdifftools` package. The major
    difference is that we express :math:`h = A \cdot e^{i \cdot \phi}`
    and then calculate the derivatives :math:`\partial_{\theta^\mu} A`,
    :math:`\partial_{\theta^\mu} \phi` (:math:`\theta^\mu` is some
    arbitrary parameter). This is sufficient as the chain rule yields
    :math:`\partial_{\theta^\mu} h = (\partial_{\theta^\mu} A + i \cdot
    \partial_{\theta^\mu} \phi) e^{i \cdot \phi}`.

    This behaves potentially better mathematically, but also introduces
    some changes from a code perspective compared to the other
    derivatives: there is no straightforward way to get something like
    an overall final step size from the ones for amplitude and phase.
    Thus, structure and attributes are very different for this class.
    """
    def __init__(
        self,
        point: dict[str, u.Quantity],
        param_to_vary: str,
        wf_generator: Callable[[dict[str, u.Quantity]], FrequencySeries | TimeSeries],
        *args,
        **kwds
    ) -> None:
        # -- Check if parameter has analytical derivative
        if param_to_vary == 'time':
            wf = wf_generator(point)
            deriv = wf * (-1.j * 2. * np.pi * wf.frequencies)

            self.deriv_info = {
                'description': 'This derivative is exact.'
            }
            self._ana_deriv = deriv
            return None
        elif param_to_vary == 'phase':
            wf = wf_generator(point) 
            deriv = wf * 1.j / u.rad

            self.deriv_info = {
                'description': 'This derivative is exact.'
            }
            self._ana_deriv = deriv
            return None
        
        self._param_center_val = point[param_to_vary]
        param_unit = self.param_center_val.unit
        self._wf_generator = wf_generator
        self._point = point
        self._param_to_vary = param_to_vary

        if 'base_step' not in kwds:
                kwds['base_step'] = self._default_base_step
        elif isinstance(_base_step := kwds['base_step'], u.Quantity):
            kwds['base_step'] = _base_step.to_value(self.param_center_val.unit)
        
        # def abs_wrapper(x):
        #     _point = point |{
        #         param_to_vary: x * param_unit
        #     }
        #     return np.abs(wf_generator(_point).value)

        # def phase_wrapper(x):
        #     _point = point |{
        #         param_to_vary: x * param_unit
        #     }
        #     return np.unwrap(np.angle(wf_generator(_point).value))

        # -- Defining fun turns out to be useful later on
        # TODO: decide if calling it in abs_wrapper, phase_wrapper makes sense
        # -> it does make nice code. And one additional call with single argument should not be too bad
        def fun(x):
            return self.wf_generator(point | {param_to_vary: x*param_unit})
        self.fun = fun

        def abs_wrapper(x):
            return np.abs(self.fun(x).value)

        def phase_wrapper(x):
            return np.unwrap(np.angle(self.fun(x).value))
        
        self._abs_deriv = nd.Derivative(abs_wrapper, *args, **kwds)
        self._phase_deriv = nd.Derivative(phase_wrapper, *args, **kwds)
    
    def __call__(self, x=None) -> Any:
        # -- Check if analytical derivative has already been calculated
        if hasattr(self, '_ana_deriv'):
            return self._ana_deriv
        
        # -- Check selected arguments
        if x is None:
            x = self.param_center_val.value
        elif isinstance(x, u.Quantity):
            x = x.to_value(self.param_center_val.unit)        

        # -- Check if parameter has analytical derivative (cannot be in
        # -- previous check because dependent on point)
        if self.param_to_vary == 'distance':
            dist_val = x*self.param_center_val.unit
            wf = self.wf_generator(self.point | {'distance': dist_val})
            deriv = (-1./dist_val) * wf

            self.deriv_info = {
                'description': 'This derivative is exact.'
            }
            return deriv
        
        # -- Test for valid point, potentially adjusting method
        self.test_base_step()        

        self.abs_deriv.full_output = True
        abs_deriv, abs_info = self.abs_deriv(x)

        self.phase_deriv.full_output = True
        phase_deriv, phase_info = self.phase_deriv(x)

        self.deriv_info = {'abs': abs_info._asdict(),
                           'phase': phase_info._asdict()}

        param_unit = self.param_center_val.unit

        wf = self.fun(x)
        ampl = np.abs(wf).value
        phase = np.unwrap(np.angle(wf)).value
        # -- TODO: following would be more future proof I think... But
        # -- involves more calls to function... So should we do it?
        # ampl = self.abs_fun(x)
        # phase = self.phase_fun(x)

        deriv = (abs_deriv + 1.j*ampl*phase_deriv) * np.exp(1j*phase)

        # -- Use type that wf_generator returns to have flexibility
        # -- with whether TimeSeries/FrequencySeries is passed
        out = type(wf)(
            data=deriv,
            xindex=wf.frequencies,
            unit=wf.unit / param_unit
        )

        return out
    
    @property
    def _default_base_step(self) -> float:
        """Largest step size used by default."""
        _par_val = self.param_center_val.value
        return 1e-2*(_par_val if _par_val != 0. else 1.)
        # -- If case needed to avoid zero step size
        
        # if _par_val == 0. or np.log10(_par_val) < 1:
        #     return 1e-2
        # else:
        #     return 1e-2*_par_val
    
    _param_bound_storage = param_bounds.copy()
    param_bounds = WaveformDerivativeNumdifftools.param_bounds
    
    def test_base_step(self) -> None:
        """
        Check if `self.point` contains potentially tricky values, e.g.
        mass ratios close to 1. If yes, a subsequent adjustment takes
        place.
        """
        default_bounds = (-np.inf, np.inf)
        lower_bound, upper_bound = self._param_bound_storage.get(
            self.param_to_vary, default_bounds)
        if self.param_to_vary == 'mass_ratio':
            # -- Depending on chosen convention, bounds might have to be corrected
            if self.param_center_val > 1:
                lower_bound, upper_bound = self._param_bound_storage.get(
                    self.param_to_vary, default_bounds)
        
        _base_step = self.abs_deriv.step.base_step  # Same for phase_deriv
        _par_val = self.param_center_val.value
        lower_violation = _par_val - _base_step <= lower_bound
        upper_violation = _par_val + _base_step >= upper_bound

        # -- Check if base_step needs change
        if lower_violation and upper_violation:
            self.abs_deriv.step.base_step = self.phase_deriv.step.base_step = min(_base_step/2., self._default_base_step)
        elif lower_violation and not upper_violation:
            # -- Can only happen if method is not forward yet
            self.method = 'forward'
            self.abs_deriv.step.base_step = self.phase_deriv.step.base_step = min(_base_step/2., self._default_base_step)
        elif not lower_violation and upper_violation:
            # -- Can only happen if method is not backward yet
            self.method = 'backward'
            self.abs_deriv.step.base_step = self.phase_deriv.step.base_step = min(_base_step/2., self._default_base_step)
    
    @property
    def deriv(self) -> Any:
        """Alias for calling with no arguments."""
        return self.__call__()
    
    # -- Define certain properties. These have NO setters, on purpose!
    param_to_vary = WaveformDerivativeNumdifftools.param_to_vary
    param_center_val = WaveformDerivativeNumdifftools.param_center_val
    wf_generator = WaveformDerivativeNumdifftools.wf_generator
    point = WaveformDerivativeNumdifftools.point

    @property
    def abs_deriv(self) -> nd.Derivative:
        """
        Wrapper that calculates derivative of waveform amplitude.

        :type: `~numdifftools.core.Derivative`
        """
        return self._abs_deriv
    
    @property
    def abs_fun(self) -> Callable[[float], np.ndarray]:
        """
        Function that calculates the waveform amplitude.

        :type: `Callable[[float], ~numpy.ndarray]`
        """
        return self.abs_deriv.fun
    
    @property
    def phase_deriv(self) -> nd.Derivative:
        """
        Wrapper that calculates derivative of waveform phase.

        :type: `~numdifftools.core.Derivative`
        """
        return self._phase_deriv
    
    @property
    def phase_fun(self) -> Callable[[float], np.ndarray]:
        """
        Function that calculates the waveform phase.

        :type: `Callable[[float], ~numpy.ndarray]`
        """
        return self.phase_deriv.fun
    
    deriv_info = WaveformDerivativeNumdifftools.deriv_info
