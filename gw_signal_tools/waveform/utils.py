# -- Standard Lib Imports
from typing import Optional, Literal

# -- Third Party Imports
import numpy as np
import astropy.units as u
from gwpy.timeseries import TimeSeries
from gwpy.frequencyseries import FrequencySeries
from lalsimulation.gwsignal import (
    gwsignal_get_waveform_generator,
    GravitationalWaveGenerator,
)
import lalsimulation.gwsignal.core.waveform as wfm

# -- Local Package Imports
from ..logging import logger
from ..test_utils import allclose_quantity
from ._error_helpers import _q_convert
from ..types import WFGen, FDWFGen


__all__ = (
    'pad_to_target_df',
    'restrict_f_range',
    'fill_f_range',
    'get_signal_at_target_df',
    'get_signal_at_target_frequs',
    'get_strain',
    'get_wf_generator',
    'apply_time_phase_shift',
    'time_phase_wrapper',
)

__doc__ = """
Waveform helpers for work with waveforms generated by gwsignal.
"""


# -- Inner Product Helpers ----------------------------------------------------
def pad_to_target_df(signal: TimeSeries, df: float | u.Quantity) -> TimeSeries:
    """
    Pads :code:`signal` with zeros after its end until a fft of it has
    desired resolution of :code:`df`. If the resolution is already at
    the required level, it does not nothing (i.e. this function is not
    suited for getting a smaller df, which would require cropping of the
    time-domain signal; to do this, :code:`FrequencySeries.interpolate`
    can be applied to the Fourier transform instead).

    Parameters
    ----------
    signal : ~gwpy.timeseries.TimeSeries
        Signal that will be padded.
    df : float or ~astropy.units.Quantity
        Desired resolution in frequency domain.

    Returns
    -------
    padded_signal : ~gwpy.timeseries.TimeSeries
        Padded signal, still in time domain.
    """
    # -- Handle units
    frequ_unit = 1.0 / signal.times.unit
    df = _q_convert(df, frequ_unit, 'df', 'signal.frequencies')

    # -- Check whether padding is required or current df is sufficient
    df_current = 1.0 / (signal.size * signal.dt)
    if df_current > df:
        target_sample_number = int(np.ceil(1.0 / (signal.dt * df)))
        number_to_append = target_sample_number - signal.size

        # padding_series = TimeSeries(
        #     np.zeros(number_to_append),
        #     unit=signal.unit,
        #     t0=signal.times[-1] + signal.dt,
        #     dt=signal.dt,
        #     dtype=signal.dtype
        # )
        # padded_signal = signal.append(padding_series, inplace=False)
        padded_signal = TimeSeries(
            np.zeros(number_to_append),
            unit=signal.unit,
            t0=signal.t0 - number_to_append * signal.dt,
            dt=signal.dt,
            dtype=signal.dtype,
        ).append(signal)
    else:
        padded_signal = signal

    return padded_signal


def restrict_f_range(
    signal: FrequencySeries,
    f_range: Optional[tuple[float, float] | tuple[u.Quantity, u.Quantity]] = None,
    fill_val: float | u.Quantity = 0.0,
    fill_range: Optional[tuple[float, float] | tuple[u.Quantity, u.Quantity]] = None,
    copy: bool = True,
) -> FrequencySeries:
    """
    Pad :code:'signal' to frequencies specified by :code:`f_range`,
    while potentially setting its values in the interval
    :code:`fill_range` to a fixed value.

    Parameters
    ----------
    signal : ~gwpy.frequencyseries.FrequencySeries
        Signal to be restricted.
    f_range : list[float] or list[~astropy.units.Quantity]
        Two-tuple specifying lower and upper frequency bounds of the
        returned signal. Based on this value, :code:`signal` will either
        be padded with :code:`fill_val` or trimmed.

        Main usecase is preparation for an inverse Fourier
        transformation, where certain frequency ranges are required.
    fill_val : float or ~astropy.units.Quantity, optional, default = 0.0
        Value that will be used to fill :code:`signal` outside of
        :code:`f_range`.
    fill_range : list[float] or list[~astropy.units.Quantity], optional, default = False
        Two-tuple specifying lower and upper frequency bounds of the
        interval outside of which the returned signal is filled with
        :code:`fill_val`.
    copy : bool, optional, default = True
        Determines if the input signal is copied before performing
        operations or not. Note that not all of them are (can be)
        performed inplace, so setting copy to False does still not mean
        the output signal will be equal to the input after calling the
        function.

    Returns
    -------
    ~gwpy.frequencyseries.FrequencySeries
        Copy of signal where values outside of :code:`f_range` have been
        changed. If the interval defined by :code:`f_range` is larger
        than the one spanned by :code:`signal.frequencies`, no entry
        will be changed.

    Raises
    ------
    ValueError
        If :code:`f_range`, :code:`fill_range` do not contain exactly
        two elements.
    """
    assert isinstance(
        signal, FrequencySeries
    ), '`signal` has to be a GWPy ``FrequencySeries``.'

    # -- Handling f_range
    frequ_unit = signal.frequencies.unit

    if f_range is None:
        f_range = [None, None]
    elif len(f_range) != 2:  # pragma: no cover
        raise ValueError(
            '`f_range` must be None or contain lower and upper frequency bounds.'
        )

    f_lower = f_range[0] if f_range[0] is not None else signal.frequencies[0]
    f_upper = f_range[1] if f_range[1] is not None else signal.frequencies[-1]

    f_lower = _q_convert(f_lower, frequ_unit, 'f_lower', 'signal.frequencies')
    f_upper = _q_convert(f_upper, frequ_unit, 'f_upper', 'signal.frequencies')

    # -- Handling fill_val
    signal_unit = signal.unit
    fill_val = _q_convert(fill_val, signal_unit, 'fill_val', 'signal')

    # -- Padding/trimming
    lower_number = abs(int(np.ceil((f_lower - signal.f0) / signal.df)))

    if f_lower < signal.f0:  # Equivalent to lower_number > 0
        signal = FrequencySeries(
            np.full(lower_number, fill_value=fill_val.value),
            unit=signal_unit,
            f0=f_lower,
            df=signal.df,
            name=signal.name,
            epoch=signal.epoch,
            channel=signal.channel,
            dtype=signal.dtype,
        ).append(signal, inplace=True, pad=fill_val.value)
        # -- Properties of first series are taken in append, thus need
        # -- to paste all necessary properties
    elif f_lower > signal.f0:
        signal = signal[lower_number:]

    upper_number = abs(int(np.ceil((f_upper - signal.frequencies[-1]) / signal.df)))

    if f_upper > signal.frequencies[-1]:  # Equivalent to upper_number > 0
        signal = signal.append(
            FrequencySeries(
                np.full(upper_number, fill_value=fill_val.value),
                unit=signal_unit,
                f0=signal.frequencies[-1] + signal.df,
                df=signal.df,
                dtype=signal.dtype,
            ),
            inplace=False,  # Otherwise error
        )  # Could avoid copy from beginning, right?
    elif f_upper < signal.frequencies[-1]:
        signal = signal[: signal.size - upper_number]

    # -- Filling
    if fill_range is None:
        fill_range = f_range
    elif len(fill_range) != 2:  # pragma: no cover
        raise ValueError(
            '`fill_range` must be None or contain lower and upper frequency bounds.'
        )

    f_fill_lower = _q_convert(
        fill_range[0] if fill_range[0] is not None else f_lower,
        frequ_unit,
        'f_fill_lower',
        'signal.frequencies',
    )
    f_fill_upper = _q_convert(
        fill_range[1] if fill_range[1] is not None else f_upper,
        frequ_unit,
        'f_fill_upper',
        'signal.frequencies',
    )

    if f_fill_lower < f_lower:
        logger.info(
            f'Lower bound {f_fill_lower} in `fill_range` is smaller '
            f'than the signals smallest frequency {f_lower}. Please be '
            'aware that this function does nothing to change that, i.e.'
            ' no padding is applied (adjust `f_range` for that).'
        )

        f_fill_lower = f_lower

    if f_fill_upper > f_upper:
        logger.info(
            f'Upper bound {f_fill_upper} in `fill_range` is larger '
            f'than the signals largest frequency {f_upper}. Please be '
            'aware that this function does nothing to change that, i.e.'
            ' no padding is applied (adjust `f_range` for that).'
        )

        f_fill_upper = f_upper

    # -- Check if fill_f_range will do something and copy if required
    if (
        copy
        and (lower_number == 0)
        and (f_fill_lower != f_lower)
        and (f_fill_upper != f_upper)
    ):
        # -- Signal shall not be edited inplace and has not been copied
        # -- in previous beforehand in function
        signal = signal.copy()

    signal = fill_f_range(signal, fill_val, [f_fill_lower, f_fill_upper])

    return signal


def fill_f_range(
    signal: FrequencySeries,
    fill_val: float | u.Quantity,
    fill_bounds: tuple[float, float] | tuple[u.Quantity, u.Quantity],
) -> FrequencySeries:
    """
    Fills :code:`signal` with :code:`fill_val` outside of interval
    provided in :code:`fill_range`. Note that this function operates
    inplace, i.e. the input is changed. For a function with similar
    functionality that is not applied inplace, consider using
    :code:`~gw_signal_tools.waveform_utils.restrict_f_range`.

    Parameters
    ----------
    signal : FrequencySeries
        Signal to be (potentially) filled.
    fill_val : float or ~astropy.units.Quantity
        Value to fill with.
    fill_bounds : tuple[float, float] or tuple[~astropy.units.Quantity, ~astropy.units.Quantity]
        Bounds of interval outside of which :code:`signal` is filled.
        Must have length 2, but members can be None to indicate that no
        filling shall be done on the respective end of the interval.

    Returns
    -------
    FrequencySeries
        Edited input :code:`signal`.

    Raises
    ------
    ValueError
        If :code:`fill_bounds` is does not have two elements.
    ValueError
        If members of :code:`fill_bounds` have frequency units that are
        incompatible with the frequency units of :code:`signal`.
    """
    fill_val = _q_convert(fill_val, signal.unit, 'fill_val', 'signal')

    frequ_unit = signal.frequencies.unit
    f_lower, f_upper = signal.f0, signal.frequencies[-1]

    if len(fill_bounds) != 2:  # pragma: no cover
        raise ValueError('`fill_bounds` must contain lower and upper frequency bounds.')

    # -- Actual filling
    if (f_fill_lower := fill_bounds[0]) is not None:
        f_fill_lower = _q_convert(
            f_fill_lower, frequ_unit, 'f_fill_lower', 'signal.frequencies'
        )
        if f_fill_lower < f_lower:
            logger.info(
                f'Lower bound {f_fill_lower} in `fill_bounds` is '
                f'smaller than the signals smallest frequency {f_lower}'
                '. Please be aware that this function does nothing to '
                'change that, i.e. no padding is applied.'
            )
        else:
            lower_number_to_fill = int(np.ceil((f_fill_lower - f_lower) / signal.df))
            signal[:lower_number_to_fill].fill(fill_val)

    if (f_fill_upper := fill_bounds[1]) is not None:
        f_fill_upper = _q_convert(
            f_fill_upper, frequ_unit, 'f_fill_upper', 'signal.frequencies'
        )
        if f_fill_upper > f_upper:
            logger.info(
                f'Upper bound {f_fill_upper} in `fill_bounds` is larger'
                f' than the signals end frequency {f_upper}. Please be'
                ' aware that this function does nothing to change that,'
                ' i.e. no padding is applied.'
            )
        else:
            upper_number_to_fill = int(np.ceil((f_upper - f_fill_upper) / signal.df))
            signal[signal.size - upper_number_to_fill :].fill(fill_val)

    return signal


def get_signal_at_target_df(
    signal: FrequencySeries, df: float | u.Quantity, full_metadata: bool = True
) -> FrequencySeries:
    """
    Return :code:`signal` with required frequency spacing :code:`df`.
    This is either done by interpolating or by copying.

    This functions main purpose is to get equal frequency spacing
    before calculating an inner product.

    Parameters
    ----------
    signal : ~gwpy.frequencyseries.FrequencySeries
        Signal to be interpolated.
    df : float or ~astropy.units.Quantity
        Target frequency spacing to evaluate :code:`signal` on.
    full_metadata : bool, optional, default = True
        If True, all metadata of the FrequencySeries will be copied.
        If False, only values, unit and frequencies are copied (all
        other metadata like name, epoch are discarded).

    Returns
    -------
    ~gwpy.frequencyseries.FrequencySeries
        Signal with desired resolution.

    Notes
    -----
    The option :code:`full_metadata` is motivated by the fact that
    copying the metadata (in particular the epoch) goes along with a
    notable slowdown of copying. This is not desirable in applications
    where speed matters and metadata is not needed (for example in the
    inner product from :code:`~gw_signal_tools.waveform.inner_product`).
    """
    if np.isclose(signal.df, df, atol=0.0, rtol=0.01):
        if full_metadata:
            return signal.copy()
        else:
            # -- Essentially custom copy of properties needed in inner_product
            return FrequencySeries(
                signal.value, unit=signal.unit, frequencies=signal.frequencies
            )
    else:
        if full_metadata:
            return signal.interpolate(df.value)
        else:
            return FrequencySeries(
                signal.interpolate(df.value),
                epoch=signal.epoch,
                name=signal.name,
                channel=signal.channel,
            )


def get_signal_at_target_frequs(
    signal: FrequencySeries,
    target_frequencies: np.ndarray | u.Quantity,
    fill_val: float | u.Quantity = np.nan,
    fill_bounds: Optional[tuple[float, float] | tuple[u.Quantity, u.Quantity]] = None,
) -> FrequencySeries:
    """
    Interpolate and pad input :code:`signal` so that it spans the
    frequency interval given by :code:`target_frequencies`, while
    potentially being filled with a specific value outside of the
    interval given by :code:`fill_bounds`.

    This functions main purpose is to get equal frequency spacing
    before calculating an inner product.

    Parameters
    ----------
    signal : FrequencySeries
        Signal to be interpolated.
    target_frequencies : ~numpy.array or ~astropy.units.Quantity
        Frequency samples to evaluate :code:`signal` in.
    fill_val : float or ~astropy.units.Quantity, optional, default = ~numpy.nan
        Value to fill :code:`signal` with in case
        :code:`target_frequencies` contains signals outside its
        frequency band.

        If it is an astropy ``Quantity``, it must have units compatible with
        :code:`signal.unit`.
    fill_bounds : ~numpy.array or ~astropy.units.Quantity, optional, default = None
        In case only a certain region inside of
        :code:`target_frequencies` is supposed to not (!) be filled with
        :code:`fill_val`, the boundaries of this region can be specified
        here. Must have length 2 if not None.

    Returns
    -------
    ~gwpy.frequencyseries.FrequencySeries
        Input signal in required format.

    Raises
    ------
    ValueError
        If :code:`fill_val.unit` is incompatible with
        :code:`signal.unit`.

    See Also
    --------
    numpy.interp :
        Routine that performs interpolation and padding.
    gw_signal_tools.waveform.utils.restrict_f_range :
        Filling routine used.
    """
    target_frequencies = _q_convert(
        target_frequencies,
        signal.frequencies.unit,
        'target_frequencies',
        'signal.frequencies',
    )

    fill_val = _q_convert(fill_val, signal.unit, 'fill_val', 'signal')

    # -- Actual computations
    if signal.frequencies.size == target_frequencies.size and allclose_quantity(
        signal.frequencies, target_frequencies, atol=0.5 * signal.df.value, rtol=0.00
    ):
        out = FrequencySeries(
            signal.value, unit=signal.unit, frequencies=signal.frequencies
        )
    else:
        out = FrequencySeries(
            np.interp(
                target_frequencies,
                signal.frequencies,
                signal,
                left=fill_val.value,
                right=fill_val.value,
            ),
            unit=signal.unit,
            frequencies=target_frequencies,
        )

    if fill_bounds is not None:
        out = fill_f_range(out, fill_val=fill_val, fill_bounds=fill_bounds)

    return out


# -- Wrapper functions for strain generation ----------------------------------
_CORRECT_H_UNIT_TIME: u.Unit = u.strain
_CORRECT_H_UNIT_FREQU: u.Unit = u.strain * u.s
# -- Can be set to 1 for easy tests omitting units


def get_strain(
    params: dict[str, float | u.Quantity],
    domain: Literal['time', 'frequency'],
    generator: GravitationalWaveGenerator,
    mode: Optional[Literal['plus', 'cross', 'mixed']] = None,
) -> FrequencySeries | TimeSeries:
    """
    Wrapper function that allows to generate various types of
    gravitational wave strain.

    Parameters
    ----------
    params : dict[str, float or ~astropy.units.Quantity]
        Parameters to use for waveform generation. Is passed straight to
        :code:`~lalsimulation.gwsignal.core.waveform.GenerateTDWaveform`
        or :code: `~lalsimulation.gwsignal.core.waveform.
        GenerateFDWaveform`, depending on the value of :code:`domain`.

        Moreover, extrinsic parameters as accepted by
        :code:`~lalsimulation.gwsignal.core.gw.
        GravitationalWavePolarizations.strain` can be passed in the same
        dictionary. If none of them are given, no projection on a
        detector is performed and instead, the output is generated based
        on the given :code:`mode`.
    domain : Literal['time', 'frequency']
        Determines domain that waveform is generated in.
    generator : lalsimulation.gwsignal.core.waveform.GravitationalWaveGenerator
        Instance of :code:`~lalsimulation.gwsignal.core.waveform.
        GravitationalWaveGenerator` class (or a subclass thereof) that
        can be called for waveform generation.
    mode : Literal['plus', 'cross', 'mixed'], optional, default = None
        If output is not projected on a detector, this argument
        determines which strain is returned. Can be :code:`'plus'` (only
        plus polarization is returned), :code:`'cross'` (only cross
        polarization is returned) or :code:`'mixed'` (combination
        :math:`h = h_+ - i h_{\\cross}` is returned).

    Returns
    -------
    ~gwpy.timeseries.TimeSeries or ~gwpy.frequencyseries.FrequencySeries
        Gravitational wave strain.
    """
    # TODO: remove temp_factor once correct version is in lal release
    if domain == 'time':
        generator_func = wfm.GenerateTDWaveform
        temp_factor = _CORRECT_H_UNIT_TIME
    elif domain == 'frequency':
        generator_func = wfm.GenerateFDWaveform
        temp_factor = _CORRECT_H_UNIT_FREQU
    else:
        raise ValueError('Invalid domain, select either `\'time\'` or `\'frequency\'`.')

    expected_extr_params = ['det', 'ra', 'dec', 'psi', 'tgps']
    # extr_params_mask = np.isin(params.keys(), expected_extr_params, assume_unique=True)
    extr_params_mask = [param in params for param in expected_extr_params]
    if np.any(extr_params_mask):
        if not np.all(extr_params_mask):
            raise ValueError(
                'Need complete set of extrinsic parameters: '
                + f'{expected_extr_params}'
            )

        return_detector_output = True
        intrinsic_params = params.copy()
        extrinsic_params = {}

        for param in expected_extr_params:
            extrinsic_params[param] = intrinsic_params.pop(param)

        # TODO: check if copy is less efficient than looping over params
        # and putting in intrinsic_params or extrinsic_params using .get
    else:
        return_detector_output = False
        intrinsic_params = params

    if mode is None:
        mode = 'plus'
    else:
        if return_detector_output:
            logger.info(
                '`mode` argument has been set, but is ignored because '
                'extrinsic parameters have been passed.'
            )

    if return_detector_output:
        return (
            generator_func(intrinsic_params, generator).strain(**extrinsic_params)
            * temp_factor
        )
    else:
        match mode:
            case 'plus':
                return generator_func(intrinsic_params, generator)[0] * temp_factor
            case 'cross':
                return generator_func(intrinsic_params, generator)[1] * temp_factor
            case 'mixed':
                hp, hc = generator_func(intrinsic_params, generator)

                # -- Note: we choose to construct strain according to
                # -- the LALconvention, i.e. as h_+ + i * h_x and not
                # -- according to h_+ - i * h_x

                if domain == 'time':
                    return (hp + 1.0j * hc) * temp_factor
                else:
                    # -- Need negative Fourier components as well
                    return (
                        FrequencySeries(
                            np.flip((np.conjugate(hp) + 1.0j * np.conjugate(hc))[1:]),
                            f0=-hp.frequencies[-1],
                            df=hp.df,
                        ).append(hp + 1.0j * hc, inplace=True)
                        * temp_factor
                    )
            case _:
                raise ValueError('Invalid `mode`.')


def get_wf_generator(
    approximant: str,
    domain: Literal['frequency', 'time'] = 'frequency',
    cache: Optional[bool] = None,
    *args,
    **kwargs,
) -> WFGen:
    """
    Generates a function that can serve as a convenient waveform
    generator since its only input is a parameter dictionary.

    The returned function fulfils the requirements of the
    :code:`wf_generator` argument of a ``~gw_signal_tools.fisher.
    FisherMatrix``.

    Parameters
    ----------
    approximant : str
        Name of a waveform model that is accepted by the
        ``~lalsimulation.gwsignal.core.waveform.
        LALCompactBinaryCoalescenceGenerator`` class.
    domain : Literal['frequency', 'time'], optional, default = 'frequency'
        String representing the domain where the Fisher matrix is
        computed. Accepted values are :code:`'frequency'` and
        :code:`'time'`.
    cache : boolean, optional, default = None
        Parameter that controls whether or not the returned function is
        capable of waveform caching. If None, the current setting from
        the `~gw_signal_tools.caching` module is taken. If true, caching
        is enabled, else it is not.
    args, kwargs :
        All other arguments are passed on to `get_strain`.

    Returns
    -------
    ~gw_signal_tools.types.WFGen
        Function that takes dicionary of waveform parameters as
        input and produces a waveform (stored in a GWPy ``TimeSeries``
        or ``FrequencySeries``). Can, for example, be used as input
        to :code:`wf_generator` argument during initialization of a
        ``FisherMatrix``.

    See Also
    --------
    gw_signal_tools.waveform_utils.get_strain :
        Function that is wrapped here. All arguments provided in
        addition to the mandatory ones are passed to this function
        (just like :code:`domain` is as well).
    lalsimulation.gwsignal.gwsignal_get_waveform_generator :
        Function used to get a generator from :code:`approximant`. This
        is passed to the :code:`generator` argument of
        :code:`get_strain`.
    """
    generator = gwsignal_get_waveform_generator(approximant)

    def wf_generator(wf_params):
        return get_strain(wf_params, domain, generator, *args, **kwargs)

    if cache is None:
        # -- Do whatever current default is
        from ..caching import cache_func

        return cache_func(wf_generator)
    elif cache:
        from ..caching import _cache

        return _cache(wf_generator)
    else:
        return wf_generator


def apply_time_phase_shift(
    wf: FrequencySeries,
    time: u.Quantity,
    phase: u.Quantity,
) -> FrequencySeries:
    r"""
    Apply global time and phase shift to a frequency domain signal, i.e.
    multiply with :math:`\exp(i \cdot phase - i \cdot 2 \pi \cdot f \cdot time)`.
    """
    if (time.value == 0.0) and (phase.value == 0.0):
        return wf  # Shortcut to avoid operations
    else:
        return wf * np.exp(-2.0j * np.pi * wf.frequencies * time + 1.0j * phase)


def time_phase_wrapper(wf_gen: FDWFGen) -> FDWFGen:
    """
    Given a waveform generator, return a generator that accepts `'time'`
    and `'phase'` as keyword arguments for global time, phase shifts.
    """

    def new_wf_gen(params):
        if ('time' in params) or ('phase' in params):
            time = params.pop('time', 0.0 * u.s)
            phase = params.pop('phase', 0.0 * u.rad)
            wf = wf_gen(params)
            params |= {'time': time, 'phase': phase}
            # -- By doing this, we to avoid making a copy of params

            return apply_time_phase_shift(wf, time, phase)
        else:
            # -- Without this else case, we would add parameters time,
            # -- phase to a dictionary that did not have them initially!
            return wf_gen(params)

    return new_wf_gen
