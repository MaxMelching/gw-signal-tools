# -- Standard Lib Imports
from typing import Optional, Literal, Sequence

# -- Third Party Imports
import numpy as np
import astropy.units as u
from gwpy.timeseries import TimeSeries
from gwpy.frequencyseries import FrequencySeries
from gwpy.types import Index, Series
from lalsimulation.gwsignal import (
    gwsignal_get_waveform_generator,
    GravitationalWaveGenerator,
)
import lalsimulation.gwsignal.core.waveform as wfm

# -- Local Package Imports
from ..logging import logger
from ..test_utils import allclose_quantity
from ._error_helpers import _q_convert
from ..types import WFGen, FDWFGen


__all__ = (
    'pad_to_dx',
    'adjust_x_range',
    'fill_x_range',
    'signal_at_dx',
    'signal_at_xindex',
    'get_strain',
    'get_wf_generator',
    'apply_time_phase_shift',
    'time_phase_wrapper',
)

__doc__ = """
Waveform helpers for work with waveforms generated by gwsignal.
"""


# -- Inner Product Helpers ----------------------------------------------------
def pad_to_dx(
    signal: Series,
    dx: float | u.Quantity,
    where: Literal['start', 'end'] = 'start',
) -> Series:
    """
    Pads :code:`signal` with zeros after its end until a Fourier
    transform (or inverse Fourier transform) of it has the desired
    resolution of :code:`dx`. If the resolution is already at the
    required level, it does not nothing (i.e. this function is not
    suited for getting a smaller spacings dx, which would require
    cropping of :code:`signal`, which in turn would potentially cut off
    important information from it; to do this, use
    :code:`Series.interpolate` on the result of the transformation of
    :code:`signal` instead).

    Parameters
    ----------
    signal : ~gwpy.types.Series
        Signal that will be padded.
    dx : float or ~astropy.units.Quantity
        Desired resolution after transformation.
    where : Literal['start', 'end'], optional, default = 'start'
        Determines if zeros are prepended or appended to the signal.
        Note that this may have an impact on how the FT of `signal`
        comes out to be in case it is a ``TimeSeries``, since its
        starting time might be changed (relevant for the `'unwrap'`
        convention).

    Returns
    -------
    ~gwpy.types.Series
        Padded signal, still in the same domain as the input.
    """
    # -- Handle units
    xunit = 1.0 / signal.xunit
    dx = _q_convert(dx, xunit, 'dx', 'signal.xindex')

    # -- Check whether padding is required or current df is sufficient
    dx_transf_current = 1.0 / (signal.size * signal.dx)
    if dx_transf_current > dx:
        target_sample_number = int(np.ceil(1.0 / (signal.dx * dx)))
        number_to_append = target_sample_number - signal.size

        if where == 'start':
            return type(signal)(
                np.zeros(number_to_append),
                unit=signal.unit,
                x0=signal.x0 - number_to_append * signal.dx,
                dx=signal.dx,
                dtype=signal.dtype,
            ).append(signal)
        elif where == 'end':
            return signal.append(
                type(signal)(
                    np.zeros(number_to_append),
                    unit=signal.unit,
                    x0=signal.xindex[-1] + signal.dx,
                    dx=signal.dx,
                    dtype=signal.dtype,
                ),
                inplace=False,
            )
        else:
            raise ValueError(f"Invalid value {where} given for 'where'.")
    else:
        return signal


def adjust_x_range(
    signal: Series,
    x_range: Optional[Sequence[float | u.Quantity]] = None,
    fill_val: float | u.Quantity = 0.0,
    fill_range: Optional[Sequence[float | u.Quantity]] = None,
    copy: bool = True,
) -> Series:
    """
    Pad :code:'signal' to xindex values specified by :code:`x_range`,
    while potentially setting its values in the interval
    :code:`fill_range` to a fixed value. Note that this function can
    both extend and restrict the range of :code:`signal.xindex`,
    depending on the given :code:`x_range`.

    This function does not support signals that are unevenly spaced if
    padding is required (i.e. if :code:`x_range` is wider than
    :code:`signal.xindex`).

    Parameters
    ----------
    signal : ~gwpy.types.Series
        Signal to be restricted.
    x_range : Sequence[float or ~astropy.units.Quantity], optional, default = None
        Two-member sequence specifying lower and upper xindex bounds of
        the returned signal. Based on this value, :code:`signal` will
        either be padded with :code:`fill_val` or trimmed.

        Main usecase is preparation for an inverse Fourier
        transformation, where certain frequency ranges are required.
    fill_val : float or ~astropy.units.Quantity, optional, default = 0.0
        Value that will be used to fill :code:`signal` outside of
        :code:`x_range`.
    fill_range : Sequence[float or ~astropy.units.Quantity], optional, default = None
        Two-member sequence specifying lower and upper xindex bounds of
        the interval outside of which the returned signal is filled with
        :code:`fill_val`.
    copy : bool, optional, default = True
        Determines if the input signal is copied before performing
        operations or not. Note that not all of them are (can be)
        performed inplace, so setting copy to False does still not mean
        the output signal will be equal to the input after calling the
        function.

    Returns
    -------
    ~gwpy.types.Series
        Copy of signal where values outside of :code:`x_range` have been
        changed. If the interval defined by :code:`x_range` is larger
        than the one spanned by :code:`signal.xindex`, no entry will be
        changed. Note that this function maintains the input type, i.e.
        if a subclass of :code:``Series`` (like a
        :code:``FrequencySeries``) is given, the output will have the
        same type.

    Raises
    ------
    ValueError
        If :code:`x_range`, :code:`fill_range` do not contain exactly
        two elements.
    """
    assert isinstance(signal, Series), (
        '`signal` has to be a GWpy ``Series`` or a subclass thereof.'
    )

    _copied = False

    # -- Handling x_range
    xunit = signal.xunit

    if x_range is None:
        x_range = (None, None)  # Needed below
        x_lower = signal.xindex[0]
        x_upper = signal.xindex[-1]
    elif len(x_range) != 2:
        raise ValueError(
            '`x_range` must be None or contain one lower and one upper bound.'
        )
    else:
        x_lower = x_range[0] if x_range[0] is not None else signal.xindex[0]
        x_upper = x_range[1] if x_range[1] is not None else signal.xindex[-1]

        x_lower = _q_convert(x_lower, xunit, 'x_lower', 'signal.xindex')
        x_upper = _q_convert(x_upper, xunit, 'x_upper', 'signal.xindex')

        # -- Following test is taken from GWpy.Series.crop
        try:
            signal.dx
        except AttributeError:
            _regular = False
        else:
            _regular = True

        # -- Handling fill_val
        signal_unit = signal.unit
        fill_val = _q_convert(fill_val, signal_unit, 'fill_val', 'signal')

        # -- Padding/trimming
        if not _regular:
            if (x_lower < signal.x0) or (x_upper > signal.xindex[-1]):
                # if (x_lower < signal.x0 - 0.5*signal.dx) or (x_upper > signal.xindex[-1] + 0.5*signal.dx):  # Has no dx...
                # if (x_lower < signal.x0 - 0.5*(signal.xindex[1] - signal.xindex[0])) or (x_upper > signal.xindex[-1] + 0.5*(signal.xindex[-1] - signal.xindex[-2])):
                # -- Keep as backup, in case this shows up as issue again
                raise ValueError(
                    'The padding features of `adjust_x_range` only works '
                    'for equally sampled signals.'
                )

            lower_number = (
                np.searchsorted(
                    signal.xindex.value,
                    x_lower,
                    side='right',
                )
                - 1
            )

            upper_number = (
                np.searchsorted(
                    signal.xindex.value,
                    x_upper,
                    side='left',
                )
                + 1
            )
            # -- GWpy uses side='left' without subtraction for both cases,
            # -- but we found better results for this here. Is likely
            # -- related to the fact that we want to KEEP elements at
            # -- lower_number and upper_number, not access them (which
            # -- is what searchsorted does).

            signal = signal[lower_number:upper_number]
        else:
            lower_number = abs(int(np.floor((x_lower - signal.x0) / signal.dx)))
            # -- Use of np.floor means: if x_lower=42 and we have samples at
            # -- 41.9, 42.6, then we include 41.9. np.ceil would exclude

            if x_lower < signal.x0:  # Equivalent to lower_number > 0
                signal = type(signal)(
                    np.full(lower_number, fill_value=fill_val.value),
                    unit=signal_unit,
                    # x0=x_lower,
                    x0=signal.x0 - lower_number * signal.dx,
                    dx=signal.dx,
                    name=signal.name,
                    epoch=signal.epoch,
                    channel=signal.channel,
                    dtype=signal.dtype,
                ).append(signal, inplace=True, pad=fill_val.value)
                # -- Properties of first series are taken in append, thus need
                # -- to paste all necessary properties
                _copied = True
            elif x_lower > signal.x0:
                signal = signal[lower_number:]

            upper_number = abs(int(np.ceil((x_upper - signal.xindex[-1]) / signal.dx)))
            # -- Use of np.ceil means: if x_upper=42 and we have samples at
            # -- 41.9, 42.6, then we include 42.6. np.floor would exclude

            if x_upper > signal.xindex[-1]:  # Equivalent to upper_number > 0
                signal = signal.append(
                    type(signal)(
                        np.full(upper_number, fill_value=fill_val.value),
                        unit=signal_unit,
                        x0=signal.xindex[-1] + signal.dx,
                        dx=signal.dx,
                        dtype=signal.dtype,
                    ),
                    inplace=False,  # Otherwise error
                )
            elif x_upper < signal.xindex[-1]:
                signal = signal[: signal.size - upper_number]

    # -- Filling
    if fill_range is None:
        if copy and not _copied:
            return signal.copy()
        else:
            return signal

    elif len(fill_range) != 2:
        raise ValueError(
            '`fill_range` must be None or contain one lower and one upper bound.'
        )

    x_fill_lower = _q_convert(
        fill_range[0] if fill_range[0] is not None else x_lower,
        xunit,
        'fill_range[0]',
        'signal.xindex',
    )
    x_fill_upper = _q_convert(
        fill_range[1] if fill_range[1] is not None else x_upper,
        xunit,
        'fill_range[1]',
        'signal.xindex',
    )

    if x_fill_lower < x_lower:
        logger.info(
            f'Lower bound {x_fill_lower} in `fill_range` is smaller '
            f'than the signals lower xindex bound {x_lower}. Please be '
            'aware that this function does nothing to change that, i.e. '
            'no padding is applied (adjust `x_range` for that).'
        )

        x_fill_lower = x_lower

    if x_fill_upper > x_upper:
        logger.info(
            f'Upper bound {x_fill_upper} in `fill_range` is larger '
            f'than the signals upper xindex bound {x_upper}. Please be '
            'aware that this function does nothing to change that, i.e. '
            'no padding is applied (adjust `x_range` for that).'
        )

        x_fill_upper = x_upper

    # -- Check if fill_x_range will do something and copy if required
    if copy and not _copied:
        signal = signal.copy()

    signal = fill_x_range(signal, fill_val, (x_fill_lower, x_fill_upper), copy=False)

    return signal


def fill_x_range(
    signal: Series,
    fill_val: float | u.Quantity,
    fill_bounds: Sequence[float | u.Quantity],
    copy: bool = False,
) -> Series:
    """
    Fills :code:`signal` with :code:`fill_val` outside of interval
    provided in :code:`fill_range`.

    This function does support signals that are unevenly spaced.

    Parameters
    ----------
    signal : ~gwpy.types.Series
        Signal to be (potentially) filled.
    fill_val : float or ~astropy.units.Quantity
        Value to fill with.
    fill_bounds : Sequence[float or ~astropy.units.Quantity]
        Bounds of interval outside of which :code:`signal` is filled.
        Must have length 2, but members can be None to indicate that no
        filling shall be done on the respective end of the interval.
    copy : bool, optional, default = True
        Determines if the input signal is copied before performing
        operations or not.

    Returns
    -------
    ~gwpy.types.Series
        Edited input :code:`signal`.

    Raises
    ------
    ValueError
        If :code:`fill_bounds` is does not have two elements.
    ValueError
        If members of :code:`fill_bounds` have xunits that are
        incompatible with the :code:`signal.xunit`.
    """
    assert isinstance(signal, Series), (
        '`signal` has to be a GWpy ``Series`` or a subclass thereof.'
    )

    if copy:
        signal = signal.copy()

    fill_val = _q_convert(fill_val, signal.unit, 'fill_val', 'signal')

    # -- Following test is taken from GWpy.Series.crop
    try:
        signal.dx
    except AttributeError:
        _regular = False
    else:
        _regular = True

    xunit = signal.xunit
    x_lower, x_upper = signal.x0, signal.xindex[-1]

    if len(fill_bounds) != 2:
        raise ValueError('`fill_bounds` must contain one lower and one upper bound.')

    # -- Actual filling
    if (x_fill_lower := fill_bounds[0]) is not None:
        x_fill_lower = _q_convert(x_fill_lower, xunit, 'x_fill_lower', 'signal.xindex')
        if x_fill_lower < x_lower:
            logger.info(
                f'Lower bound {x_fill_lower} in `fill_bounds` is '
                f'smaller than the signals lower xindex bound {x_lower}. '
                'Please be aware that this function does nothing to '
                'change that, i.e. no padding is applied.'
            )
        else:
            if _regular:
                lower_number_to_fill = int(
                    np.ceil((x_fill_lower - x_lower) / signal.dx)
                )
            else:
                lower_number_to_fill = np.searchsorted(
                    signal.xindex.value,
                    x_fill_lower,
                    side='left',
                )
            signal[:lower_number_to_fill].fill(fill_val)

    if (x_fill_upper := fill_bounds[1]) is not None:
        x_fill_upper = _q_convert(x_fill_upper, xunit, 'x_fill_upper', 'signal.xindex')
        if x_fill_upper > x_upper:
            logger.info(
                f'Upper bound {x_fill_upper} in `fill_bounds` is larger '
                f'than the signals end upper xindex bound {x_upper}. '
                'Please be aware that this function does nothing to '
                'change that, i.e. no padding is applied.'
            )
        else:
            if _regular:
                upper_number_to_fill = signal.size - int(
                    np.ceil((x_upper - x_fill_upper) / signal.dx)
                )
            else:
                upper_number_to_fill = np.searchsorted(
                    signal.xindex.value,
                    x_fill_upper,
                    side='left',
                )
            signal[upper_number_to_fill:].fill(fill_val)

    return signal


def signal_at_dx(
    signal: Series, dx: float | u.Quantity, full_metadata: bool = True
) -> Series:
    """
    Return :code:`signal` with required spacing :code:`dx`.
    This is either done by interpolating or by copying.

    This functions main purpose is to get equal frequency spacing
    before calculating an inner product.

    Parameters
    ----------
    signal : ~gwpy.types.Series
        Signal to be interpolated.
    df : float or ~astropy.units.Quantity
        Target spacing to evaluate :code:`signal` on.
    full_metadata : bool, optional, default = True
        If True, all metadata of the :code:``Series`` will be copied.
        If False, only values, unit and xunit are copied (all other
        metadata like name, epoch are discarded).

    Returns
    -------
    ~gwpy.types.Series
        Signal with desired resolution.

    Notes
    -----
    The option :code:`full_metadata` is motivated by the fact that
    copying the metadata (in particular the epoch) goes along with a
    notable slowdown of copying. This is not desirable in applications
    where speed matters and metadata is not needed (for example in the
    inner product from :code:`~gw_signal_tools.waveform.inner_product`).
    """
    assert isinstance(signal, Series), (
        '`signal` has to be a GWpy ``Series`` or a subclass thereof.'
    )

    # -- Initially this was an indepedent function, but now it can be
    # -- redefined in terms of the more general function
    # -- signal_at_xindex. Still, it is somewhat useful and thus kept.

    new_index = (
        np.arange(
            signal.x0.to_value(signal.xunit),
            signal.xindex[-1].to_value(signal.xunit),
            step=_q_convert(dx, signal.xunit, 'dx', 'signal').value,
        )
        << signal.xunit
    )

    return signal_at_xindex(signal, new_index, full_metadata=full_metadata)


def signal_at_xindex(
    signal: Series,
    target_xindex: np.ndarray | u.Quantity | Index,
    fill_val: float | u.Quantity = None,
    fill_bounds: Optional[Sequence[float | u.Quantity]] = None,
    full_metadata: bool = False,
) -> FrequencySeries:
    """
    Interpolate and pad input :code:`signal` so that it spans the
    frequency interval given by :code:`target_frequencies`, while
    potentially being filled with a specific value outside of the
    interval given by :code:`fill_bounds`.

    This functions main purpose is to get equal frequency spacing
    before calculating an inner product.

    Parameters
    ----------
    signal : ~gwpy.types.Series
        Signal to be interpolated.
    target_xindex : ~numpy.array or ~astropy.units.Quantity or ~gwpy.types.Index
        Samples to evaluate :code:`signal` in.
    fill_val : float or ~astropy.units.Quantity, optional, default = None
        Value to fill :code:`signal` with in case
        :code:`target_frequencies` contains signals outside its
        frequency band. If it is an astropy ``Quantity``, it must have
        units compatible with :code:`signal.unit`.

        If None (the default), the decision is passed on to the function
        that is used for interpolation, i.e. `~numpy.interp`.
    fill_bounds : Sequence[float or u.Quantity], optional, default = None
        In case only a certain region inside of
        :code:`target_xindex` is supposed to not (!) be filled with
        :code:`fill_val`, the boundaries of this region can be specified
        here. Must have length 2 if not None.
    full_metadata : bool, optional, default = True
        If True, all metadata of the :code:``Series`` will be copied.
        If False, only values, unit and xunit are copied (all other
        metadata like name, epoch are discarded).

    Returns
    -------
    ~gwpy.types.Series
        Input signal in required format.

    Raises
    ------
    ValueError
        If :code:`fill_val.unit` is incompatible with
        :code:`signal.unit`.

    See Also
    --------
    numpy.interp :
        Routine that performs interpolation and padding.
    gw_signal_tools.waveform.fill_x_range :
        Filling routine used.
    """
    assert isinstance(signal, Series), (
        '`signal` has to be a GWpy ``Series`` or a subclass thereof.'
    )

    target_xindex = _q_convert(
        target_xindex,
        signal.xunit,
        'target_xindex',
        'signal.xindex',
    )

    if fill_val is not None:
        fill_val = _q_convert(fill_val, signal.unit, 'fill_val', 'signal')

    # -- Actual computations
    if signal.xindex.size == target_xindex.size and (
        allclose_quantity(
            signal.xindex,
            target_xindex,
            atol=0.5 * signal.dx.to_value(signal.xunit),
            rtol=0.0,
        )
        if hasattr(signal, 'dx')
        else np.all(
            abs(signal.xindex - target_xindex)[:-1] <= 0.5 * abs(np.diff(signal.xindex))
        )
    ):
        # -- Basically custom copy, no interpolation required though
        out = type(signal)(signal.value, unit=signal.unit, xindex=signal.xindex)
    else:
        out = np.interp(
            target_xindex,
            signal.xindex,
            signal,
            left=fill_val.to_value(signal.unit) if fill_val is not None else None,
            right=fill_val.to_value(signal.unit) if fill_val is not None else None,
        ).view(type(signal))
        out.xindex = target_xindex

    if fill_bounds is not None:
        out = fill_x_range(out, fill_val=fill_val, fill_bounds=fill_bounds, copy=False)

    if full_metadata:
        # -- Copy everything from signal._metadata_slots
        out.__metadata_finalize__(signal, force=False)

    return out


# -- Wrapper functions for strain generation ----------------------------------
_CORRECT_H_UNIT_TIME: u.Unit = u.strain
_CORRECT_H_UNIT_FREQU: u.Unit = u.strain * u.s
# -- Can be set to 1 for easy tests omitting units


def get_strain(
    params: dict[str, float | u.Quantity],
    domain: Literal['time', 'frequency'],
    generator: GravitationalWaveGenerator,
    mode: Optional[Literal['plus', 'cross', 'mixed']] = None,
) -> FrequencySeries | TimeSeries:
    """
    Wrapper function that allows to generate various types of
    gravitational wave strain.

    Parameters
    ----------
    params : dict[str, float or ~astropy.units.Quantity]
        Parameters to use for waveform generation. Is passed straight to
        :code:`~lalsimulation.gwsignal.core.waveform.GenerateTDWaveform`
        or :code: `~lalsimulation.gwsignal.core.waveform.
        GenerateFDWaveform`, depending on the value of :code:`domain`.

        Moreover, extrinsic parameters as accepted by
        :code:`~lalsimulation.gwsignal.core.gw.
        GravitationalWavePolarizations.strain` can be passed in the same
        dictionary. If none of them are given, no projection on a
        detector is performed and instead, the output is generated based
        on the given :code:`mode`.
    domain : Literal['time', 'frequency']
        Determines domain that waveform is generated in.
    generator : ~lalsimulation.gwsignal.core.waveform.GravitationalWaveGenerator
        Instance of :code:`~lalsimulation.gwsignal.core.waveform.
        GravitationalWaveGenerator` class (or a subclass thereof) that
        can be called for waveform generation.
    mode : Literal['plus', 'cross', 'mixed'], optional, default = None
        If output is not projected on a detector, this argument
        determines which strain is returned. Can be :code:`'plus'` (only
        plus polarization is returned), :code:`'cross'` (only cross
        polarization is returned) or :code:`'mixed'` (combination
        :math:`h = h_+ - i h_{\\cross}` is returned).

    Returns
    -------
    ~gwpy.timeseries.TimeSeries or ~gwpy.frequencyseries.FrequencySeries
        Gravitational wave strain.
    """
    # TODO: remove temp_factor once correct version is in lal release
    if domain == 'time':
        generator_func = wfm.GenerateTDWaveform
        temp_factor = _CORRECT_H_UNIT_TIME
    elif domain == 'frequency':
        generator_func = wfm.GenerateFDWaveform
        temp_factor = _CORRECT_H_UNIT_FREQU
    else:
        raise ValueError("Invalid domain, select either `'time'` or `'frequency'`.")

    expected_extr_params = ['det', 'ra', 'dec', 'psi', 'tgps']
    # extr_params_mask = np.isin(params.keys(), expected_extr_params, assume_unique=True)
    extr_params_mask = [param in params for param in expected_extr_params]
    if np.any(extr_params_mask):
        if not np.all(extr_params_mask):
            raise ValueError(
                'Need complete set of extrinsic parameters: '
                + f'{expected_extr_params}'
            )

        return_detector_output = True
        intrinsic_params = params.copy()
        extrinsic_params = {}

        for param in expected_extr_params:
            extrinsic_params[param] = intrinsic_params.pop(param)

        # TODO: check if copy is less efficient than looping over params
        # and putting in intrinsic_params or extrinsic_params using .get
    else:
        return_detector_output = False
        intrinsic_params = params

    if mode is None:
        mode = 'plus'
    else:
        if return_detector_output:
            logger.info(
                '`mode` argument has been set, but is ignored because '
                'extrinsic parameters have been passed.'
            )

    if return_detector_output:
        return (
            generator_func(intrinsic_params, generator).strain(**extrinsic_params)
            * temp_factor
        )
    else:
        match mode:
            case 'plus':
                return generator_func(intrinsic_params, generator)[0] * temp_factor
            case 'cross':
                return generator_func(intrinsic_params, generator)[1] * temp_factor
            case 'mixed':
                hp, hc = generator_func(intrinsic_params, generator)

                # -- Note: we choose to construct strain according to
                # -- the LALconvention, i.e. as h_+ + i * h_x and not
                # -- according to h_+ - i * h_x

                if domain == 'time':
                    return (hp + 1.0j * hc) * temp_factor
                else:
                    # -- Need negative Fourier components as well
                    return (
                        FrequencySeries(
                            np.flip((np.conjugate(hp) + 1.0j * np.conjugate(hc))[1:]),
                            f0=-hp.frequencies[-1],
                            df=hp.df,
                        ).append(hp + 1.0j * hc, inplace=True)
                        * temp_factor
                    )
            case _:
                raise ValueError('Invalid `mode`.')


def get_wf_generator(
    approximant: str,
    domain: Literal['frequency', 'time'] = 'frequency',
    cache: Optional[bool] = None,
    *args,
    **kwargs,
) -> WFGen:
    """
    Generates a function that can serve as a convenient waveform
    generator since its only input is a parameter dictionary.

    The returned function fulfils the requirements of the
    :code:`wf_generator` argument of a ``~gw_signal_tools.fisher.
    FisherMatrix``.

    Parameters
    ----------
    approximant : str
        Name of a waveform model that is accepted by the
        ``~lalsimulation.gwsignal.core.waveform.
        LALCompactBinaryCoalescenceGenerator`` class.
    domain : Literal['frequency', 'time'], optional, default = 'frequency'
        String representing the domain where the Fisher matrix is
        computed. Accepted values are :code:`'frequency'` and
        :code:`'time'`.
    cache : boolean, optional, default = None
        Parameter that controls whether or not the returned function is
        capable of waveform caching. If None, the current setting from
        the `~gw_signal_tools.caching` module is taken. If true, caching
        is enabled, else it is not.
    args, kwargs :
        All other arguments are passed on to `get_strain`.

    Returns
    -------
    ~gw_signal_tools.types.WFGen
        Function that takes dicionary of waveform parameters as
        input and produces a waveform (stored in a GWpy ``TimeSeries``
        or ``FrequencySeries``). Can, for example, be used as input
        to :code:`wf_generator` argument during initialization of a
        ``FisherMatrix``.

    See Also
    --------
    gw_signal_tools.waveform.get_strain :
        Function that is wrapped here. All arguments provided in
        addition to the mandatory ones are passed to this function
        (just like :code:`domain` is as well).
    lalsimulation.gwsignal.gwsignal_get_waveform_generator :
        Function used to get a generator from :code:`approximant`. This
        is passed to the :code:`generator` argument of
        :code:`get_strain`.
    """
    generator = gwsignal_get_waveform_generator(approximant)

    def wf_generator(wf_params):
        return get_strain(wf_params, domain, generator, *args, **kwargs)

    if cache is None:
        # -- Do whatever current default is
        from ..caching import cache_func

        return cache_func(wf_generator)
    elif cache:
        from ..caching import _cache

        return _cache(wf_generator)
    else:
        return wf_generator


def apply_time_phase_shift(
    wf: FrequencySeries,
    time: u.Quantity,
    phase: u.Quantity,
) -> FrequencySeries:
    r"""
    Apply global time and phase shift to a frequency domain signal, i.e.
    multiply with :math:`\exp(i \cdot phase - i \cdot 2 \pi \cdot f \cdot time)`.
    """
    if (time.value == 0.0) and (phase.value == 0.0):
        return wf  # Shortcut to avoid operations
    else:
        return wf * np.exp(-2.0j * np.pi * wf.frequencies * time + 1.0j * phase)


def time_phase_wrapper(wf_gen: FDWFGen) -> FDWFGen:
    """
    Given a waveform generator, return a generator that accepts `'time'`
    and `'phase'` as keyword arguments for global time, phase shifts.
    """

    def new_wf_gen(params):
        # -- General goal: avoid storing waveform after generation and
        # -- then pass on, this slows down significantly!
        # -- This is why we copy params instead of popping time+phase,
        # -- generating WF, and adding them again, much faster.
        if 'time' in params or 'phase' in params:
            _params = params.copy()
            time = _params.pop('time', 0.0)
            phase = _params.pop('phase', 0.0)

            if time == 0.0 and phase == 0.0:
                return wf_gen(_params)
            else:
                return apply_time_phase_shift(wf_gen(_params), time, phase)
        else:
            return wf_gen(params)

    return new_wf_gen
