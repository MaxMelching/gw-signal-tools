import numpy as np

from gwpy.timeseries import TimeSeries
from gwpy.frequencyseries import FrequencySeries
import astropy.units as u

from typing import Optional, Literal, Any
import logging



__doc__ = """
Waveform helpers for work with waveforms generated by gwsignal.
"""


# ---------- Fourier Transformation and Helpers ----------

def td_to_fd_waveform(signal: TimeSeries) -> FrequencySeries:
    """
    Transform given `signal` to Fourier domain. Note that the output is
    normalized to represent the continuous frequency components, not the
    discrete ones. Furthermore, a phase shift is applied to account for
    the starting of `signal`.

    Parameters
    ----------
    signal : ~gwpy.timeseries.TimeSeries
        Signal to be transformed.

    Returns
    -------
    out : ~gwpy.frequencyseries.FrequencySeries
        Transformed signal.

    See also
    --------
    numpy.fft.rfft : Fourier transformation routine used.
    """

    # Get Fourier coefficients and corresponding frequencies
    out = FrequencySeries(
        np.fft.rfft(signal) * signal.dx,  # Discrete -> continuous
        frequencies=np.fft.rfftfreq(signal.size, d=signal.dx.value) << 1 / signal.dx.unit,
        unit=signal.unit,
        name=('Fourier transform of '
              + signal.name if signal.name is not None else None),
        channel=signal.channel
    )
    
    # Account for non-zero starting time
    out *= np.exp(-1.j * 2 * np.pi * out.frequencies * signal.t0)

    # TODO: if input type is complex, do non-real fft
    # -> so maybe not using GWpy fft is better anyway. Template:
    # if isinstance(signal.dtype, np.dtypes.Complex128DType):
    # # Maybe use np.iscomplexobj?
    #     dft = ...
    #     # Don't forget fftshift!!! And adjust f0
    # # else:
    # elif isinstance(signal.dtype, np.dtypes.Float64DType):
    #     dft = ...
    # else:
    # print('Error)
    # 
    # Also set frequencies
    
    # out = FrequencySeries(dft, ...)
    
    return out


def restrict_f_range(
    signal: FrequencySeries,
    f_range: list[float] | list[u.Quantity],
    fill_val: float | u.Quantity = 0.0,
    pad_to_f_zero: bool = False,
    cut_upper: bool = False,
    copy: bool = True
) -> FrequencySeries:
    """
    Set frequency components of signal outside of f_range to fill_val.

    Parameters
    ----------
    signal : ~gwpy.frequencyseries.FrequencySeries
        Signal to be restricted.
    f_range : list[float] or list[~astropy.units.Quantity]
        Two-tuple specifying lower and upper frequency bounds that will
        be used as cutoffs.
    fill_val : float or ~astropy.units.Quantity, optional, default = 0.0
        Value that will be used to fill `signal` outside of `f_range`.
    pad_to_f_zero : bool, optional, default = False
        If true, signal is padded with `fill_val` to start at f=0.

        Convenient option if signal shall be prepared for inverse
        Fourier transformation, where start at f=0 is usually expected.
    cut_upper : bool, optional, default = False
        If true, signal will be cut off at upper frequency limit.

        Convenient in preparation for computations with multiple signals
        where equal frequency ranges might be needed.
    copy : bool, optional, default = True
        Determines if the input signal is copied before performing
        operations or not.

        Note that copying is done automatically in case `pad_to_f_zero`
        is `True` because this involves appending, an operation the
        input array has to be copied in any case.

    Returns
    -------
    ~gwpy.frequencyseries.FrequencySeries
        Copy of signal where values outside of `f_range` have been
        changed. If the interval defined by `f_range` is larger than the
        one spanned by `signal.frequencies`, no entry will be changed.

    Raises
    ------
    ValueError
        If `f_range` does not contain exactly two elements.
    """
    frequ_unit = signal.frequencies.unit

    if len(f_range) != 2:
        raise ValueError(
            '`f_range` must contain lower and upper frequency bounds.'
        )

    f_lower = f_range[0] if f_range[0] is not None else 0.0 * frequ_unit
    f_upper = f_range[1] if f_range[1] is not None else signal.frequencies[-1]
    # TODO: better handling if f_range[1] > signal.frequencies[-1], should give error

    try:
        f_lower = u.Quantity(f_lower, unit=frequ_unit)
    except u.UnitConversionError:
        raise ValueError(
            'Need consistent frequency units for `f_range` members'
            f' ({f_lower.unit}) and signals ({frequ_unit}).'
        )
    
    try:
        f_upper = u.Quantity(f_upper, unit=frequ_unit)
    except u.UnitConversionError:
        raise ValueError(
            'Need consistent frequency units for `f_range` members'
            f' ({f_upper.unit}) and signals ({frequ_unit}).'
        )


    # Sanity checks with frequencies
    if (f_lower < signal.f0) and not pad_to_f_zero:
        # Note: first condition fine if padding shall be done, thus second
        # condition after "and" is important
        logging.info(
            f'The `f_lower` provided is smaller than the signals smallest '
            'frequency. Please be aware that this function does not nothing '
            'to change that, i.e. no padding to this lower frequency is '
            'applied (can be changed by setting `pad_to_zero` to `True`).'
        )
    
    if f_upper > signal.frequencies[-1]:
        logging.info(
            f'The `f_upper` provided is higher than the signals highest '
            'frequency. Please be aware that this function does not nothing '
            'to change that, i.e. no padding to this higher frequency is '
            'applied (not the scope of this function).'
        )


    if pad_to_f_zero:# and (signal.f0 > signal.df):
        # Padding to zero frequency component shall be done and is needed
        number_to_append = int(signal.f0.value / signal.df.value)

        signal = FrequencySeries(
            np.zeros(number_to_append),
            unit=signal.unit,
            f0=0.0,
            df=signal.df,
            dtype=signal.dtype
        ).append(signal)
    elif copy:
        # Note that this is not separate if-condition because copying
        # happens automatically in append-operation in case above. Thus
        # making another copy would make no sense.
        signal = signal.copy()

    # Otherwise all operations are performed inplace


    # Now filling of all values outside of frequency range
    # and potentially cutting off some parts of the signal
    fill_val = u.Quantity(fill_val, unit=signal.unit)

    lower_number_to_discard = int(np.ceil((f_lower.value - signal.f0.value) / signal.df.value))
    signal[:lower_number_to_discard].fill(fill_val)

    if cut_upper and (f_upper < signal.frequencies[-1]):
        # If second condition is not True, no cropping can be performed
        signal = signal.crop(end=f_upper)
    else:
        upper_number_to_discard = signal.size -  int(np.ceil((signal.frequencies[-1].value - f_upper.value) / signal.df.value))
        signal[upper_number_to_discard:].fill(fill_val)

    return signal


def fd_to_td_waveform(
    signal: FrequencySeries,
    f_range: Optional[list[float] | list[u.Quantity]] = None
) -> TimeSeries:
    """
    Transform given `signal` to time domain. Note that the input is
    expected to be normalized according to `td_to_fd_waveform`, i.e. so
    that the components in `signal` are continuous frequency components.

    Parameters
    ----------
    signal : ~gwpy.frequencyseries.FrequencySeries
        Signal to be transformed
    f_range : list[float] or list[~astropy.units.Quantity], optional,
    default = None
        Range of frequency components to take into account. Is used as
        input for `restrict_f_range` function.

    Returns
    -------
    out : ~gwpy.timeseries.TimeSeries
        Transformed signal.

    Raises
    ------
    ValueError
        If `f_range` does not contain exactly two elements.

    See also
    --------
    numpy.fft.irfft : Inverse Fourier transformation routine used.
    """

    if f_range is not None:
        if len(f_range) != 2:
            raise ValueError(
                '`f_range` must contain lower and upper frequency bounds.'
            )

        signal = restrict_f_range(signal, f_range)
        

    # dt = 1 / (2 * signal.size * signal.df)  # Two because rfft has only half size
    dt = 1 / (2 * (signal.size - 1) * signal.df)
    # Note: 2*(n-1) follows normalization that happens according to the docs:
    # https://numpy.org/doc/stable/reference/generated/numpy.fft.irfft.html
    out = TimeSeries(
        np.fft.irfft(signal / dt),
        unit=signal.unit / dt.unit,
        # np.fft.irfft(signal / dt),
        # t0=0.0 * u.s,
        # dt=dt.to(u.s),  # Ensure unit is displayed in seconds, not 1/Hz
        t0=0.0 * dt.unit,
        dt=dt,  # Units might not be s, thus no use of .to()
        name=('Inverse Fourier transform of '
              + signal.name if signal.name is not None else None),
        channel=signal.channel
    )
    # Note: dividing by dt is necessary because irfft uses discrete
    # Fourier coefficients, but the input is expected to be continuous
    # (as this is true for the output of waveform generators in lal).
    # Equivalently, one could say that we first revert the numpy
    # normalization and then make the transition from continuous to
    # discrete Fourier coefficients by approximating the corresponding
    # integral (df comes in)


    # TODO: add possibility that ifft is done, based on value of f0


    # Handle wrap-around of signal
    # TODO: put this in separate function cyclic_shift?
    # TODO: once epoch is given for FreqSeries, no wrap-around should be
    # needed, right? Thus maybe use if-condition here and only roll if t0=0.0?
    # -> ah no, wrap-around would still occur, has to be kept in (maybe without shift then)
    number_to_roll = out.size * 7 // 8  # Value chosen, no deep meaning
    out = np.roll(out, shift=number_to_roll)

    # out.times -= out.times[number_to_roll]  # Equivalent to following
    out.shift(-7 / 8 * out.duration)  # Note: 7 / 8 * out.duration = out.times[number_to_roll]

    # TODO: make optional argument taper? TimeSeries has built-in function
    # .taper() to handle this
    # out = out.taper(duration=out.duration.value / 6.0)  # Default is side='leftright'
    # out = out.taper(duration=out.duration.value / 2.0, side='right')
    # out = out.taper(duration=out.duration.value / 5.0, side='right')

    # -> uhhhh, np.hanning(number_of_points) is nice; for other windows, see
    # https://numpy.org/doc/stable/reference/routines.window.html

    return out


def pad_to_get_target_df(
    signal: TimeSeries,
    df: float | u.Quantity
) -> TimeSeries:
    """
    Pads `signal` with zeros after its end until a fft of it has desired
    resolution of `df`. If the resolution is already at the required
    level, it does not nothing (i.e. this function is not suited for
    getting a smaller df, which would require cropping of the
    time-domain signal; to do this, `FrequencySeries.interpolate` can
    be applied to the Fourier transform instead).

    Parameters
    ----------
    signal : ~gwpy.timeseries.TimeSeries
        Signal that will be padded.
    df : float or ~astropy.units.Quantity
        Desired resolution in frequency domain.

    Returns
    -------
    padded_signal : ~gwpy.timeseries.TimeSeries
        Padded signal, still in time domain.
    """
    # Handle units
    frequ_unit = 1/signal.times.unit

    try:
        df = u.Quantity(df, unit=frequ_unit)
    except u.UnitConversionError:
        # Conversion only fails if df is already Quantity and has
        # non-matching unit, so we can assume that df.unit works
        raise ValueError(
            f'Need consistent frequency units for `df` ({df.unit}) and'
            f' signals ({frequ_unit}).'
        )


    # Compute what would be current df
    df_current = 1.0 / (signal.size * signal.dt)

    if df_current > df:
        target_sample_number = int(1.0 / (signal.dt * df))

        number_to_append = target_sample_number - signal.size

        padding_series = TimeSeries(
            np.zeros(number_to_append),
            unit=signal.unit,
            t0=signal.times[-1] + signal.dt,
            dt=signal.dt
        )

        padded_signal = signal.append(padding_series, inplace=False)
    else:
        # Nothing has to be done
        padded_signal = signal

    return padded_signal



# ---------- Plotting Routine with Labels etc ----------
# import matplotlib
# import matplotlib.pyplot as plt

# def plot_wf(
#     waveform: TimeSeries | FrequencySeries,
#     label: Optional[str] = None,
#     ax: Optional[matplotlib.axes.Axes] = None
# ) -> matplotlib.axes.Axes:
    
#     if ax is None:
#         ax = plt.gca()

#     ax.plot(waveform)


#     if isinstance(waveform, TimeSeries):
#         ax.set_xlabel(f'Times [{waveform.times.unit}]')
#         ax.set_ylabel(f'Strain [{waveform.unit}]')
#     elif isinstance(waveform, FrequencySeries):
#         ax.set_xlabel(f'Frequencies [{waveform.frequencies.unit}]')
#         ax.set_ylabel(f'Strain [{waveform.unit}]')


#     return ax
# Hmmmm, is this function really useful?



# ---------- Mass Rescaling ----------
    

# def scale_to_Mtotal(
#     waveform: FrequencySeries | TimeSeries,
#     total_mass: u.Quantity,
#     unit_sys: Optional[Literal['SI', 'cosmo', 'geom']] = None
# ) -> FrequencySeries | TimeSeries:
#     """
#     _summary_

#     Parameters
#     ----------
#     waveform : FrequencySeries | TimeSeries
#         Output will be in SI units.
#     total_mass : u.Quantity
#         _description_
#     unit_sys : Optional[Literal[&#39;SI&#39;, &#39;cosmo&#39;, &#39;geom&#39;]], optional
#         _description_, by default None

#     Returns
#     -------
#     FrequencySeries | TimeSeries
#         _description_

#     Raises
#     ------
#     ValueError
#         _description_
#     """
#     import astropy.constants as const  # TODO: check if import outside of function. Then also define constants outside

#     if unit_sys is None:
#         unit_sys = 'cosmo'

#     if unit_sys == 'cosmo':
#         total_mass = total_mass.to(u.Msun)
#     elif unit_sys == 'SI':
#         total_mass = total_mass.to(u.kg)
#     elif unit_sys == 'geom':
#         kg_to_s = const.G / const.c**3

#         total_mass = total_mass.to(u.kg) * kg_to_s


#     rescaled_wf = waveform.copy()

#     if isinstance(waveform, FrequencySeries):
#         rescaled_wf *= total_mass**2
#         rescaled_wf.frequencies /= total_mass
    
#         return rescaled_wf
#     elif isinstance(waveform, TimeSeries):
#         rescaled_wf *= total_mass
#         rescaled_wf.times *= total_mass
    
#         return rescaled_wf
#     else:
#         raise ValueError(
#             '`waveform` has to be either a GWPy `FrequencySeries` or'
#             ' a GWPy `TimeSeries`.'
#         )


def get_mass_scaled_wf(
    wf_params: dict[str, u.Quantity | float | int],
    domain: Literal['TD', 'FD'],
    gen: Any,
    target_unit_sys: Optional[Literal['SI', 'cosmo', 'geom']] = None
) -> FrequencySeries | TimeSeries:
    """
    Rescale a given `waveform` to be independent of the total mass
    parameter.

    Parameters
    ----------
    wf_params: dict[str, u.Quantity | float | int]
        Parameters for the waveform.
    total_mass : u.Quantity
        Value of the total mass that has been used to generate the
        `waveform`. Has to be given in SI or cosmological units.
    gen: Any
        Generator that shall be used for waveform generation, is given
        to generator argument of `~lalsimulation.gwsignal.core.waveform`.
    target_unit_sys : Literal['SI', 'cosmo', 'geom'], optional, default = None
        Unit system that `total_mass` is converted to before rescaling.

    Returns
    -------
    FrequencySeries | TimeSeries
        Rescaled waveform generated from `wf_params`.
    
    Notes
    -----
    This function creates time and frequency domain waveforms that are
    rescaled with the total mass M as follows:

    .. math:: h(t) \\rightarrow h(t / M) / M =: H(t)

    .. math:: \\tilde{h}(f) \\rightarrow \\tilde{h}(M f) / M^2 =: \\tilde{H}(f)

    Note that this changes starting and end frequency of the waveform.
    A rescaling to counter that is not applied here because it can lead
    to the f22_start property (that is either present in `wf_params` or
    taken from `lalsimulation.gwsignal.core.parameter_conventions.default_dict`
    and thus equal to 20.0 Hz) becoming too small, which leads to a
    significantly larger evaluation time of waveform generators.

    On that note, the reason that this function does not accept
    waveforms that are already generated is that it also has to be
    rescaled before the waveform generation. Otherwise, the
    transformation shown above does not work properly, which means that
    changing only the total mass in the generation and subsequent
    rescaling would not produce euqal waveforms, simply because these
    waveforms would have different reference frequencies (which causes
    inconsistent phases). However, if you do account for this, consider
    using the `~gw_signal_tools.waveform_utils.rescale_with_Mtotal` function.
    """
    import astropy.constants as const  # TODO: check if import outside of function. Then also define constants outside
    import lalsimulation.gwsignal.core.waveform as wfm
    from lalsimulation.gwsignal.core.parameter_conventions import default_dict

    if target_unit_sys is None:
        target_unit_sys = 'cosmo'

    total_mass: u.Quantity = wf_params['total_mass']


    wf_params = default_dict | wf_params

    # if 'f_max' not in wf_params.keys():
    #     wf_params['f_max'] = 1024.*u.Hz
        
    wf_params |= {
        # 'f22_start': wf_params['f22_start'] / total_mass.value,  # DO NOT DO FOR TD CASE
        'f22_ref': wf_params['f22_ref'] / total_mass.value,
        # 'f_max': wf_params['f_max'] / total_mass.value,
    }
    # NOTE: /= operator overwrites original dictionary...
    
    logging.debug(total_mass)
    logging.debug(wf_params)
    
    # wf_params['f22_ref'] /= total_mass.value
    # wf_params['f22_start'] = wf_params['f22_ref']

    # TODO: return both plus and cross polarization

    if target_unit_sys == 'cosmo':
        total_mass = total_mass.to(u.solMass)
    elif target_unit_sys == 'SI':
        total_mass = total_mass.to(u.kg)
    elif target_unit_sys == 'geom':
        kg_to_s = const.G / const.c**3

        total_mass = total_mass.to(u.kg) * kg_to_s

    if domain == 'FD':
        rescaled_wf, _ = wfm.GenerateFDWaveform(wf_params, gen)
        
        rescaled_wf /= total_mass**2
        rescaled_wf.frequencies *= total_mass
    
        return rescaled_wf
    elif domain == 'TD':
        rescaled_wf, _ = wfm.GenerateTDWaveform(wf_params, gen)

        rescaled_wf /= total_mass
        rescaled_wf.times /= total_mass
    
        return rescaled_wf
    else:
        raise ValueError(
            '`domain` has to be either `FD` (frequency domain) or `TD`'
            ' (time domain).'
        )


def rescale_with_Mtotal(
    waveform: FrequencySeries | TimeSeries,
    total_mass: u.Quantity,
    target_unit_sys: Optional[Literal['SI', 'cosmo', 'geom']] = None
) -> FrequencySeries | TimeSeries:
    """
    Rescale a given `waveform` to be independent of the total mass
    parameter.

    Parameters
    ----------
    waveform : FrequencySeries | TimeSeries
        Waveform to rescale. Strain and frequencies have to be either in
        SI or cosmological units.
    total_mass : u.Quantity
        Value of the total mass that has been used to generate the
        `waveform`. Has to be given in SI or cosmological units.
    target_unit_sys : Literal['SI', 'cosmo', 'geom'], optional, default = None
        Unit system that `total_mass` is converted to before rescaling.

    Returns
    -------
    FrequencySeries or TimeSeries
        Rescaled version of `waveform`.

    Notes
    -----
    This function expects that you have paid attention to frequencies
    during waveform generation. For details on what this means, refer to
    the notes of `~gw_signal_tools.waveform_utils.get_mass_scaled_wf`.
    """
    import astropy.constants as const  # TODO: check if import outside of function. Then also define constants outside

    if target_unit_sys is None:
        target_unit_sys = 'cosmo'

    if target_unit_sys == 'cosmo':
        total_mass = total_mass.to(u.Msun)
    elif target_unit_sys == 'SI':
        total_mass = total_mass.to(u.kg)
    elif target_unit_sys == 'geom':
        kg_to_s = const.G / const.c**3

        total_mass = total_mass.to(u.kg) * kg_to_s


    rescaled_wf = waveform.copy()

    if isinstance(waveform, FrequencySeries):
        rescaled_wf /= total_mass**2
        rescaled_wf.frequencies *= total_mass
    
        return rescaled_wf
    elif isinstance(waveform, TimeSeries):
        rescaled_wf /= total_mass
        rescaled_wf.times /= total_mass
    
        return rescaled_wf
    else:
        raise ValueError(
            '`waveform` has to be either a GWPy `FrequencySeries` or'
            ' a GWPy `TimeSeries`.'
        )
    

def scale_to_Mtotal(
    waveform: FrequencySeries | TimeSeries,
    total_mass: u.Quantity,
    unit_sys: Optional[Literal['SI', 'cosmo', 'geom']] = None
) -> FrequencySeries | TimeSeries:
    """
    _summary_

    Parameters
    ----------
    waveform : FrequencySeries | TimeSeries
        Output will be in SI units.
    total_mass : u.Quantity
        _description_
    unit_sys : Literal['SI', 'cosmo', 'geom'], optional, default = None
        _description_, by default None

    Returns
    -------
    FrequencySeries | TimeSeries
        _description_

    Raises
    ------
    ValueError
        _description_
    """
    import astropy.constants as const  # TODO: check if import outside of function. Then also define constants outside

    if unit_sys is None:
        unit_sys = 'cosmo'

    if unit_sys == 'cosmo':
        total_mass = total_mass.to(u.solMass)
    elif unit_sys == 'SI':
        total_mass = total_mass.to(u.kg)
    elif unit_sys == 'geom':
        kg_to_s = const.G / const.c**3

        total_mass = total_mass.to(u.kg) * kg_to_s


    rescaled_wf = waveform.copy()

    if isinstance(waveform, FrequencySeries):
        rescaled_wf *= total_mass**2
        rescaled_wf.frequencies /= total_mass
    
        return rescaled_wf
    elif isinstance(waveform, TimeSeries):
        rescaled_wf *= total_mass
        rescaled_wf.times *= total_mass
    
        return rescaled_wf
    else:
        raise ValueError(
            '`waveform` has to be either a GWPy `FrequencySeries` or'
            ' a GWPy `TimeSeries`.'
        )