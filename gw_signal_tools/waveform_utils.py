import numpy as np

import astropy.units as u

from gwpy.timeseries import TimeSeries
from gwpy.frequencyseries import FrequencySeries

import lalsimulation.gwsignal.core.waveform as wfm


from .test_utils import allclose_quantity

from typing import Optional, Literal, Any
import logging


__doc__ = """
Waveform helpers for work with waveforms generated by gwsignal.
"""


# ---------- Fourier Transformation ----------
# TODO: we should probably set epoch to be consistent... Although this
# would slow down the FT perhaps...
def td_to_fd_waveform(signal: TimeSeries) -> FrequencySeries:
    """
    Transform given `signal` to Fourier domain. Note that the output is
    normalized to represent the continuous frequency components, not the
    discrete ones. Furthermore, a phase shift is applied to account for
    the starting of `signal`.

    Parameters
    ----------
    signal : ~gwpy.timeseries.TimeSeries
        Signal to be transformed.

    Returns
    -------
    out : ~gwpy.frequencyseries.FrequencySeries
        Transformed signal.

    See also
    --------
    numpy.fft.rfft : Fourier transformation routine used.
    """

    # Get Fourier coefficients and corresponding frequencies
    if np.iscomplexobj(signal):
        # rfft not sufficient, need fft
        out = FrequencySeries(
            np.fft.fftshift(np.fft.fft(signal)) * signal.dx,  # Discrete -> continuous
            frequencies=np.fft.fftshift(np.fft.fftfreq(signal.size, d=signal.dx.value)) << 1 / signal.dx.unit,
            unit=signal.unit * signal.dx.unit,  # Make sure numpy functions carry unit correctly
            name=('Fourier transform of '
                + signal.name if signal.name is not None else None),
            channel=signal.channel
        )
    else:
        out = FrequencySeries(
            np.fft.rfft(signal) * signal.dx,  # Discrete -> continuous
            frequencies=np.fft.rfftfreq(signal.size, d=signal.dx.value) << 1 / signal.dx.unit,
            unit=signal.unit * signal.dx.unit,  # Make sure numpy functions carry unit correctly
            name=('Fourier transform of '
                + signal.name if signal.name is not None else None),
            channel=signal.channel
        )
    
    # Account for non-zero starting time
    out *= np.exp(-1.j * 2 * np.pi * out.frequencies * signal.t0)
    
    return out


def fd_to_td_waveform(
    signal: FrequencySeries,
    f_range: Optional[list[float] | list[u.Quantity]] = None
) -> TimeSeries:
    """
    Transform given `signal` to time domain. Note that the input is
    expected to be normalized according to `td_to_fd_waveform`, i.e. so
    that the components in `signal` are continuous frequency components.

    Parameters
    ----------
    signal : ~gwpy.frequencyseries.FrequencySeries
        Signal to be transformed
    f_range : list[float] or list[~astropy.units.Quantity], optional,
    default = None
        Range of frequency components to take into account. Is used as
        input for `restrict_f_range` function.

    Returns
    -------
    out : ~gwpy.timeseries.TimeSeries
        Transformed signal.

    Raises
    ------
    ValueError
        If `f_range` does not contain exactly two elements.

    See also
    --------
    numpy.fft.irfft : Inverse Fourier transformation routine used.
    """

    if f_range is not None:
        if len(f_range) != 2:
            raise ValueError(
                '`f_range` must contain lower and upper frequency bounds.'
            )

        signal = restrict_f_range(signal, fill_range=f_range)


    # Check if irfft can be performed or full ifft needed
    if signal.f0 == 0.0:
        dt = 1 / (2 * (signal.size - 1) * signal.df)
        # NOTE: 2*(n-1) follows normalization that happens according to the docs:
        # https://numpy.org/doc/stable/reference/generated/numpy.fft.irfft.html

        out = TimeSeries(
            np.fft.irfft(signal / dt),
            unit=signal.unit / dt.unit,  # Make sure numpy functions carry unit correctly
            t0=0.0 * dt.unit,
            dt=dt,  # Units might not be s, thus no use of .to()
            name=('Inverse Fourier transform of '
                + signal.name if signal.name is not None else None),
            channel=signal.channel
        )
    elif signal.f0 < 0.0:
        # if shifted_frequs:=np.fft.ifftshift(signal.frequencies)[0] != 0.0:
        if np.fft.ifftshift(signal.frequencies)[0] != 0.0:
            raise ValueError(
                '`signal` does not have correct format for ifft. Please check '
                'https://numpy.org/doc/stable/reference/generated/numpy.fft.ifft.html#numpy.fft.ifft'
                'for the requirements regarding frequency range.'
            )

        dt = 1 / (signal.size * signal.df)
        # Note: follows normalization that happens according to the docs:
        # https://numpy.org/doc/stable/reference/generated/numpy.fft.ifft.html

        out = TimeSeries(
            np.fft.ifft(np.fft.ifftshift(signal) / dt),
            unit=signal.unit / dt.unit,  # Make sure numpy functions carry unit correctly
            t0=0.0 * dt.unit,
            dt=dt,  # Units might not be s, thus no use of .to()
            name=('Inverse Fourier transform of '
                + signal.name if signal.name is not None else None),
            channel=signal.channel
        )
    else:
        raise ValueError(
            'Signal starts at positive frequency. Need either f0=0 (for irfft)'
            ' or negative f0 (for ifft).'
        )


    # Handle wrap-around of signal
    # TODO: put this in separate function cyclic_shift?
    # TODO: once epoch is given for FreqSeries, no wrap-around should be
    # needed, right? Thus maybe use if-condition here and only roll if t0=0.0?
    # -> ah no, wrap-around would still occur, has to be kept in (maybe without shift then)
    number_to_roll = out.size * 7 // 8  # Arbitrary value, no deep meaning
    out = np.roll(out, shift=number_to_roll)

    # out.times -= out.times[number_to_roll]  # Equivalent to following
    out.shift(-7 / 8 * out.duration)  # Note: 7 / 8 * out.duration = out.times[number_to_roll]

    # TODO: make optional argument taper? TimeSeries has built-in function
    # .taper() to handle this
    # out = out.taper(duration=out.duration.value / 6.0)  # Default is side='leftright'
    # out = out.taper(duration=out.duration.value / 2.0, side='right')
    # out = out.taper(duration=out.duration.value / 5.0, side='right')

    # -> uhhhh, np.hanning(number_of_points) is nice; for other windows, see
    # https://numpy.org/doc/stable/reference/routines.window.html

    return out



# ---------- Inner Product Helpers ----------
def pad_to_get_target_df(
    signal: TimeSeries,
    df: float | u.Quantity
) -> TimeSeries:
    """
    Pads `signal` with zeros after its end until a fft of it has desired
    resolution of `df`. If the resolution is already at the required
    level, it does not nothing (i.e. this function is not suited for
    getting a smaller df, which would require cropping of the
    time-domain signal; to do this, `FrequencySeries.interpolate` can
    be applied to the Fourier transform instead).

    Parameters
    ----------
    signal : ~gwpy.timeseries.TimeSeries
        Signal that will be padded.
    df : float or ~astropy.units.Quantity
        Desired resolution in frequency domain.

    Returns
    -------
    padded_signal : ~gwpy.timeseries.TimeSeries
        Padded signal, still in time domain.
    """
    # Handle units
    frequ_unit = 1/signal.times.unit

    try:
        df = u.Quantity(df, unit=frequ_unit)
    except u.UnitConversionError:
        # Conversion only fails if df is already Quantity and has
        # non-matching unit, so we can assume that df.unit works
        raise ValueError(
            f'Need consistent frequency units for `df` ({df.unit}) and'
            f' signals ({frequ_unit}).'
        )


    # Compute what would be current df
    df_current = 1.0 / (signal.size * signal.dt)

    if df_current > df:
        target_sample_number = int(1.0 / (signal.dt * df))

        number_to_append = target_sample_number - signal.size

        padding_series = TimeSeries(
            np.zeros(number_to_append),
            unit=signal.unit,
            t0=signal.times[-1] + signal.dt,
            dt=signal.dt
        )

        padded_signal = signal.append(padding_series, inplace=False)
    else:
        # Nothing has to be done
        padded_signal = signal

    return padded_signal


def restrict_f_range(
    signal: FrequencySeries,
    f_range: Optional[tuple[float, float] | tuple[u.Quantity, u.Quantity]] = None,
    fill_val: float | u.Quantity = 0.0,
    fill_range: Optional[tuple[float, float] | tuple[u.Quantity, u.Quantity]] = None,
    copy: bool = True
) -> FrequencySeries:
    """
    Pad 'signal' to frequencies specified by `f_range`, while
    potentially setting its values in the interval `fill_range` to a
    fixed value.

    Parameters
    ----------
    signal : ~gwpy.frequencyseries.FrequencySeries
        Signal to be restricted.
    f_range : list[float] or list[~astropy.units.Quantity]
        Two-tuple specifying lower and upper frequency bounds of the
        returned signal. Based on this value, `signal` will either be
        padded with `fill_val` or trimmed.
    fill_val : float or ~astropy.units.Quantity, optional, default = 0.0
        Value that will be used to fill `signal` outside of `f_range`.
    fill_range : list[float] or list[~astropy.units.Quantity], optional,
    default = False
        Two-tuple specifying lower and upper frequency bounds where the
        returned signal is filled with `fill_val`.

        Main usecase is preparation for an inverse Fourier
        transformation, where certain frequency ranges are required.
    copy : bool, optional, default = True
        Determines if the input signal is copied before performing
        operations or not. Note that not all of them are (can be)
        performed inplace, so setting copy to False does still not mean
        the output signal will be equal to the input after calling the
        function.
    
    Returns
    -------
    ~gwpy.frequencyseries.FrequencySeries
        Copy of signal where values outside of `f_range` have been
        changed. If the interval defined by `f_range` is larger than the
        one spanned by `signal.frequencies`, no entry will be changed.

    Raises
    ------
    ValueError
        If `f_range`, `fill_range` do not contain exactly two elements.
    """

    assert isinstance(signal, FrequencySeries), \
        '`signal` has to be a GWPy ``FrequencySeries``.'
    

    # ----- Handling f_range -----
    frequ_unit = signal.frequencies.unit

    if f_range is None:
        f_range = [None, None]
    elif len(f_range) != 2:
        raise ValueError(
            '`f_range` must be None or contain lower and upper frequency bounds.'
        )

    f_lower = f_range[0] if f_range[0] is not None else signal.frequencies[0]
    f_upper = f_range[1] if f_range[1] is not None else signal.frequencies[-1]

    try:
        f_lower = u.Quantity(f_lower, unit=frequ_unit)
    except u.UnitConversionError:
        raise ValueError(
            'Need consistent frequency units for `f_range` members'
            f' ({f_lower.unit}) and `signal` ({frequ_unit}).'
        )
    
    try:
        f_upper = u.Quantity(f_upper, unit=frequ_unit)
    except u.UnitConversionError:
        raise ValueError(
            'Need consistent frequency units for `f_range` members'
            f' ({f_upper.unit}) and `signal` ({frequ_unit}).'
        )
    

    # ----- Handling fill_val -----
    signal_unit = signal.unit

    try:
        fill_val = u.Quantity(fill_val, unit=signal_unit)
    except u.UnitConversionError:
        # Conversion only fails if fill_val is already Quantity and has
        # non-matching unit, so we can assume that fill_val.unit works
        raise ValueError(
            f'Need consistent units for `fill_val` ({fill_val.unit}) and'
            f' `signal` ({signal_unit}).'
        )

    
    # ----- Padding/trimming -----
    lower_number = abs(int(np.ceil((f_lower - signal.f0) / signal.df)))

    if f_lower < signal.f0:  # Equivalent to lower_number > 0
        signal = FrequencySeries(
            np.full(lower_number, fill_value=fill_val.value),
            unit=signal_unit,
            f0=f_lower,
            df=signal.df,
            name=signal.name,
            epoch=signal.epoch,
            channel=signal.channel,
            dtype=signal.dtype
        ).append(signal, inplace=True, pad=fill_val.value)
        # Properties of first series are taken in append, thus need to
        # paste all necessary properties
    elif f_lower > signal.f0:
        signal = signal[lower_number:]
    

    upper_number = abs(int(np.ceil((f_upper - signal.frequencies[-1]) / signal.df)))

    if f_upper > signal.frequencies[-1]:  # Equivalent to upper_number > 0
        signal = signal.append(
            FrequencySeries(
                np.full(upper_number, fill_value=fill_val.value),
                unit=signal_unit,
                f0=signal.frequencies[-1] + signal.df,
                df=signal.df,
                dtype=signal.dtype
            ),
            inplace=False  # Otherwise error
        )  # Could avoid copy from beginning, right?
    elif f_upper < signal.frequencies[-1]:
        signal = signal[:signal.size - upper_number]


    # ----- Filling -----
    if fill_range is None:
        fill_range = f_range
    elif len(fill_range) != 2:
        raise ValueError(
            '`fill_range` must be None or contain lower and upper frequency bounds.'
        )

    f_fill_lower = fill_range[0] if fill_range[0] is not None else f_lower
    f_fill_upper = fill_range[1] if fill_range[1] is not None else f_upper

    try:
        f_fill_lower = u.Quantity(f_fill_lower, unit=frequ_unit)
    except u.UnitConversionError:
        raise ValueError(
            'Need consistent frequency units for `fill_range` members'
            f' ({f_fill_lower.unit}) and `signal` ({frequ_unit}).'
        )
    
    try:
        f_fill_upper = u.Quantity(f_fill_upper, unit=frequ_unit)
    except u.UnitConversionError:
        raise ValueError(
            'Need consistent frequency units for `f_range` members'
            f' ({f_fill_upper.unit}) and `signal` ({frequ_unit}).'
        )
    

    if f_fill_lower < f_lower:
        logging.info(
            f'Lower bound {f_fill_lower} in `fill_range` is smaller '
            f'than the signals smallest frequency {f_lower}. Please be '
            'aware that this function does nothing to change that, i.e.'
            ' no padding is applied (adjust `f_range` for that).'
        )

        f_fill_lower = f_lower
    
    if f_fill_upper > f_upper:
        logging.info(
            f'Upper bound {f_fill_upper} in `fill_range` is larger '
            f'than the signals largest frequency {f_upper}. Please be '
            'aware that this function does nothing to change that, i.e.'
            ' no padding is applied (adjust `f_range` for that).'
        )

        f_fill_upper = f_upper


    if (copy and (lower_number == 0)
        and (f_fill_lower != f_lower) and (f_fill_upper != f_upper)):  # Check if fill_f_range will do something
        # Signal shall not be edited inplace and has not been copied in
        # previous beforehand in function
        signal = signal.copy()

    signal = fill_f_range(signal, fill_val, [f_fill_lower, f_fill_upper])

    return signal


def fill_f_range(
    signal: FrequencySeries,
    fill_val: float | u.Quantity,
    fill_bounds: tuple[float, float] | tuple[u.Quantity, u.Quantity]
) -> FrequencySeries:
    """
    Fills `signal` with `fill_val` outside of interval provided in
    `fill_range`. Note that this function operates inplace, i.e. the
    input is changed.

    Parameters
    ----------
    signal : FrequencySeries
        Signal to be (potentially) filled.
    fill_val : float or ~astropy.units.Quantity
        Value to fill with.
    fill_bounds : tuple[float, float] or tuple[~astropy.units.Quantity,
    ~astropy.units.Quantity]
        Bounds of interval outside of which `signal` is filled. Must
        have length 2, but members can be None to indicate that no
        filling shall be done on the respective end of the interval.

    Returns
    -------
    FrequencySeries
        Edited input `signal`.

    Raises
    ------
    ValueError
        If `fill_bounds` is does not have two elements.
    ValueError
        If members of `fill_bounds` have frequency units that are
        incompatible with the frequency units of `signal`.
    """
    frequ_unit = signal.frequencies.unit

    f_lower, f_upper = signal.f0, signal.frequencies[-1]


    if len(fill_bounds) != 2:
        raise ValueError(
            '`fill_bounds` must contain lower and upper frequency bounds.'
        )
    

    if (f_fill_lower := fill_bounds[0]) is not None:
        try:
            f_fill_lower = u.Quantity(f_fill_lower, unit=frequ_unit)
        except u.UnitConversionError:
            raise ValueError(
                'Need consistent frequency units for `fill_range` members'
                f' ({f_fill_lower.unit}) and `signal` ({frequ_unit}).'
            )
        
        if f_fill_lower < f_lower:
            logging.info(
                f'Lower bound {f_fill_lower} in `fill_bounds` is '
                f'smaller than the signals smallest frequency {f_lower}'
                '. Please be aware that this function does nothing to '
                'change that, i.e. no padding is applied.'
            )
        else:
            lower_number_to_fill = int(np.ceil((f_fill_lower - f_lower) / signal.df))
            signal[:lower_number_to_fill].fill(fill_val)


    if (f_fill_upper := fill_bounds[1]) is not None:
        try:
            f_fill_upper = u.Quantity(f_fill_upper, unit=frequ_unit)
        except u.UnitConversionError:
            raise ValueError(
                'Need consistent frequency units for `f_range` members'
                f' ({f_fill_upper.unit}) and `signal` ({frequ_unit}).'
            )
        

        if f_fill_upper > f_upper:
            logging.info(
                f'Upper bound {f_fill_upper} in `fill_bounds` is larger'
                f' than the signals end frequency {f_upper}. Please be'
                ' aware that this function does nothing to change that,'
                ' i.e. no padding is applied.'
            )
        else:
            upper_number_to_fill = int(np.ceil((f_upper - f_fill_upper) / signal.df))
            signal[signal.size - upper_number_to_fill:].fill(fill_val)

    return signal


def get_signal_at_target_df(
    signal: FrequencySeries,
    df: float | u.Quantity,
    full_metadata: bool = True
) -> FrequencySeries:
    """
    Return `signal` with required frequency spacing `df`. This is either
    done by interpolating or by copying.

    This functions main purpose is to be used in 

    Parameters
    ----------
    signal : ~gwpy.frequencyseries.FrequencySeries
        _description_
    df : float or ~astropy.units.Quantity
        _description_
    full_metadata : bool, optional, default = True
        If `True`, all metadata of the FrequencySeries will be copied.
        If `False`, only values, unt and frequencies are copied (all
        other metadata like name, epoch are discarded)

    Returns
    -------
    ~gwpy.frequencyseries.FrequencySeries
        Signal with desired resolution.

    Notes
    -----
    The option `full_metadata` is motivated by the fact that copying the
    metadata (in particular the epoch) goes along with a notable
    slowdown of copying. This is not desirable in applications where
    speed matters and the metadata is not needed (for example in the
    inner product from ~gw_signal_tools.inner_product).
    """

    if np.isclose(signal.df, df, atol=0.0, rtol=0.01):
        if full_metadata:
            return signal.copy()
        else:
            # Essentially custom copy of properties needed in inner_product
            return FrequencySeries(
                signal.value,
                unit=signal.unit,
                frequencies=signal.frequencies
            )
    else:
        if full_metadata:
            return signal.interpolate(df.value)
        else:
            return FrequencySeries(
                signal.interpolate(df.value),
                epoch=signal.epoch,
                name=signal.name,
                channel=signal.channel
            )
        
    
def get_signal_at_target_frequs(
    signal: FrequencySeries,
    target_frequencies: np.ndarray | u.Quantity,
    fill_val: u.Quantity = np.nan,
    fill_bounds: Optional[tuple[float, float] | tuple[u.Quantity, u.Quantity]] = None
) -> FrequencySeries:
    """
    Interpolate and pad input `signal` so that it spans the frequency
    interval given by `target_frequencies`, while potentially being
    filled with a specific value outside of the interval given by
    `fill_bounds`.

    Parameters
    ----------
    signal : FrequencySeries
        _description_
    target_frequencies : ~numpy.array or ~astropy.units.Quantity
        _description_
    fill_val : ~astropy.units.Quantity, optional, default = ~numpy.nan
        _description_
    fill_bounds : ~numpy.array or ~astropy.units.Quantity, optional,
    default = None
        In case only a certain region inside of `target_frequencies`
        is supposed to not (!) be filled with `fill_val`, the
        boundaries of this region can be specified here.
        Must have length 2 if not None.

    Returns
    -------
    FrequencySeries
        Input signal in required format.

    See also
    -----
    numpy.interp : Interpolation and padding routine used.
    gw_signal_tools.restrict_f_range : Filling routine used.
    """

    # ----- Handling frequency input -----
    frequ_unit = signal.frequencies.unit

    try:
        target_frequencies = u.Quantity(target_frequencies, unit=frequ_unit)
    except u.UnitConversionError:
        raise ValueError(
            # 'Cannot sample to frequencies with different units.'
            'Need consistent frequency units for `target_frequencies` '
            f'({target_frequencies.unit}) and signal ({frequ_unit}).'
        )


    # ----- Handling fill_val -----
    signal_unit = signal.unit

    try:
        fill_val = u.Quantity(fill_val, unit=signal_unit)
    except u.UnitConversionError:
        # Conversion only fails if fill_val is already Quantity and has
        # non-matching unit, so we can assume that fill_val.unit works
        raise ValueError(
            f'Need consistent units for `fill_val` ({fill_val.unit}) and'
            f' `signal` ({signal_unit}).'
        )
    

    # ----- Actual computations -----
    if (signal.frequencies.size == target_frequencies.size
        and allclose_quantity(signal.frequencies,
                              target_frequencies,
                              atol=0.5 * signal.df.value, rtol=0.00)):
        out = FrequencySeries(
            signal.value,
            unit=signal.unit,
            frequencies=signal.frequencies
        )
    else:
        out = FrequencySeries(
            np.interp(target_frequencies, signal.frequencies, signal,
                      left=fill_val.value, right=fill_val.value),
            unit=signal.unit,
            frequencies=target_frequencies
        )
    
    if fill_bounds is not None:
        out = fill_f_range(
            out,
            fill_val=fill_val,
            fill_bounds=fill_bounds
        )

    return out


# ---------- Wrapper function for strain generation ----------
def get_strain(
    intrinsic_params: dict[str, float | u.Quantity],
    domain: Literal['time', 'frequency'],
    generator: Any,
    extrinsic_params: Optional[dict[str, str | u.Quantity]] = None,
    mode: Optional[Literal['plus', 'cross', 'mixed']] = None
) -> Any:
    """
    Wrapper function that allows to generate various types of
    gravitational wave strain.

    Parameters
    ----------
    intrinsic_params : dict[str, float or ~astropy.units.Quantity]
        Parameters to use for waveform generation. Is passed straight to
        `~lalsimulation.gwsignal.core.waveform.GenerateTDWaveform` or
        `~lalsimulation.gwsignal.core.waveform.GenerateFDWaveform`,
        depending on the value of `domain`.
    domain : Literal['time', 'frequency']
        Determines domain that waveform is generated in.
    generator : Any
        Instance of `~lalsimulation.gwsignal.core.waveform.
        LALCompactBinaryCoalescenceGenerator` class that is used for
        waveform generation.
    extrinsic_params : dict[str, str or ~astropy.units.Quantity],
    optional, default = None
        All arguments required to call `~lalsimulation.gwsignal.core.gw.
        GravitationalWavePolarizations.strain`.
        If None, no projection on a detector is performed.         
    mode : Literal['plus', 'cross', 'mixed'], optional, default = None
        If output is not projected on a detector (i.e.
        `extrinsic_params` is `None`), this argument determines which
        strain is returned. Can be `'plus'` (only plus polarization is
        returned), `'cross'` (only cross polarization is returned) or
        `'mixed'` (combination :math:`h = h_+ - i h_{\\cross}` is returned).

    Returns
    -------
    Any
        Gravitational wave strain.
    """
    
    if domain == 'time':
        generator_func = wfm.GenerateTDWaveform
        temp_factor = 1.0  # TODO: change unit once lal gets it right
    elif domain == 'frequency':
        generator_func = wfm.GenerateFDWaveform
        temp_factor = u.s  # TODO: change unit once lal gets it right
    else:
        raise ValueError(
            'Invalid domain, select either `\'time\'` or `\'frequency\'`.'
        )

    expected_extr_params = ['det', 'ra', 'dec', 'psi', 'tgps']

    if (extrinsic_params is not None
        and any(param in expected_extr_params for param in extrinsic_params)):
        return_detector_output = True

        if not all(param in expected_extr_params for param in extrinsic_params):
            raise ValueError('Need complete set of extrinsic parameters.')    
    else:
        return_detector_output = False

    
    if mode is None:
        mode = 'plus'
    else:
        if return_detector_output:
            logging.info(
                '`mode` argument has been set, but is ignored because '
                'extrinsic parameters have been passed.'
            )
    

    if return_detector_output:
        return generator_func(intrinsic_params, generator).strain(**extrinsic_params) * temp_factor  # TODO: change unit once lal gets it right
    else:
        match mode:
            case 'plus':
                return generator_func(intrinsic_params, generator)[0] * temp_factor  # TODO: change unit once lal gets it right
            case 'cross':
                return generator_func(intrinsic_params, generator)[1] * temp_factor  # TODO: change unit once lal gets it right
            case 'mixed':
                hp, hc = generator_func(intrinsic_params, generator)

                # NOTE: we choose to construct strain according to the LAL
                # convention, i.e. as h_+ + i * h_x and not according to
                # h_+ - i * h_x

                if domain == 'time':
                    return hp + 1.j * hc
                else:
                    # Need to specify negative Fourier components as well
                    return FrequencySeries(
                        np.flip((np.conjugate(hp) + 1.j * np.conjugate(hc))[1:]),
                        f0=-hp.frequencies[-1],
                        df=hp.df
                    ).append(hp + 1.j * hc, inplace=True) * temp_factor  # TODO: change unit once lal gets it right
            case _:
                raise ValueError('Invalid `mode`.')


# ---------- Mass Rescaling ----------
# TODO: decide if function still makes sense. No simple rescaling of
# input waveform is possible, only generation of new one (for frequ domain)
def get_mass_scaled_wf(
    wf_params: dict[str, u.Quantity | float | int],
    domain: Literal['time', 'frequency'],
    gen: Any,
    target_unit_sys: Optional[Literal['SI', 'cosmo', 'geom']] = None
) -> FrequencySeries | TimeSeries:  # pragma: no cover
    """
    Rescale a given `waveform` to be independent of the total mass
    parameter.

    Parameters
    ----------
    wf_params : dict[str, u.Quantity | float | int]
        Parameters for the waveform.
    domain : Literal['time', 'frequency']
    total_mass : u.Quantity
        Value of the total mass that has been used to generate the
        `waveform`. Has to be given in SI or cosmological units.
    gen : Any
        Generator that shall be used for waveform generation, is given
        to generator argument of `~lalsimulation.gwsignal.core.waveform`.
    target_unit_sys : Literal['SI', 'cosmo', 'geom'], optional, default = None
        Unit system that `total_mass` is converted to before rescaling.

    Returns
    -------
    ~gwpy.frequencyseries.FrequencySeries or ~gwpy.timeseries.TimeSeries
        Rescaled waveform generated from `wf_params`.
    
    Notes
    -----
    This function creates time and frequency domain waveforms that are
    rescaled with the total mass M as follows:

    .. math:: h(t) \\rightarrow h(t / M) / M =: H(t)

    .. math:: \\tilde{h}(f) \\rightarrow \\tilde{h}(M f) / M^2 =: \\tilde{H}(f)

    Note that this changes starting and end frequency of the waveform.
    A rescaling to counter that is not applied here because it can lead
    to the f22_start property (that is either present in `wf_params` or
    taken from `lalsimulation.gwsignal.core.parameter_conventions.default_dict`
    and thus equal to 20.0 Hz) becoming too small, which leads to a
    significantly larger evaluation time of waveform generators.

    On that note, the reason that this function does not accept
    waveforms that are already generated is that it also has to be
    rescaled before the waveform generation. Otherwise, the
    transformation shown above does not work properly, which means that
    changing only the total mass in the generation and subsequent
    rescaling would not produce euqal waveforms, simply because these
    waveforms would have different reference frequencies (which causes
    inconsistent phases). However, if you do account for this, consider
    using the `~gw_signal_tools.waveform_utils.rescale_with_Mtotal` function.
    """
    import astropy.constants as const
    # from lalsimulation.gwsignal.core.parameter_conventions import default_dict

    if target_unit_sys is None:
        target_unit_sys = 'cosmo'

    total_mass: u.Quantity = wf_params['total_mass']


    # if domain == 'frequency':
    #     wf_params['f22_start'] = wf_params['f22_start'] / total_mass.value
        # Doing this for TD case can make wf generation take ages
    # wf_params['f_max'] = wf_params['f_max'] / total_mass.value
    # Rescaling bounds is not a good idea, we do not know the value that
    # comes out in the end

    wf_params['f22_ref'] = wf_params['f22_ref'] / total_mass.value

    # NOTE: /= operator overwrites original dictionary, thus not used
    
    logging.debug(total_mass)
    logging.debug(wf_params)
    

    if target_unit_sys == 'cosmo':
        total_mass = total_mass.to(u.solMass)
    elif target_unit_sys == 'SI':
        total_mass = total_mass.to(u.kg)
    elif target_unit_sys == 'geom':
        kg_to_s = const.G / const.c**3

        total_mass = total_mass.to(u.kg) * kg_to_s

    if domain == 'frequency':
        rescaled_wf_p, rescaled_wf_c = wfm.GenerateFDWaveform(wf_params, gen)
        
        rescaled_wf_p /= total_mass**2
        rescaled_wf_p.frequencies *= total_mass

        rescaled_wf_c /= total_mass**2
        rescaled_wf_c.frequencies *= total_mass
    
        return rescaled_wf_p, rescaled_wf_c
    elif domain == 'time':
        rescaled_wf_p, rescaled_wf_c = wfm.GenerateTDWaveform(wf_params, gen)

        rescaled_wf_p /= total_mass
        rescaled_wf_p.times /= total_mass
        rescaled_wf_c /= total_mass
        rescaled_wf_c.times /= total_mass
    
        return rescaled_wf_p, rescaled_wf_c
    else:
        raise ValueError(
            '`domain` has to be either `frequency` or `time`.'
        )
